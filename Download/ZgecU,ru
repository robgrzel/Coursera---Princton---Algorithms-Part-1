1
00:00:02,022 --> 00:00:08,015
Итак, QuickFind слишком нетороплив для больших задач. Как же

2
00:00:08,015 --> 00:00:14,035
ускорить? Нашей первой попыткой улучшить алгоритм будет Quick-union. Мы используем

3
00:00:14,035 --> 00:00:20,082
так называемый "ленивый подход" к дизайну алгоритмов, при котором мы стараемся избежать работы,

4
00:00:20,082 --> 00:00:27,506
пока не придется ею заняться. Алгоритм использует ту же структуру данных (массив id[] размера M), но теперь

5
00:00:27,506 --> 00:00:34,280
мы он имеет другой смысл. Мы будем рассматривать этот массив

6
00:00:34,280 --> 00:00:41,298
как множество деревьев, называемых лесом (изображение справа). Итак, каждый

7
00:00:41,298 --> 00:00:49,468
элемент массива будет содержать ссылку на родителя в этом дереве. Так,

8
00:00:49,468 --> 00:00:57,425
к примеру, у 3 родитель 4, у 4 родитель 9. Поэтому 3-м элементом массива будет 4,

9
00:00:57,425 --> 00:01:06,681
а 4-м будет 9. Каждый элемент массива теперь связан с

10
00:01:06,681 --> 00:01:13,179
корнем своего дерева. Элементы, расположенные отдельно,

11
00:01:13,179 --> 00:01:19,303
связаны сами с собой и указывают на себя. Так, 1 указывает на

12
00:01:19,303 --> 00:01:26,108
себя, но и 9 указывает на себя. Это корень дерева, содержащего 2,

13
00:01:26,108 --> 00:01:32,419
4 и 3. Такая структура данных позволяет нам связать каждый элемент

14
00:01:32,419 --> 00:01:40,202
с корнем, представляющим собой связную компоненту. Итак,

15
00:01:40,202 --> 00:01:47,044
корень для 3 будет 9. Как только мы сможем вычислять эти корни,

16
00:01:47,044 --> 00:01:52,956
мы сможем реализовать операцию поиска (find) просто проверяя, имеют ли проверяемые два элемента

17
00:01:52,956 --> 00:01:57,592
один и тот же корень.

18
00:01:57,592 --> 00:02:02,373
Этот вопрос эквивалентен вопросу, принадлежат ли они одной связной компоненте?

19
00:02:02,373 --> 00:02:09,240
Поиск корня каждого элемента потребует работы, но операция объединения (union) очень проста.

20
00:02:09,240 --> 00:02:15,254
Чтобы объединить компоненты, содержащие два различных элемента,

21
00:02:15,254 --> 00:02:21,613
нужно лишь установить id корня элемента P равным id корня элемента Q.

22
00:02:21,613 --> 00:02:28,748
В этом случае мы могли бы изменить 9й элемент на

23
00:02:28,748 --> 00:02:35,027
6 чтобы объединить компоненты содержащие 3 и 5. И

24
00:02:35,027 --> 00:02:41,317
мы просто изменяя одно значение в массиве объединяем две большие компоненты 

25
00:02:41,317 --> 00:02:46,295
в одну. Это алгоритм Quick-union. Из-за того что операция объединения

26
00:02:46,295 --> 00:02:52,429
включает изменение только одного элемента массива. Операция поиска требует немного больше

27
00:02:52,429 --> 00:02:57,907
работы. Рассмотрим сперва демонстрацию операции объединения.

28
00:02:57,907 --> 00:03:03,569
Мы снова начинаем с того же, но сейчас элементы массива на самом деле значат что

29
00:03:03,569 --> 00:03:09,415
каждый из них представляет маленькое дерево с одним узлом указывающим на 

30
00:03:09,415 --> 00:03:15,284
себя. Сейчас мы должны объединить 4 и 3 в 

31
00:03:15,284 --> 00:03:21,236
одну компоненту, и все что мы делаем это берем корень компоненты содержащей 

32
00:03:21,236 --> 00:03:26,624
первый элемент и делаем его наследником корня компоненты

33
00:03:26,624 --> 00:03:33,029
 содержащей второй элемент. В это случае мы просто делаем 3 родителем 4. Теперь 
3 и 8. И снова мы берем первый элемент и делаем его наследником корня

34
00:03:33,259 --> 00:03:39,823
3 и 8. И снова мы берем первый элемент и делаем его наследником корня 

35
00:03:39,823 --> 00:03:47,532
компоненты содержащей второй элемент. Теперь 3,4  и 8 в одной 

36
00:03:47,532 --> 00:03:56,434
компоненте. 6 и 5. 6 становиться под 5.8 и 4 Теперь 4

37
00:03:56,434 --> 00:04:06,045
корень дерева содержащий 4 это 8. А корень содержащий 9 

38
00:04:06,045 --> 00:04:13,745
- 9. И мы делаем 9 наследником 8. 2 и 1. это легко.

39
00:04:14,007 --> 00:04:20,993
Теперь если мы хотим узнать соединены ли 8 и 9, мы просто проверяем имеют ли

40
00:04:20,993 --> 00:04:28,011
они тот же корень. У них корень один и тот же, значит они соединены. 5

41
00:04:28,011 --> 00:04:34,230
и 4, корень 4 - 8. Корень 5 - 5. Они различны. Объекты

42
00:04:34,230 --> 00:04:42,339
не соединены. 5 и 0. 5 становится наследником 0. 7 и 2 семь становится 

43
00:04:42,339 --> 00:04:52,836
наследником корня 2, 0. 6 и 1 , корень 6 это 0, 1

44
00:04:52,836 --> 00:05:00,636
свой собственный корень, тогда 0 становится наследником 1. Каждая из эти операций объединения просто

45
00:05:00,636 --> 00:05:10,069
состоит их изменения только одного элемента массива. и наконец 7 и 3. Корень 7  

46
00:05:10,069 --> 00:05:18,755
- 1, корень 3 - 8. 1 становится наследником 8. В итоге

47
00:05:18,755 --> 00:05:26,012
 мы имеет одну связную компоненту со всеми объектами вместе. Хорошо, теперь 

48
00:05:26,012 --> 00:05:32,668
посмотрим на код реализации Quick-union. Конструктор тот же самый.

49
00:05:32,668 --> 00:05:40,967
Мы создаем массив и задаем каждый элемент своим корнем. Теперь у нас есть

50
00:05:40,967 --> 00:05:46,005
private метод реализующий процесс поиска корня

51
00:05:46,005 --> 00:05:51,352
по всем родителям пока мы не найдем элемент такой что i = ID[i],  а если

52
00:05:51,352 --> 00:05:57,369
не равны то движемся вверх в дереве, установив i как ID[i], в конце возвращаем i.

53
00:05:57,369 --> 00:06:02,005
Итак начиная с любого  узла вы просто следуете по ID, до тех пор пока i = ID[i]

54
00:06:02,005 --> 00:06:07,396
это значит вы в корне. Этот private метод мы можем использовать

55
00:06:07,396 --> 00:06:11,959
чтобы реализовать операцию поиска или операцию connected. Вы просто находите 

56
00:06:11,959 --> 00:06:17,316
корень P и корень Q и если проверяете равны ли они. Тогда операция объединения

57
00:06:17,316 --> 00:06:23,342
это просто поиск двух корней и задание второго как корень

58
00:06:23,342 --> 00:06:30,310
первого. По факту здесь меньше кода, нет цикла for. Есть

59
00:06:30,310 --> 00:06:37,139
один цикл wile, о котором стоит немного беспокоиться. Но это быстрая и 

60
00:06:37,139 --> 00:06:43,326
элегантная реализация для решения задачи динамической связности, называемая 

61
00:06:43,326 --> 00:06:50,318
Quick-union. Теперь мы должны будем рассмотреть может ли этот код эффективно решать 

62
00:06:50,582 --> 00:06:57,657
большие задачи. К сожалению Quick-Union  хоть и быстрее но еще слишком

63
00:06:57,657 --> 00:07:04,042
медленный. И его медлительность отличается от Quick-Find, есть

64
00:07:04,042 --> 00:07:10,005
случаю когда он может быть быстрым, но есть и случаю когда об слишком медленный.

65
00:07:10,005 --> 00:07:16,256
Недостаток Quick-Union в том что деревья могут быть слишком высокими. Это означает

66
00:07:16,256 --> 00:07:22,065
что операция поиска будет слишком затратной. Вы можете подниматься по длинному 

67
00:07:22,065 --> 00:07:28,432
узкому дереву. Каждый объект которого указывает на следующий, и операция поиска 

68
00:07:28,432 --> 00:07:33,976
для объекта снизу может включать проход по всему дереву.

69
00:07:34,183 --> 00:07:40,184
Затраты операции поиска включают доступ к массиву для, и

70
00:07:40,184 --> 00:07:44,013
множества таких операций будут медленными.