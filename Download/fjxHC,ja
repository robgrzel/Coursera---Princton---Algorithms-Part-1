1
00:00:00,000 --> 00:00:04,085
おかえりなさい。今日お話するのは、はunion find問題

2
00:00:04,085 --> 00:00:09,098
いわゆる動的接続問題を解くアルゴリズムのことです。

3
00:00:09,098 --> 00:00:14,091
まず、二つの古典的なアルゴリズムから始めます。Quick FIndとQuick Unionです。

4
00:00:14,091 --> 00:00:20,078
適用例を紹介し、これらのアルゴリズムの改良を考えてみます。本日の講義のサブテキストは

5
00:00:20,078 --> 00:00:27,039
使えるアルゴリズムを開発するためにこれから紹介する手順を繰り返し実施するということです。

6
00:00:27,039 --> 00:00:32,039
最初のステップは問題のモデル化です。

7
00:00:32,039 --> 00:00:37,031
基本的には解決すべき問題の主な要素がなんであるかを理解する必要があります。

8
00:00:37,031 --> 00:00:41,681
すると問題を解決するアルゴリズムをいくつか発見するようになります。多くの場合、

9
00:00:41,681 --> 00:00:46,486
多くの場合は最初に見つけたアルゴリズムが十分に高速で、メモリにも収まるものと思います。

10
00:00:46,486 --> 00:00:52,024
その場合は、どんどん先に進み、それを使っていけばよいでしょう。しかし、他の多くの場合は、

11
00:00:52,024 --> 00:00:56,074
十分な速度を得られなかったり、メモリが不足したりします。そのようなときに、私たちがやるべきことは、

12
00:00:56,074 --> 00:01:01,037
原因を突き止め、問題の原因となっているものへの対処を検討し、

13
00:01:01,037 --> 00:01:06,051
新しいアルゴリズムを見つけ、満足できるまでこれを繰り返すのです。これは

14
00:01:06,051 --> 00:01:11,099
アルゴリズムを設計、分析するときの科学的なアプローチです。そこでは、数理モデルを構築し、

15
00:01:11,099 --> 00:01:17,061
何が起きているのか理解し、モデルの確からしさを検証し、

16
00:01:17,061 --> 00:01:22,089
物事を改善する役に立つのです。まず最初に動的接続問題について、

17
00:01:22,089 --> 00:01:29,021
次にunion-findの問題のモデルついての話をします。
さて、次のように考えてみましょう。

18
00:01:29,021 --> 00:01:33,090
n個のものからなる集合があります。それらが何かは問題ではありません。

19
00:01:33,090 --> 00:01:39,002
数字のゼロからnを使って、それらをモデル化します。次に

20
00:01:39,002 --> 00:01:43,082
2つの間の接続について考えてみます。何かの命令が存在すると考えて、

21
00:01:43,082 --> 00:01:48,057
2つをつなぐことにするのです。2つのものがあり、

22
00:01:48,057 --> 00:01:53,093
それらの間に接続を考えるのです。そして、問題の重要な部分はクエリー、あるいは、

23
00:01:53,093 --> 00:01:59,097
一連のクエリーを見つけることで、そのクエリを使って、2つのものの間の経路があるかどうかを答えることができるのです。

24
00:01:59,097 --> 00:02:05,021
例えば、この集合は10個の要素があり、既に多くのunion命令を実行して、

25
00:02:05,021 --> 00:02:10,278
4と3を、3と8を、6と5を、9と4を、

26
00:02:10,278 --> 00:02:16,526
2と1を接続しています。ここで、クエリを発行し、0と7が接続されているかを問い合わせてみます。

27
00:02:16,526 --> 00:02:22,713
この場合は接続はありませんので、Noを答えることになります。しかし、

28
00:02:22,713 --> 00:02:28,281
8と9の接続を問い合わせられたら、Yesを答えることになります。8と9の間には直接の接続はありませんが、

29
00:02:28,281 --> 00:02:33,629
8から3へ、そして4へ、次に9へという経路が存在しているのです。

30
00:02:33,629 --> 00:02:39,783
そうです。これが今回の問題で、与えられた集合に対してこれら二つの命令に公式に対応することなのです。

31
00:02:39,783 --> 00:02:45,444
ここで、5と0のunionを追加します。

32
00:02:45,444 --> 00:02:51,026
5と0の間の接続をつくります。

33
00:02:51,026 --> 00:02:56,744
7と2の間の接続を構築し、6と1の間の接続を構築します。

34
00:02:56,744 --> 00:03:02,836
ここで、0と7は接続されているでしょうか？そうですね1と0もつなげることができます。これは冗長な接続ですね。

35
00:03:02,836 --> 00:03:08,528
ここで0が7と接続されているかどうか質問されたら、答えは

36
00:03:08,528 --> 00:03:13,858
Yesとなりますね。そう、これが今回の問題で、union命令と接続のクエリを組み合わせで、

37
00:03:13,858 --> 00:03:18,991
多数のものに対して、これらの命令を明確にサポートすること必要があるのです。

38
00:03:18,991 --> 00:03:23,833
ここにより大きな例があります。これに対しては効率的なアルゴリズムが必要となるのはわかりますね。

39
00:03:23,833 --> 00:03:28,128
まず最初に、コンピュータが必要ですね。

40
00:03:28,128 --> 00:03:33,085
接続があるかどうかを人間が確かめるには、相当の時間かかります。

41
00:03:33,085 --> 00:03:38,205
この場合は接続が存在します。さて、アルゴリズムは、

42
00:03:38,205 --> 00:03:43,805
私たちが今日見るものですが、それは、2つのものを接続する経路を実際に与えるものではありません。

43
00:03:43,805 --> 00:03:48,847
ただ、問い合わせに答えるだけです。経路があるかどうかいうね。

44
00:03:48,847 --> 00:03:53,721
コースの第2部では、経路を明示的に発見するアルゴリズムを検討する予定です。

45
00:03:53,721 --> 00:03:59,220
それらはunion findほどは効率的なものではありません。なぜなら、やらないといけないことが多いですから。

46
00:03:59,220 --> 00:04:05,972
このアルゴリズムはいろんな種類のものに対して適用することができます。

47
00:04:05,972 --> 00:04:11,906
デジタル写真に利用されたり、ここではピクセルが対象になります。ネットワークにも利用されています。

48
00:04:11,906 --> 00:04:17,444
ここではコンピュータが接続の対象になりますね。人のつながりを対象としてソーシャルネットワークもそうです。また、コンピュータチップ、

49
00:04:17,444 --> 00:04:23,528
回路の要素を接続する対象としています。抽象的なものにも使われます、プログラムの変数名や

50
00:04:23,528 --> 00:04:29,334
数学の集合の要素などですね。複合材料の金属部位のような物理的なものにも使われます。

51
00:04:29,334 --> 00:04:34,802
そのため、どんな種類のものに対しても、

52
00:04:34,802 --> 00:04:40,574
プログラミングのためには、それぞれの対象に対する名前をつける必要があります。ここでは

53
00:04:40,574 --> 00:04:46,810
対象を数字、0からN-1までの整数で識別することにします。プログラミングの最初の出発点としてはとても便利です。

54
00:04:46,810 --> 00:04:53,605
整数を配列のインデックスとして使うことができますから、

55
00:04:53,605 --> 00:05:00,160
すると、各対象に関連する情報に簡単にアクセスすることができますね。

56
00:05:00,160 --> 00:05:05,777
また、union findに関係ない詳細な事項を省略することができます。

57
00:05:05,777 --> 00:05:10,444
実際、対象の名前から0からN-1の整数に対するマッピングは、

58
00:05:10,444 --> 00:05:14,914
シンボルテーブルや探索アルゴリズムへの応用にみることができます。

59
00:05:14,914 --> 00:05:20,300
探索アルゴリズムはこのコースでも後ほど問題を解くためのアルゴリズムやデータ構造について学習する予定です。

60
00:05:20,501 --> 00:05:26,316
さて、接続は満たすべき2,3の抽象的な性質があります。

61
00:05:26,316 --> 00:05:33,545
みな、自然で直観的なものばかりです。

62
00:05:33,775 --> 00:05:40,563
"接続されている"というのは同値関係と仮定します。つまり、

63
00:05:40,563 --> 00:05:47,148
すべての対象は自分自身と接続されています。対称であるとします。
つまり、PがQと接続されているならば、QはPと接続されているということです。

64
00:05:47,148 --> 00:05:53,205
また、推移的です。PとQが接続され、QとRが接続されているなら、

65
00:05:53,205 --> 00:05:59,128
PとRは接続されているということです。これらの性質はとても直観的ですね。

66
00:05:59,128 --> 00:06:05,292
しかし、それらを明示して、われわれのアルゴリズムがそれを満たしていることを保証するのは重要なことです。

67
00:06:05,292 --> 00:06:12,452
同値関係があれば、対象と接続の集合が

68
00:06:12,452 --> 00:06:19,172
接続コンポーネントという部分集合に分割することができます。
接続コンポーネントは極大集合で、

69
00:06:19,172 --> 00:06:25,056
その中の対象は相互に接続されています。たとえば、ここに簡単な例を挙げましょう。

70
00:06:25,056 --> 00:06:30,936
3つの接続コンポーネントがありますね。1つ目は、対象0しかありません。2つ目は

71
00:06:30,936 --> 00:06:36,239
1と4と5があります。3つ目には、残りの4つの対象があります。

72
00:06:36,239 --> 00:06:42,244
これらのコンポーネントはそこに含まれるどの2つの対象も接続されていて、

73
00:06:42,244 --> 00:06:47,096
外側にはこれらの対象に接続されている対象がないとき、

74
00:06:47,096 --> 00:06:53,126
接続されたコンポーネントであるといいます。今回のアルゴリズムは接続コンポーネントを維持して、

75
00:06:53,126 --> 00:06:59,319
効率性を確保する予定であり、その知識を利用して、提示されたクエリに効率的に答えを返すことができるのです。

76
00:06:59,319 --> 00:07:04,949
いいですね。では、この操作を実装するためには、クエリコマンドとunionコマンドを見つける必要があります。

77
00:07:04,949 --> 00:07:09,840
また、接続コンポーネントを維持する必要があるのです。

78
00:07:09,840 --> 00:07:14,449
findコマンドは2つのオブジェクトが同じコンポーネントに入っているかどうかをチェックする必要があり、

79
00:07:14,449 --> 00:07:20,243
unionコマンドは2つのオブジェクトを含むコンポートをその合併、union、で置換するのです。

80
00:07:20,243 --> 00:07:25,872
例えば、このようなコンポーネントで、

81
00:07:25,872 --> 00:07:31,906
2と5を接続するunionコマンドが発行されたとしています。このときには必ず、

82
00:07:31,906 --> 00:07:37,965
2を含む接続コンポーネントと5を含む接続コンポーネントを併合して、

83
00:07:37,965 --> 00:07:44,453
1つの接続コンポーネントにします。そうして、接続コンポーネントを2つだけにします。

84
00:07:44,453 --> 00:07:52,821
これで、プログラミングで必要となる、データ型をきめて、

85
00:07:52,821 --> 00:07:59,122
問題を解くために実装する必要があるメソッドの仕様を考えることができるようになりました。

86
00:07:59,122 --> 00:08:04,980
典型的なJavaモデルでは、まず最初に、

87
00:08:05,224 --> 00:08:12,425
UFというクラスを作り、そこに2つのメソッド、1つはunionメソッドを実装し、

88
00:08:12,425 --> 00:08:19,052
もう一つは、bool値を返すconnectedメソッドを実装します。コンストラクターは、SR単位をとり、

89
00:08:19,052 --> 00:08:26,030
対象の数を表すものですが、対象の数を応じたデータ構造を構築します。

90
00:08:26,030 --> 00:08:31,089
ここで、対数オーダーで構築するように気をつける必要があります。

91
00:08:31,089 --> 00:08:37,029
対象の数が多くなることもありますし、操作の数についても同様です。

92
00:08:37,029 --> 00:08:42,076
unionやconnectedのオペレーションは非常に多くなることがありますので、

93
00:08:42,076 --> 00:08:48,315
このアルゴリズムは、このような状況でも効率的である必要があるのです。

94
00:08:48,315 --> 00:08:56,011
このコースでよく従うプラクティスの一つが、APIの設計をチェックすることです。

95
00:08:56,011 --> 00:09:04,029
問題に深く入りこむ前に、クライアントプラグラムを作って、

96
00:09:04,029 --> 00:09:11,050
開発しているデータ型を使ってみるのです。今回の例では、

97
00:09:11,050 --> 00:09:19,074
標準入力から情報を読み取るクライアントを作りました。最初に、整数、

98
00:09:19,074 --> 00:09:27,381
これは処理すべき対象の数を表します。次に、一連の対象の名前のペアを処理します。

99
00:09:27,381 --> 00:09:35,070
クライアントプログラムがやることは、まず、整数を標準入力から

100
00:09:35,070 --> 00:09:42,068
リードして、UFオブジェクトを生成します。次に標準入力が空になるまで、

101
00:09:42,068 --> 00:09:47,089
入力から2つの整数を読み込み、次に、それらが

102
00:09:47,089 --> 00:09:52,663
接続されていなければ、それらを接続し、プリントアウトします。接続されている場合は、

103
00:09:52,663 --> 00:09:58,266
無視します。そうです。これがテストクライアントプログラムで、このテストクライアントで

104
00:09:58,266 --> 00:10:04,702
どのような実装でも期待するように動作することを確認することができるのです。これで準備はできました。

105
00:10:04,702 --> 00:10:10,348
プログラムとして実装したいことはすべて説明し、

106
00:10:10,348 --> 00:10:15,091
実装が機能するかどうかを確認するクライアントプログラムも作ることができます。