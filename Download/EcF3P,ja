1
00:00:01,078 --> 00:00:08,004
動的接続問題を解くアルゴリズムの最初の実装を見てみましょう。

2
00:00:08,004 --> 00:00:14,012
Quick findと呼ばれているものですね。これはいわゆる欲張りアルゴリズムで、

3
00:00:14,012 --> 00:00:20,013
接続問題をとくことが出来ます。アルゴリズムで使っているデータ構造は

4
00:00:20,013 --> 00:00:25,082
対象でインデックス化された整数配列です。

5
00:00:25,082 --> 00:00:31,099
PとQの2つの対象が接続されているということは、

6
00:00:31,099 --> 00:00:39,005
配列の中の2つのエントリが同じであり、かつ、そのときに限ると考えることが出来ます。今回の10個の対象の例では、

7
00:00:39,005 --> 00:00:46,099
配列idで7つの接続が出来た後の状況を示しており、

8
00:00:46,099 --> 00:00:53,349
スライドの中央に示しています。で、ここでは、0、5、

9
00:00:53,349 --> 00:00:59,578
6はすべて同じ接続コンポーネントに含まれています。なぜなら、それらは

10
00:00:59,578 --> 00:01:05,171
同じ配列のエントリ、0になっているからです。1、2、7も皆、エントリが1で、3、4、8、

11
00:01:05,171 --> 00:01:10,664
9はすべてエントリが8になっています。つまり、このようにして、接続されていることを

12
00:01:10,664 --> 00:01:16,636
示しているのです。また明らかに。findの操作に対する高速な実装をサポートすることができます。

13
00:01:16,636 --> 00:01:22,439
配列のエントリをチェックして、それらが等しいかどうかを見ればよいですね。PとQが同じIDを持っているのかをチェックするのです。

14
00:01:22,439 --> 00:01:27,904
そう、6と1は違うIDになっています。1のIDは1で6のIDは

15
00:01:27,904 --> 00:01:34,171
0です。この2つは同じ接続コンポーネントの中には含まれていないということです。unionはもう少し難しく、

16
00:01:34,171 --> 00:01:40,981
与えられた2つの対象を含むコンポーネントを併合する必要があります。エントリが

17
00:01:40,981 --> 00:01:47,755
どちらかのIDに等しいID場合は、もう片方のIDni
すべて変更する必要があるのです。そのときには

18
00:01:47,755 --> 00:01:53,634
Pと同じものをすべてQと同じになるように変更する必要があります。

19
00:01:53,634 --> 00:01:58,898
6と1を連結するときは、0、5、6のエントリを変更する必要があります。

20
00:01:58,898 --> 00:02:04,741
6と同じ接続コンポーネントにあるもの全部です。0から1に変更します。

21
00:02:04,741 --> 00:02:10,917
これは、皆さんもわかると思いますが、対象の数が非常に大きくなるときには、ちょっと問題になります。

22
00:02:10,917 --> 00:02:16,927
なぜかというと、たくさんの値を変更することになるからです。しかし、それでも簡単に

23
00:02:16,927 --> 00:02:23,263
実装できるので、これを最初のスタート地点にします。はじめに

24
00:02:23,263 --> 00:02:31,189
どのように機能するかをお見せしましょう。そう、最初は、配列idを準備して、各エントリはそのインデックスと等しくなっています。

25
00:02:31,189 --> 00:02:37,932
こらは、すべての対象が独立であるということです。皆、

26
00:02:37,932 --> 00:02:43,918
自分自身の接続コンポーネントに入っているということですね。さあ、ここでunionオペレーションを受け取ると、そうですね、

27
00:02:43,918 --> 00:02:49,694
4が3と接続されるとします。すると、すべてのエントリ、

28
00:02:49,694 --> 00:02:56,190
IDが1番目のIDと同じIDのものをすべて、2番目のIDに変更します。この場合は、

29
00:02:56,190 --> 00:03:02,061
3と4を接続するということは、4を3に変更する必要があります。そして、

30
00:03:02,061 --> 00:03:10,259
もう少し続けてみましょう。するとどのようにしているのかを理解するようになってきます。3と8

31
00:03:10,259 --> 00:03:13,657
3と8を接続するために、こんどは3と4を8と接続する必要があります。

32
00:03:13,657 --> 00:03:19,950
これらのエントリをすべて8に変更する必要があります。いいですか？今度は、

33
00:03:19,950 --> 00:03:26,026
6と5はどうでしょう？今度も1番目のエントリを変更して、2番目と会わせる必要があります。

34
00:03:26,026 --> 00:03:32,332
そうです、6と5を接続するには、6を5に変更します。9と4はどうでしょうか？

35
00:03:32,332 --> 00:03:39,789
今度も変更する必要がありますね、9と4を接続するのですから、9のエントリを4と同じにする必要があります。

36
00:03:39,789 --> 00:03:45,325
これで、3、4、8、9ができました。皆、エントリが8になっています。

37
00:03:45,325 --> 00:03:52,365
同じ接続コンポーネントに入っていることになりますね。2と1についても、

38
00:03:52,365 --> 00:04:00,013
2を1に変更して接続します。8と9は、もう接続されています。

39
00:04:00,013 --> 00:04:06,660
配列idのエントリがもう同じですから。接続のクエリ、findは真を返します。

40
00:04:06,660 --> 00:04:13,096
既に接続されています。5と0のエントリは違っています。

41
00:04:13,096 --> 00:04:21,780
接続されていないということですから、この場合は偽を返します。接続されていないということです。

42
00:04:21,780 --> 00:04:31,617
もし、5と0を接続したいのであれば、同じように、

43
00:04:31,617 --> 00:04:39,855
5と6の両方の対応するエントリを0に変更すればよいですね。7と2は、7と２を接続しましょう。

44
00:04:39,865 --> 00:04:49,623
これは簡単ですね。6と1を接続してみます。今度は3つのエントリを変更する必要があります。

45
00:04:49,623 --> 00:04:57,899
すべて0になっているのを1に変更する必要があります。quick findのデモを見てみました。

46
00:04:57,899 --> 00:05:04,126
今度は、これを実装したプログラムを見てみましょう。いいですか？

47
00:05:04,126 --> 00:05:10,628
デモを頭に浮かべておくと、このアルゴリズムをプログラミングするのはきっと単純だと思います。

48
00:05:10,628 --> 00:05:16,518
とても面白いプログラミングの練習で、

49
00:05:16,518 --> 00:05:23,312
最初は多くの人が間違えます。では、コンストラクターからはじめます。

50
00:05:23,312 --> 00:05:29,125
プライベートな整数配列があります。これが、id配列です。このデータ構造を使って、

51
00:05:29,125 --> 00:05:33,953
実装を進めることになります。

52
00:05:33,953 --> 00:05:40,637
コンストラクターは配列を生成し、配列のインデックスに対応した値をセットしていきます。

53
00:05:40,637 --> 00:05:47,200
i番目の配列にはiをセットします。簡単ですね。findオペレーション、あるいは、connectedオペレーションです。

54
00:05:47,200 --> 00:05:53,024
これは簡単ですね。これが、quick findアルゴリズムです。2つの引数、

55
00:05:53,024 --> 00:05:58,552
PとQをとって、id配列のエントリが等しいかどうかをチェックして、その結果を返します。

56
00:05:58,552 --> 00:06:04,077
等しければ、真を返し、異なるときは偽を返します。

57
00:06:04,077 --> 00:06:09,942
複雑なオペレーションを実装しているのはunionです。そこでは、

58
00:06:09,942 --> 00:06:15,803
まず、一番目の引数に対応するidを見つけ、次に二番目の引数に対応するidを見つけます。

59
00:06:15,803 --> 00:06:21,018
次に、すべての配列を探索して、

60
00:06:21,018 --> 00:06:27,068
一番目の引数のidと等しいidのエントリを探し、そこに

61
00:06:27,068 --> 00:06:32,565
二番目の引数のidをセットするのです。これはちょっと愚直な実装ですね。

62
00:06:32,565 --> 00:06:38,156
多くの人が間違いをおかすといいましたね。ここで犯しやすい間違いは、

63
00:06:38,156 --> 00:06:43,660
ここに、一番目に取り出した値でなく、Pのidをセットしまうことです。皆さんもわかると思いますが、

64
00:06:43,660 --> 00:06:48,672
油断のならないバグです。さて、これがquick findの実装です。

65
00:06:48,672 --> 00:06:54,900
次に考えるのは、アルゴリズムがどれくらい効率的であるかということです。

66
00:06:54,900 --> 00:07:01,152
いくつか詳細の話もしますが、

67
00:07:01,152 --> 00:07:07,088
ここでは、次のような回数を考えれば十分ですね。

68
00:07:07,088 --> 00:07:12,901
コードが配列にアクセスする回数を数えるのです。実行してわかるのは、

69
00:07:12,901 --> 00:07:19,019
初期化とunion操作の両方がforループを含んでいて、配列をすべて走査しています。

70
00:07:19,019 --> 00:07:25,469
したがって、配列のエントリにアクセスした後、一定のn倍の比率でアクセスする必要があります。

71
00:07:25,469 --> 00:07:32,155
findオペレーションは高速で、配列のエントリに対するチェックは、コンスタントな回数です。

72
00:07:32,155 --> 00:07:37,829
これは問題で、union操作のコストが大きすぎるのです。

73
00:07:37,829 --> 00:07:45,708
特にn個の対象に対して、n個のunionコマンドがあるときは、合理的でないことが明らかです。

74
00:07:45,708 --> 00:07:52,515
それぞれが接続されているか、そうでないかのいずれかで平方的な時間という二次関数的な時間が必要になるのです。

75
00:07:52,515 --> 00:07:58,458
このコースを通して、繰り返し登場するテーマの一つが、

76
00:07:58,458 --> 00:08:04,531
二次関数的な時間は非常に遅いということです。

77
00:08:04,531 --> 00:08:10,796
大規模な問題では、二次関数時間のアルゴリズムは適用することはできません。なぜなら、スケールしないからです。コンピュータが

78
00:08:10,796 --> 00:08:16,305
より高速に、大規模なものになっても、二次関数的なアルゴリズムは実際はどんどん遅くなるのです。

79
00:08:16,305 --> 00:08:22,464
簡単に私が意図していることをお話しておきます。非常にラフな基準ですが、

80
00:08:22,464 --> 00:08:29,206
コンピュータは毎秒何十億もの命令を実行することができ、

81
00:08:29,206 --> 00:08:34,815
メモリには何十億ものエントリを格納することができます。つまり、

82
00:08:34,815 --> 00:08:40,916
メモリ上のすべてのエントリに約１秒以内でアクセスすることができます。このような

83
00:08:40,916 --> 00:08:46,907
不思議なことに、このような基準が50~60年もの間用いられてきました。コンピューターは

84
00:08:46,907 --> 00:08:52,735
より大きくなりましたが、同時により高速にもなったので、メモリを全部アクセスするのに２、３秒ですむというものです。

85
00:08:52,735 --> 00:08:57,403
メモリ上にあるのが数千ワードのであれば正しいですし、

86
00:08:57,403 --> 00:09:04,657
数十億、それ以上の場合でも大丈夫です。ですから

87
00:09:04,657 --> 00:09:11,873
コンピューターはこのようなものだとしましょう。これは、巨大なメモリ空間があれば、

88
00:09:11,873 --> 00:09:17,712
巨大な問題を解決することができるということです。数十億の対象がある場合も、そこで

89
00:09:17,712 --> 00:09:23,608
数十億のunionコマンドを実行することは期待できるでしょう。しかし、問題はquick findアルゴリズムで、

90
00:09:23,608 --> 00:09:29,770
10の18乗のオペレーション、あるいは、配列への操作やメモリアクセスが必要になるのです。

91
00:09:29,770 --> 00:09:35,098
簡単な計算で、三十数年もの計算時間となることがわかります。

92
00:09:35,098 --> 00:09:42,033
現在のコンピューターでこのような問題を解くことは現実的ではないですね。

93
00:09:42,033 --> 00:09:48,057
また、理由、問題は二次関数的なアルゴリズムが技術に対してスケールしないことです。

94
00:09:48,057 --> 00:09:54,097
十倍の速さの新しいコンピュータがあれば、

95
00:09:54,097 --> 00:10:00,033
十倍の大きさの問題を解決しようとします。しかし、二次関数的な

96
00:10:00,033 --> 00:10:06,028
アルゴリズムを使うと、十倍遅くなってしまうのです。

97
00:10:06,028 --> 00:10:11,048
このような状況を回避するために、より効率的なアルゴリズムを開発し、

98
00:10:11,048 --> 00:10:13,020
このような問題を解く必要があるのです。