1
00:00:01,034 --> 00:00:06,408
现在，我们已经讲了运行时间。我们也该讲讲程序的

2
00:00:06,408 --> 00:00:11,047
内存需求了。从根本上讲就是我们想要知道

3
00:00:11,047 --> 00:00:16,088
程序需要多少比特或者字节，8个比特是一个字节。实际上

4
00:00:16,088 --> 00:00:22,064
我们以考虑上百万比特或者几十亿比特，令人惊讶的是

5
00:00:22,064 --> 00:00:27,608
这些基本概念都存在一些矛盾。计算机科学家

6
00:00:27,608 --> 00:00:34,683
认为的一百万比特是2的20次方个，十亿比特是2的30次方，因为这是

7
00:00:34,683 --> 00:00:40,949
30个比特中能够存下的不同的数，这样与计算中的东西就是一致的

8
00:00:40,949 --> 00:00:46,889
其他的科学家因为一系列的原因坚持使用10的6次方和10的9次方

9
00:00:46,889 --> 00:00:54,014
我们通常使用2^20表示兆字节 MB。现在老的计算机

10
00:00:54,014 --> 00:01:00,437
我们用了很多年的32位系统，里面的指针是4个字节的

11
00:01:00,662 --> 00:01:07,042
近几年我们基本都迁移到了新的计算模型，机器是64位的

12
00:01:07,042 --> 00:01:12,765
指针是8个字节。这使得我们能够对大得多的内存寻址，但是指针

13
00:01:12,765 --> 00:01:19,278
也使用了更大的空间。实际上刚开始的时候这个迁移引起了很多问题

14
00:01:19,510 --> 00:01:25,230
因为程序使用了比人们预想的多得多的空间

15
00:01:25,230 --> 00:01:30,121
你们不需要经历我们经历过的这样的转换

16
00:01:30,121 --> 00:01:35,997
因为64位对于你可能需要寻址的任何东西绝对够用了

17
00:01:35,997 --> 00:01:41,720
2^64次方真的是一个非常大的数字。从字节说起

18
00:01:41,720 --> 00:01:47,751
我们先讲讲典型的内存使用量。再提一次，这和机器以及硬件实现有非常大的关系

19
00:01:47,751 --> 00:01:53,432
但是这些数字是合理的，并且是从典型实现上得到的

20
00:01:53,432 --> 00:01:58,294
对于布尔量，如果一个布尔量只占一个比特那非常棒

21
00:01:58,294 --> 00:02:03,834
因为布尔量不是”真“就是”假“，但通常布尔量要占一个字节

22
00:02:03,834 --> 00:02:09,343
一个字节当然就是需要一个字节了。现在字符占两个字节，16位的字符

23
00:02:09,541 --> 00:02:16,788
不久之前表示字符我们使用8比特。整数，普通int整型是四个字节

24
00:02:16,788 --> 00:02:23,226
或者32位。单精度浮点型也是4个字节。长整型和双精度浮点型是8个字节

25
00:02:23,227 --> 00:02:29,932
大多数应用中，我们使用双精度浮点型表示浮点数，普通整型表示整数

26
00:02:30,169 --> 00:02:37,093
这是基本类型。对于数组，需要一定量的

27
00:02:37,093 --> 00:02:44,086
额外空间加上，如果有N个元素，基本类型的空间开支乘以N

28
00:02:44,345 --> 00:02:51,763
所以长度为N的双精度浮点型数组需要的空间是8N+

29
00:02:51,763 --> 00:02:58,439
24。二维数组，我们可以继续计算准确的数字

30
00:02:58,439 --> 00:03:03,376
但是现在我们使用波浪记号。所以

31
00:03:03,376 --> 00:03:08,957
一维双精度浮点型数组需要的空间近似于8N

32
00:03:09,197 --> 00:03:15,878
二维数组需要的空间近似于8MN，额外空间还有一项

33
00:03:15,878 --> 00:03:22,483
但是对于大M和N这个式子就很准确了。这就是典型

34
00:03:22,483 --> 00:03:29,675
Java实现中基本类型及其数组的内存需求

35
00:03:29,675 --> 00:03:35,580
对于很多程序以及对象，我们还需要考虑进来

36
00:03:35,580 --> 00:03:42,250
对象需要的额外空间，引用的开销还有典型实现中内置的用来对齐的空间

37
00:03:42,250 --> 00:03:48,599
使得每个对象占据的空间是8字节的倍数

38
00:03:48,599 --> 00:03:55,869
例如，如果有一个日期对象，它有三个整型实例变量

39
00:03:55,869 --> 00:04:03,256
这个对象总共占据32字节。每个整型占据4个字节

40
00:04:03,256 --> 00:04:10,571
对象额外空间占16个字节，为了对齐需要4个字节，所以

41
00:04:10,571 --> 00:04:17,784
总共占32个字节。另一个经常遇到的例子是字符串

42
00:04:17,784 --> 00:04:25,274
字符串比数组稍微复杂一些

43
00:04:25,274 --> 00:04:32,577
Java对于字符串的典型实现包含字符数组的引用

44
00:04:32,819 --> 00:04:39,649
以及存储偏移、计数和哈希值的整型，还有一些对齐用的空间

45
00:04:39,649 --> 00:04:46,864
全部加起来，字符串的空间开销是2N+64个字节

46
00:04:46,864 --> 00:04:54,023
这是我们需要用来分析典型Java程序内存使用量的基础知识

47
00:04:54,023 --> 00:04:59,011
那么对于基本数据类型

48
00:04:59,011 --> 00:05:03,947
整型需要4个字节，双精度浮点型需要8个字节，等等

49
00:05:03,947 --> 00:05:09,600
对于引用，需要8个字节，这是指针需要占据的空间

50
00:05:09,600 --> 00:05:15,416
对于数组，24字节加上每一项的内存。对象需要16字节加上

51
00:05:15,416 --> 00:05:22,061
实例变量的空间，如果含有内部类，再加上8个比特

52
00:05:22,061 --> 00:05:29,381
我们将链表的节点的时候说过。最后是对齐用的空间

53
00:05:29,381 --> 00:05:34,234
在某些情况中我们需要考虑如何计算引用对象的开销

54
00:05:34,234 --> 00:05:41,163
当我们遇到这些情况的时候再详细介绍

55
00:05:41,163 --> 00:05:46,374
举一个简单的内存使用量的例子，我们来看

56
00:05:46,374 --> 00:05:52,052
之前讲过的weightedQuickUnionUF函数输入为N时内存的使用量

57
00:05:52,052 --> 00:06:00,305
只有几个内存元素，使用我们刚刚给出的基本知识可以

58
00:06:00,305 --> 00:06:07,675
容易地分析出每个元素的内存使用量。首先是一个对象，需要16

59
00:06:07,681 --> 00:06:14,878
字节的对象额外空间。两个整型数组，每个有

60
00:06:14,878 --> 00:06:22,530
24字节的数组额外空间，加上N项需要4N个字节。每项占4个

61
00:06:22,530 --> 00:06:29,784
字节，count变量占4个字节，4个字节用来对齐

62
00:06:29,784 --> 00:06:36,147
全部加到一起得到8N+88个字节，近似为8N，说明

63
00:06:36,147 --> 00:06:42,661
我们分析内存开销时全部需要考虑的就是

64
00:06:42,661 --> 00:06:51,260
有2N个整数，两个大小为N的数组，每一项

65
00:06:51,260 --> 00:06:59,364
占4个字节，总共沾8N个字节。总结一下

66
00:06:59,364 --> 00:07:05,670
我们确实能够计算出在现代计算机上我们需要”摇动手柄“的次数

67
00:07:05,670 --> 00:07:11,267
我们可以做经验分析，我们执行程序

68
00:07:11,267 --> 00:07:15,604
做实验，并假设幂定律成立，提出假设

69
00:07:15,604 --> 00:07:20,748
并做出预测。但我们能做更多，我们能进行数学分析

70
00:07:20,748 --> 00:07:26,452
找到开支最大的操作，分析这些开支执行的频率

71
00:07:26,452 --> 00:07:32,020
并使用波浪记号简化分析

72
00:07:32,020 --> 00:07:37,664
实际上我们还能解释程序的行为，而不只是预测它。这是

73
00:07:37,664 --> 00:07:42,819
使用科学方法理解我们的研究对象，算法，的很好的例子

74
00:07:42,819 --> 00:07:46,890
我们的数学模型通常和具体的

75
00:07:46,890 --> 00:07:51,562
计算机系统无关，甚至能够应用到还没有造出的机器上

76
00:07:51,562 --> 00:07:56,411
但我们一直在真实的机器上运行实验以验证

77
00:07:56,411 --> 00:08:05,677
我们的数学模型，使我们有信心我们能够做

78
00:08:05,677 --> 00:08:13,000
预测并分析算法。