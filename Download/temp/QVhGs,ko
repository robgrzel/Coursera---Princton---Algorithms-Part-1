1
00:00:01,084 --> 00:00:07,035
사실상 컴퓨팅 어플리케이션들에서 결정적으로 중요한 어플리케이션들

2
00:00:07,035 --> 00:00:11,901
전체 군의 대표격인 우선순위 큐들의 흥미로운 어플리케이션에 대하여 살펴봅시다.

3
00:00:12,094 --> 00:00:18,810
그것은 사건 중심 시뮬레이션이라고 불리는데 발상은

4
00:00:19,081 --> 00:00:26,739
시뮬레이션을 통하여 자연 세계의 특성들을 연구하고자 하는 것입니다. 그리고 그것은

5
00:00:27,030 --> 00:00:34,013
요즘의 과학적 연구에 매우 매우 일상적인 것입니다. 그리고 이것은

6
00:00:34,013 --> 00:00:40,369
매우 자연스러운 발상이고 사실상, 이 발상은 아이슈타인까지 거슬러 올라갑니다.

7
00:00:40,369 --> 00:00:46,198
우리는 우선순위에 의하여 충돌할 수도 있는 N개의 움직이는 입자들의 움직임을 시뮬레이션하고자 합니다.

8
00:00:46,198 --> 00:00:53,035
이러한 종류의 시뮬레이션은 우선순위 큐에 의하여 활성화되고,

9
00:00:53,035 --> 00:00:58,744
우선순위 큐와 같은 것 없이는, 많은 수의 입자들로 이것을 할 수 없습니다. 왜냐하면

10
00:00:58,744 --> 00:01:05,215
그것은 이차함수적인 시간을 필요로 할 수 있고 엄청난 수의 입자들을 위해 간단히 감당이 될 수 없습니다.

11
00:01:05,215 --> 00:01:11,225
어떻게 우리가 이것이 일어나게 만들 수 있는지 봅시다.

12
00:01:11,427 --> 00:01:16,532
우리는 하드 디스크 모델이라고 불리는 간단한 과학적 모델을 사용하는데,

13
00:01:16,532 --> 00:01:22,136
이것은 이것을 단지 간단히 하기 위한 것이고 단지 강의의 일부입니다. 확실히, 이러한 것들은

14
00:01:22,136 --> 00:01:27,971
많은 방식으로 확장될 수 있습니다. 우리는 서로 부딪히거나 벽과 부딪히는

15
00:01:27,971 --> 00:01:33,034
움직이는 입자들을 갖게 될 것입니다. 그리고 각각의 입자는

16
00:01:33,034 --> 00:01:38,776
위치, 속도, 질량, 그리고 반경을 가진 디스크입니다. 그리고 관련된 다른 물리력들은

17
00:01:38,776 --> 00:01:43,258
없습니다. 만약 저기에 중력이 관련되는 것처럼 추가적인 물리력들이 있다면, 그것은 더욱 복잡해질 것입니다.

18
00:01:43,258 --> 00:01:49,783
그리고 이 점은 그것 자체로 매우 중요합니다. 제가 언급하였듯이, 그것은

19
00:01:49,783 --> 00:01:56,017
압력과 온도를 이해하고자 노력한, [기침] 그들의 움직임이

20
00:01:56,017 --> 00:02:02,031
브라운적이고 랜덤하였다는 것을 보여준 이인슈타인의 유명한

21
00:02:02,031 --> 00:02:08,678
화분 실험에서의 물리학 연구로 거슬러 올라갑니다. 그것이 각각의 원자들과 분자들인지, 또는

22
00:02:08,678 --> 00:02:14,784
어떤 더 큰 입자들의 종류인지에 따라 그것은 복합적 동적 상태이고, 그것은

23
00:02:14,784 --> 00:02:21,340
컴퓨터 시뮬레이션을 통하여 이해하는 것이 낫습니다. 그리고 요즘에는

24
00:02:21,582 --> 00:02:28,480
그것은 우선순위 큐를 의미합니다. [기침] 그러면 준비운동으로, 여기 충돌없이 튀고 있는

25
00:02:28,480 --> 00:02:37,862
공들을 구현한 코드가 있습니다. 그리고 이것은 기초적인 프로그래밍 연습으로

26
00:02:38,194 --> 00:02:46,888
왼쪽의 코드는 오른쪽에 보여지는 결과를 갖습니다.

27
00:02:46,888 --> 00:02:55,341
우리는 ball이라고 불리는 데이터 타입을 가지는데, 그것은 단지 입자들의 하나를 나타내고

28
00:02:55,341 --> 00:03:02,137
위치와 속도를 가지는 인스턴스 변수들을 가집니다. 그래서 우리는 그것들을 많이 만들고

29
00:03:02,137 --> 00:03:10,466
매 50밀리세컨드마다 모든 그림을 지웠다가

30
00:03:10,466 --> 00:03:18,072
공들을 조금 움직이고 다시 그것들의 현재 위치에 그것들을 다시 그리는

31
00:03:18,072 --> 00:03:26,238
무한 루프를 가지고 있습니다. 그리고 move 연산이 단지 하는 것은

32
00:03:26,507 --> 00:03:33,465
속도에 따라 볼의 위치를 업데이트하는 것이고, 그것은 단지 또다른 숫자이며,

33
00:03:33,465 --> 00:03:38,938
그다음 그것들은 벽들을 튕기기 시작합니다. 만약 벽의 왼쪽을 치면

34
00:03:38,938 --> 00:03:44,371
오른쪽 벽의 x좌표를 반사하고, x좌표를 바닥에서 꼭대기로 반사하며,

35
00:03:44,371 --> 00:03:48,818
y좌표도 똑같이 해줍니다. 이것은 올바른 디스플레이 요소들이 주어진

36
00:03:48,818 --> 00:03:54,423
쉬운 프로그래밍 연습과제입니다. 그리고 그것은

37
00:03:54,630 --> 00:04:00,391
객체지향 프로그래밍에서 단지 하나의 임플리멘테이션으로 수많은 인스턴스들을 시뮬레이션하기 위하여

38
00:04:00,391 --> 00:04:05,575
어떻게 우리가 그 똑같은 임플리멘테이션을 사용할 수 있는지 보여주는 좋은 연습과제입니다.

39
00:04:05,575 --> 00:04:13,025
따라서 그것은 코드 측면에서 우리의 출발점입니다. 이것은 ball 클라스의 임플리멘테이션인데요.

40
00:04:13,025 --> 00:04:19,981
제가 언급하였듯이, 그것은 위치와 속도를 가지고 있고, 모든 공은

41
00:04:19,981 --> 00:04:25,362
반경을 가지고 있습니다. 그리고 여기에 생성자가 있고 우리는 아마도

42
00:04:25,362 --> 00:04:30,176
위치와 속도를 초기화할 수도 있거나 만약 아무런 인자가 없다면

43
00:04:30,176 --> 00:04:35,248
임의의 위치로 초기화할 수도 있는 생성자를 가질 수도 있습니다. 그리고 여기에

44
00:04:35,248 --> 00:04:40,394
move 매소드가 있습니다. 그리고 다시 move 메소드는, 대부분, 단지 x와 y 좌표들을 가져다가

45
00:04:40,394 --> 00:04:46,564
현재 속도 곱하기 속력 상수를 더해줍니다. dt 속력,

46
00:04:46,564 --> 00:04:52,007
속도 변수는 인자 dt로 주어집니다. 그리고 이 테스트들은

47
00:04:52,007 --> 00:04:57,561
그것이 벽을 치는지를 알기 위한 것이고 그럴 경우 x나 y속도를 뒤집어야 합니다. 그리고

48
00:04:57,561 --> 00:05:03,767
draw인데, 그것은 단지 StdDraw를 사용하고 단지 공을 그립니다. 저것은

49
00:05:03,767 --> 00:05:09,349
튀는 공 시뮬레이션을 하는 전체 코드입니다. 여기서 빼먹은 것은

50
00:05:09,349 --> 00:05:15,715
공들이 서로 충돌할 때 어떤 일이 일어나느냐 입니다. 그리고 그것에 대처하기 위하여 우리는 둘 다 해보아야 합니다.

51
00:05:15,715 --> 00:05:22,521
약간의 고등학교 물리와 약간의 기초 컴퓨터 과학입니다.

52
00:05:22,521 --> 00:05:28,269
물리학 문제는 두 개의 공들이 부딪히고 잘 알려진 물리학 과정에 따라

53
00:05:28,269 --> 00:05:33,402
각각 반대로 튈 때 정확하게 무엇이 발생하는냐 입니다. 그리고

54
00:05:33,402 --> 00:05:39,507
그것은 고등학교 물리입니다. 그리고 CS 문제는 각각의 공들을 위해 이러한 계산을

55
00:05:39,507 --> 00:05:45,957
어떻게 그리고 언제하느냐 입니다. 그리고 우리가 그것을 어떻게 효과적으로 할 수 있는지,

56
00:05:46,161 --> 00:05:51,619
즉 log N 시간 대 N 제곱 시간입니다. 만약 우리가 제곱 시간이 걸리는

57
00:05:51,619 --> 00:05:56,860
계산 프로세스를 가지고 있다면, 그 코드는 확장가능하지 않을겁니다. 우리는

58
00:05:56,860 --> 00:06:01,489
많은 수의 입자들은 할 수가 없을 것입니다. 현실 세계의 시뮬레이션들은 보통,

59
00:06:01,489 --> 00:06:06,124
거대한 양의 데이터를 하도록 처하게 되고 우리는 2차함수적 알고리즘을 가질 수 없습니다. 이것은 단지

60
00:06:06,273 --> 00:06:11,363
왜 여러분들이 이 시뮬레이션을 하려고 할 때 우선순위 큐와 같은

61
00:06:11,363 --> 00:06:16,086
어떤 데이터 구조를 아는 것이 나은지를 알려주는 첫 번째 징조입니다.

62
00:06:16,086 --> 00:06:21,639
그것이 없이 여러분들은 성공하기 어려울 것입니다. 좋습니다, 그럼 무엇이 발생하는지

63
00:06:21,639 --> 00:06:28,967
보도록 합시다. 여기에 여러분들이 시도하려고 고려할 수도 있는 여러가지들이 있습니다.

64
00:06:28,967 --> 00:06:35,692
한 가지 아이디어는 소위 시간 중심 시뮬레이션입니다. 그리고 우리가 방금 말했듯이,

65
00:06:35,692 --> 00:06:42,597
우리는 매 dt 초마다 모든 것을 업데이트할 것입니다. 그리고 진행하다가 우리는

66
00:06:42,597 --> 00:06:48,123
만약 충돌이 있으면, 만약 두 개의 공이 똑같은 공간을

67
00:06:48,123 --> 00:06:53,250
차지하고 있다면, 우리는 시간을 조금만 뒤로 돌려

68
00:06:53,250 --> 00:06:58,297
충돌한 그 순간을 정확하게 계산해 내기 위하여 노력하고 그 후

69
00:06:58,297 --> 00:07:02,904
어떻게 위치와 속도가 그에 맞춰 바뀌어야하는지 계산하며 그 후

70
00:07:02,904 --> 00:07:08,501
시뮬레이션을 계속합니다. 하지만 이것은 커다란 문제가 있습니다. 첫 번째는

71
00:07:08,501 --> 00:07:13,431
겹치는 모든 쌍들의 공들을 체크해야하기에 그것은 2차함수적이고, 그것은 정말로

72
00:07:13,817 --> 00:07:19,504
정말로 많은 겹침이고, 어마어마한 N의 값을 위해 여러분들은 그것을 할 수 없을 것입니다.

73
00:07:19,504 --> 00:07:26,034
그러나 다른 문제는 N이 작다고 해도 dt를 매우 작게 한다면,

74
00:07:26,244 --> 00:07:32,246
단지 이 계산을 반복하는 것밖에 안 되고 한 번 공들을 조금 움직이는데

75
00:07:32,246 --> 00:07:38,556
너무 많은 계산을 하게 됩니다. 반면, 만약 여러분들이

76
00:07:38,556 --> 00:07:45,620
dt를 너무 크게 만들어 형편을 개선해보려고 노력한다면 여러분들은 오른쪽 예에서 보여준

77
00:07:45,620 --> 00:07:51,167
충돌을 완전히 놓치게 될 수도 있습니다. 따라서 정말로 효과가 있는 dt 값을 계산해내는 것은

78
00:07:51,167 --> 00:07:56,850
시간 중심 시뮬레이션에 있어서 막대한 문제입니다. 대신 우리가 하고자 하는 것은

79
00:07:56,850 --> 00:08:02,416
사건 중심 시뮬레이션이라는 불리는 것입니다. 그리고 이것은 모든 종류의 정황에서

80
00:08:02,416 --> 00:08:08,175
유용한 매우 보편적인 컨셉입니다. 그리고 우리는 무엇인가가 발생할 때 상황을 바꿀 것입니다.

81
00:08:08,175 --> 00:08:13,110
따라서 유일하게 중요한 것은 충돌이고, 우리는

82
00:08:13,110 --> 00:08:17,574
충돌 사이에 직선으로 이동하는 입자들을 계산할 것입니다. 그리고

83
00:08:17,574 --> 00:08:22,049
우리가 할 것은 충돌이 발생하려고 하는 바로 그 때만 초점을 맞추는 것입니다.

84
00:08:22,049 --> 00:08:26,680
그리고 우리가 그것을 하기 위한 방법은 우선순위 큐를 유지하고

85
00:08:26,680 --> 00:08:31,771
그 우선순위 큐는 계산에서 발생할 수 있는 모든 가능한 충돌을 가질 것이며

86
00:08:31,771 --> 00:08:37,081
그들은 시간에 의해 우선순위가 매겨질 것입니다. 그리고 우리가

87
00:08:37,081 --> 00:08:42,521
우선순위 큐에서 최소 엘리먼트를 제거할 때, 그것은 우리가 다루어야할 다음

88
00:08:42,521 --> 00:08:48,035
충돌입니다. 따라서 우리는 두 단계가 있는데, 바로 예측과 해결입니다.

89
00:08:48,035 --> 00:08:53,448
어떤 시간 t에 우리는 두 개의 입자를 가져 올 수 있고 여기 밑에 보여지는 것처럼

90
00:08:53,448 --> 00:08:59,114
우리는 그들의 위치와 속도들을 알고 있으며 우리는 정확히 그 순간을 예상할 수 있습니다.

91
00:08:59,114 --> 00:09:05,297
그것들은 다른 어떤 것이 그 사이에 일어나지 않는다는 가정하여 충돌할 것이고

92
00:09:05,297 --> 00:09:10,979
그 예상된 충돌 시간을 우선순위 큐에 집어넣을 것이며

93
00:09:10,979 --> 00:09:17,152
나중에 그 시간이 지날 때 우리는 그것들이 충돌하는 바로 그 순간에 있을 수 있고

94
00:09:17,152 --> 00:09:22,457
우리가 해야할 것을 계산할 수 있습니다. 이번에는, 그 사이 그것들에게 다른 어떤 것이 발생할

95
00:09:22,457 --> 00:09:27,211
가능성이 있고 우리는 그 변화에 대하여도 얘기해보겠습니다.

96
00:09:27,211 --> 00:09:32,575
우리는 충돌 예상을 해야하고, 그 예상은 그것이 다른 입자나 벽과 부딪히려고 할 때의

97
00:09:32,575 --> 00:09:37,972
위치, 속도 그리고 반경이 주어져야 합니다. 그리고 과학 법칙에 따라 입자들의 속도가

98
00:09:37,972 --> 00:09:46,258
어떻게 바뀌는지를 계산하는 해결을 합니다.

99
00:09:46,258 --> 00:09:53,791
이 부분은 지금 그리 자세하게 얘기하지 않을 것인데

100
00:09:53,791 --> 00:09:59,975
왜냐하면 그것은 고등학교 물리이기 때문입니다. 그리고 저는 대부분의 학생들이 고등학교

101
00:09:59,975 --> 00:10:06,327
물리 수업을 들었고 이 수학을 할 수 있으며 또는 적어도

102
00:10:06,327 --> 00:10:12,354
이 수학을 하는 코드가 맞다고 설득되었다고 생각합니다. 만약 여러분들이 x, y의 어떤 위치에 있고

103
00:10:12,354 --> 00:10:18,733
x방향의 x와 y방향의 y의 어떤 속도를 가지고 있는

104
00:10:18,733 --> 00:10:25,076
입자를 가지고 있다는 것을 알고 있다면, 먼 곳에서부터 수직 벽에 부딪힐 때까지

105
00:10:25,076 --> 00:10:31,248
얼마나 많은 시간이 걸릴지 계산할 수 있습니다.

106
00:10:31,248 --> 00:10:37,011
그것은 기본적으로 거리를 속도로 나누면 됩니다.

107
00:10:37,248 --> 00:10:42,600
저것이 예상이고 다음은 해결입니다. 그것이 벽을 칠 때

108
00:10:42,600 --> 00:10:48,586
그것의 속도와 위치가 변할 것입니다.

109
00:10:48,586 --> 00:10:54,909
저것은 단지 입자가 벽을 칠 때의 충돌 예상과

110
00:10:54,909 --> 00:11:01,148
그것이 벽에 도달했을 때 여러분들이 해야할 해결의 예입니다.

111
00:11:01,148 --> 00:11:06,671
여러분들이 두 입자의 충돌을 다룰 때는 확실하게 더 많은 수학이 필요합니다. 그리고 다시, 이것은 고등학교

112
00:11:06,671 --> 00:11:13,109
물리입니다. 그리고 우리는 그것에 관한 테스트는 하거나 심지어 세부사항을 살펴보지도 않을 것입니다.

113
00:11:13,109 --> 00:11:19,031
하지만 그것은 단지 속도와 위치로 하는 약간의 수학으로,

114
00:11:19,031 --> 00:11:24,112
속도와 위치를 알고 있는 주어진 입자가 또다른 주어진 입자와 충돌할 때를

115
00:11:24,112 --> 00:11:28,186
어떻게 예상하고 무엇이 일어나는 지를 다루는 위한 것입니다. 따라서 여러분들은

116
00:11:28,186 --> 00:11:33,772
두 속도를 가져다가 그들의 거리를 이것들로 나누고 하는 등등을 해야합니다.

117
00:11:34,025 --> 00:11:41,520
여기 우리에게 무엇을 할지를 말해주는 간단한 공식이 있고 그것들이 한 번 충돌할 때

118
00:11:41,520 --> 00:11:47,904
우리가 할 것을 위하여 또한 공식을 계산할 수 있습니다. 그리고 다시 누구도 이것이 쉽다고 주장하지는 않지만

119
00:11:47,904 --> 00:11:53,722
이것은 물리학의 부분이고 잘 작동하며 뉴톤의 2번째 법칙으로부터 나온 것입니다.

120
00:11:53,722 --> 00:11:59,962
고등학교 물리를 이수한 사람이라면 이 공식들을 다룰 수 있을 것이고

121
00:11:59,962 --> 00:12:06,359
이것의 나머지는 스피드를 내기 위해 참고 도서로 넘겨야만

122
00:12:06,359 --> 00:12:11,799
할 것 같습니다. [기침] 하지만 한번 코드로 축소되고, 그것은 아마도

123
00:12:11,799 --> 00:12:16,947
첫 디버깅 때 몇가지의 문제가 있을 수도 있겠지만 적어도 우리는 그것이 작동한다는 것을 납득할 수 있습니다.

124
00:12:16,947 --> 00:12:23,104
하지만 이번에는 컴퓨터 과학 코드를 보도록 합시다. 이것은 단지

125
00:12:23,104 --> 00:12:30,106
우리가 충돌하지 않으면서 튀는 공들을 위해 사용했던 우리의 ball 데이터 타입을

126
00:12:30,106 --> 00:12:35,324
이러한 추가적인 것들을 고려하기 위하여 확장한 것입니다. 우리 것은 질량을 가질 것이고, 따라서 거기에는

127
00:12:35,324 --> 00:12:40,962
몇몇 크고 무거운 것들이 있을 것이고, 그것은 상황을 더 흥미롭게 만듭니다. 그리고 또한 count라고 불리는

128
00:12:40,962 --> 00:12:46,141
변수가 있는데, 그것은 관련된 입자들의 충돌 횟수입니다.

129
00:12:46,141 --> 00:12:51,921
그리고 그것은 몇 개의 이유에서 유용합니다. 우리는

130
00:12:51,921 --> 00:12:57,701
예측과 충돌 분석을 하는 다수의 프로시져들을 필요로 할 것입니다.

131
00:12:57,701 --> 00:13:03,710
우리가 주어진 입자를 칠 때까지의 시간은 얼마일까요?

132
00:13:03,710 --> 00:13:09,192
우리가 수직 수평의 벽을 칠 때까지의 시간은 얼마일까요? 그리고 똑같이 만약 우리가

133
00:13:09,192 --> 00:13:14,080
입자를 치는 지점에 있다면 우리는 무엇을 할까요? 똑같은 방식으로 수직과 수평의 벽일 때는요?

134
00:13:14,080 --> 00:13:18,899
저것은 뼈대입니다. 우리는 모든 입자에 적용되는 저 물리 법칙들을 구현할

135
00:13:18,899 --> 00:13:24,760
저 프로시져들이 필요합니다. 그리고 이것이 그것들의 생김새이고

136
00:13:24,760 --> 00:13:29,547
다시, 이것은 고등학교 물리어서 자세하게 그것을 하지 않을 것입니다.

137
00:13:29,724 --> 00:13:35,184
단지 지적하고 싶은 점은 그것이 방대한 양의 코드는 아니라는 것인데, 수많은 dx와

138
00:13:35,184 --> 00:13:41,168
dy 그리고 dv가 있지만 실제로 방대한 양의 코드는 아닙니다. 그리고 다른 점은

139
00:13:41,369 --> 00:13:47,053
만약 전혀 충돌이 발생하지 않는다면 우리는 INFINITY를 반환할 것이고,

140
00:13:47,053 --> 00:13:51,710
즉 우선순위 큐에 그것을 보관할 것이고, 그것은 우선순위 큐애서 계속됩니다.

141
00:13:51,922 --> 00:13:59,105
저것은 우리가 필요로 하는 프로시저들이고

142
00:13:59,105 --> 00:14:07,618
수평과 수직의 벽들을 위한 것들과 비슷합니다. 이번에는 사건 중심 시뮬레이션을 위한

143
00:14:07,618 --> 00:14:14,846
메인 루프를 살펴봅시다. 첫 번째로 우리는 모든 입자의

144
00:14:14,846 --> 00:14:20,275
모든 수평과 수직의 벽을 칠 수도 있는 다음 시간을 계산할 것입니다.

145
00:14:20,275 --> 00:14:25,567
사실상 만약 벽에서부터 멀어진다면, 그것은 벽을 치지 않을 것이고, 즉

146
00:14:25,567 --> 00:14:30,987
무한대가 될 것입니다. 하지만 만약 그것이 벽쪽으로 가고 있다면, 우리는 시간을 계산할 수 있습니다.

147
00:14:30,987 --> 00:14:36,367
그리고 그것은 미래의 시간이고 우리는 그 이벤트를 우선순위 큐에

148
00:14:36,367 --> 00:14:41,437
그 시간을 키로 하여 넣을 것입니다. 그리고 모든 입자들에 똑같은 것을 할 것입니다.

149
00:14:41,437 --> 00:14:47,084
따라서, 우리는 이차의 초기화 단계를 가지고

150
00:14:47,084 --> 00:14:51,881
우선순위 큐가 채워지기 위하여 오직 한 번만 수행하면 됩니다. 모든 충돌은, 일어나지 않을 수도 있기때문에,

151
00:14:51,881 --> 00:14:57,266
따라서 우리는 충돌 과정에 있는 두개의 입자만을 가질 수도 있고 우리는

152
00:14:57,266 --> 00:15:01,897
그 두 입자들만을 위한 그 지점을 예측할 것입니다. 아시다시피, 처음이라도 말이죠.

153
00:15:01,897 --> 00:15:07,235
하지만 세번째 입자가 충돌이 일어나기 전에 그 둘 중 하나의 입자를 쳐서

154
00:15:07,235 --> 00:15:12,431
그 이벤트가 무효가 되는 경우가 있을 수도 있습니다.

155
00:15:12,431 --> 00:15:18,880
따라서 시뮬레이션은 이러한 경우도 계산에 넣기 위하여 조심해야 합니다. 하지만 그것은 그리 어렵지

156
00:15:18,880 --> 00:15:23,856
않습니다. 여기 메인 루프가 무엇인지 나와 있습니다. 우리는 우선순위 큐에서 다음

157
00:15:23,856 --> 00:15:28,782
이벤트를 가져올 것입니다. 그것은 모든 우리의 계산들로 알아낸 다음에 일어날 충돌입니다.

158
00:15:28,782 --> 00:15:33,618
다음에 일어날 하나의 충돌이 있습니다. 그다음 우리는

159
00:15:33,618 --> 00:15:39,518
그 이벤트가 무효인지 테스트를 합니다. 그리고 그것은 입자의 저 count 필드를 이용하여 합니다.

160
00:15:39,518 --> 00:15:45,289
그때 그것은 다음 시간이 언제일지 말해 줍니다. 그 다음

161
00:15:45,289 --> 00:15:49,766
우리는 모든 입자들을 살펴보고 직선의 궤적에 그들의 위치들을 바꿔야 합니다.

162
00:15:49,766 --> 00:15:53,894
그 많은 시간 후에 그것들은 어디에 있을까요? 우리는 충돌하는 두 개의 입자를 가져다가

163
00:15:53,894 --> 00:15:59,040
그것들의 속도를 바꾸어야 합니다. 그것들은 서로 산란하게 됩니다.

164
00:15:59,040 --> 00:16:04,014
이제 저 두 입자들의 속도는 변하였고, 근본적으로

165
00:16:04,014 --> 00:16:08,095
그것들과 관련된 미래의 충돌들을 무효화시킵니다. 그리고 저 두 입자를 위하여

166
00:16:08,095 --> 00:16:13,094
우리가 해야할 것은 살펴보고 미래에 벽이나 다른 입자들과의

167
00:16:13,094 --> 00:16:18,069
충돌들을 예측하는 것입니다. 그리고 모든 그 새로운 이벤트들을

168
00:16:18,069 --> 00:16:22,742
우선순위 큐에 집어 넣습니다. 바로 그겁니다. 여러분은 두 입자가 갖고,

169
00:16:22,742 --> 00:16:28,021
속도를 바꾸며, 앞으로 있을 그 입자들의 벽과의 충돌을 계산하고,

170
00:16:28,021 --> 00:16:33,036
우선순위 큐를 업데이트하며, 메인 루프는 우선순위 큐에서 다음 것을 제거하고

171
00:16:33,036 --> 00:16:42,017
계속 합니다. 저것은 우리가 다음에 살펴볼 코드입니다.

172
00:16:42,017 --> 00:16:47,686
우리는 단지 코드를 줄이는 다수의 규약들을 가지고 있습니다. 그리고 만약

173
00:16:47,686 --> 00:16:55,084
Event라고 불리는 것이 두 입자 사이에 무엇인가가 특정 시간에 일어날 것을

174
00:16:55,084 --> 00:17:01,086
말해준다면, 우리는 규약들을 적용할 것이고, 만약

175
00:17:02,006 --> 00:17:07,048
어떠한 입자도 nul이 아니면 우리는 두 입자들에 관하여 얘기하고 있는 것입니다. 만약

176
00:17:07,048 --> 00:17:12,838
입자 중 하나가 null이라면 우리는 수직이나 수평의 벽들에 관하여 얘기하는 것입니다.

177
00:17:12,838 --> 00:17:18,607
그리고 만약 두 입자들이 null이면 우리는 단지 다시 그리길 원한다는 것을 말해줍니다.

178
00:17:18,607 --> 00:17:25,231
그것은 약간의 핵이지만 많은 코드를 줄여줍니다. compareTo는 time으로 되어있습니다.

179
00:17:25,231 --> 00:17:33,018
그리고 우리는 충돌에 끼어드는 것을 체크하는 isValid를 필요로 합니다. 그리고 여기에

180
00:17:33,018 --> 00:17:40,763
충돌 시스템에서 앞으로 일어날 뼈대가 있는데, 핵심적인 것은

181
00:17:40,763 --> 00:17:48,987
이 예측 메소드로, Particle을 인자로 하고

182
00:17:48,987 --> 00:17:54,148
이 입자에 관련된 모든 가능한 충돌들을 우선순위 큐에 추가합니다.

183
00:17:54,148 --> 00:18:00,369
따라서 모든 입자들을 살펴볼 것이고 그 입자를 위해 timeToHit 메소드를 호출합니다.

184
00:18:00,369 --> 00:18:06,776
그리고 그 시간의 이 입자와 저 입자를 위하여

185
00:18:06,776 --> 00:18:12,695
이벤트를 우선순위 큐에 넣을 것입니다. 그리고 또한 수직 벽과 수평 벽을

186
00:18:12,695 --> 00:18:19,293
위한 이벤트도 넣을 것입니다. 다시, 이 null 규약들을 이용하여 말하면,

187
00:18:19,533 --> 00:18:26,002
Event의 두 번째 인자가 null이라는 것은 수직이라는 것을 말헤줍니다.

188
00:18:26,002 --> 00:18:31,385
따라서 그것은 충돌하게될 각각의 두 입자들을 위한 시뮬레이션에서

189
00:18:31,385 --> 00:18:38,129
사용되는 핵심 메소드입니다. 이제 마지막으로 메인 사건 중심

190
00:18:38,129 --> 00:18:45,613
시뮬레이션 루프를 볼 수 있습니다. 여기 우선순위 큐를 만들고 모든 입자들을 위한

191
00:18:45,613 --> 00:18:53,936
이 예측을 합니다. 그리고 또한 우리는 항상 먼저 발생하는

192
00:18:53,936 --> 00:19:01,135
Event를 넣을 것이고 그것은 모든 것을 다시 그리라는 명령입니다.

193
00:19:01,135 --> 00:19:08,856
따라서 그것은 단지 시뮬레이션이 잘 진행되고 있음을 확실히 하는 방법이고 쉬운 그리기 방법입니다.

194
00:19:09,110 --> 00:19:15,997
메인 루프는 while에 우선순위 큐는 empty가 아닙니다.

195
00:19:15,997 --> 00:19:22,166
우리는 하나의 이벤트를 빼내 올 것입니다. 우리는 그것이 유효한지 테스트할 것이고

196
00:19:22,166 --> 00:19:27,562
그것은 단지 두 입자들에게 다른 일이 발생했는지를 체크하는 것입니다.

197
00:19:27,562 --> 00:19:33,099
우리는 두개의 입자들을 빼낼 것이고 그다음 마지막 이벤트 이래로의

198
00:19:33,099 --> 00:19:39,075
지나간 총 시간으로 모든 입자들을 이동시킬 것입니다.

199
00:19:39,075 --> 00:19:44,656
그리고 나서 그것이 네가지 유형의 이벤트들 중 어떠한 것인지 테스트할 것입니다.

200
00:19:44,656 --> 00:19:50,174
그것은 redraw, a와 b의 충돌이거나 수평, 수직 벽과의 산란입니다.

201
00:19:50,390 --> 00:19:55,737
그리고 나서 모든 다른 입자들에 대한

202
00:19:55,737 --> 00:20:01,282
a와 b 각각 입자들의 예측을 합니다. 저것이 시뮬레이션을 위한 거의

203
00:20:01,282 --> 00:20:09,427
대부분의 코드입니다. 이것은 데이터 중심 코드입니다. 우리가 할 수 있는 한 가지는 단지

204
00:20:09,691 --> 00:20:16,813
임의의 위치와 속도의 공 100개를 가지고 돌리는 것입니다. 하지만 데이터 중심 코드의

205
00:20:16,813 --> 00:20:23,495
괜찮은 점은 지금 코드가 작동하고, 이것이 쓰기에 별것 아닌 코드라고 하는 것이 아니라,

206
00:20:23,495 --> 00:20:31,055
그것은 분명히 다루기 쉽고 그것은 우선순위 큐로 가능합니다.

207
00:20:31,055 --> 00:20:38,575
우선순위 큐가 없이는 이것을 실행하기에

208
00:20:38,575 --> 00:20:45,912
한층더 복잡한 계산이 필요할 것입니다. 그리고 또한, 많은 데이터 셋들을 위해서 전혀

209
00:20:45,912 --> 00:20:51,742
합리적으로 효율적이지 않을 것입니다. 저것은 단지 랜덤한 위치들을 생성하는 단순한 시뮬레이션입니다.

210
00:20:51,742 --> 00:20:58,772
사람들은 아마도 이것에 흥미를 가질 수도 있겠습니다. 이것은 현실 세계에서 일어나는 것과는

211
00:20:58,772 --> 00:21:04,482
정확하게 꼭 일치하지는 않습니다. 주로 왜냐하면 우리는 세 개의 입자들이 닿거나,

212
00:21:04,482 --> 00:21:10,836
또는 두 개의 입자들이 닿고 다른 것이 그들을 칠 때 무엇이 발생하는지를

213
00:21:10,836 --> 00:21:16,683
시뮬레이션에 넣지 않았기 때문입니다. 그리고 또한 누구도 모든 15번 공같은,

214
00:21:16,683 --> 00:21:23,063
당구공 세트로 모든 곳에서 맞히는 점수를 따지 못할 것입니다. 따라서 현실 세계를 시뮬레이션하려고

215
00:21:23,063 --> 00:21:28,604
노력할 때 삶은 복잡해질 수 있습니다. 이것은 약간 아이슈타인 실험에 관한 것입니다.

216
00:21:30,014 --> 00:21:38,281
만약 화분과 같은 하나의 큰 입자가 있고 그것과 부딪히는 원자, 분자같은

217
00:21:38,281 --> 00:21:46,045
작은 입자들이 있다면, 큰 것은

218
00:21:46,045 --> 00:21:54,080
랜덤하게 움직일 것입니다. 그리고 이것은 확산을 보여주는 또다른 유명한 물리 실험입니다.

219
00:21:54,080 --> 00:22:00,053
그리고 이 기초적인 충돌 시스템을 가지고 할 수 있는 다른 많은 것들이 있습니다.

220
00:22:00,053 --> 00:22:06,032
만약 막대한 숫자의 입자들이 있고 벽을 치는 횟수와

221
00:22:06,032 --> 00:22:11,867
그들이 벽을 치는 빈도를 측정한다면, 여러분들은 온도와 압력 그리고

222
00:22:12,081 --> 00:22:18,082
많은 다른 것들과 관련된 실험을 하거나 또는 3차원 버전으로 할 수도 있습니다.

223
00:22:18,082 --> 00:22:23,835
다시말하지만 자연계의 시뮬레이션은 갈수록 중요해지는

224
00:22:24,081 --> 00:22:33,066
계산 어플리케이션이고 그것을 하기 위해 우선순위 큐와 같은 효과적인 데이터 구조들을

225
00:22:33,066 --> 00:22:38,056
필요로 합니다.