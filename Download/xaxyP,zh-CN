1
00:00:02,000 --> 00:00:07,036
欢迎回来。今天我们将要做一些
数学和科学。不是很多，但是我们·

2
00:00:07,036 --> 00:00:11,055
需要有一个科学的基础
来理解我们算法的性能

3
00:00:11,055 --> 00:00:15,075
从而合理地在实战中使用它们。
所以今天我们要讲

4
00:00:15,275 --> 00:00:20,040
关于如何观察算法的性能特点

5
00:00:20,040 --> 00:00:25,022
我们将会看一下怎样建立数学模型
以及

6
00:00:25,022 --> 00:00:30,010
如何根据算法的运行时间的增长阶数来对其分类
我们会探讨到关于算法理论

7
00:00:30,010 --> 00:00:35,790
和如何分析内存使用的一点知识
总的来说，

8
00:00:35,790 --> 00:00:42,206
我们将要从多种不同的角色来思考这些问题

9
00:00:42,206 --> 00:00:48,139
第一个角色是程序员, 他需要解决一个问题

10
00:00:48,139 --> 00:00:54,270
让算法能够工作，并部署它。第二个角色是用户，他想要

11
00:00:54,270 --> 00:01:00,167
完成某项工作，但不关心程序做了什么。第三个角色是理论家

12
00:01:00,167 --> 00:01:06,424
他真的想要理解发生的事情。最后一个角色

13
00:01:06,424 --> 00:01:10,724
是一个团队，团队中的基本工作有时需要

14
00:01:10,724 --> 00:01:15,790
完成以上所有的工作。所以，今天的课程中每一种角色的工作

15
00:01:15,790 --> 00:01:21,110
都会出现一些。实际上，你还是个学生时，你必须想到

16
00:01:21,110 --> 00:01:26,753
某一天你将会扮演这里任何一种甚至所有的角色。所以

17
00:01:26,753 --> 00:01:31,522
理解不同的观点是相当重要的。那么，我们将要集中考虑的关键

18
00:01:31,522 --> 00:01:38,205
就是运行时间。实际上要理解计算时间的想法可以

19
00:01:38,205 --> 00:01:44,017
追溯到巴贝奇，甚至更早

20
00:01:44,017 --> 00:01:48,083
巴贝奇说过：“一旦分析机被造出来，它必然将

21
00:01:48,083 --> 00:01:54,076
指导科学的未来行程。无论用它帮忙寻找什么结果

22
00:01:54,076 --> 00:02:00,062
都一定会面临使用什么计算方法才能让这个机器

23
00:02:00,062 --> 00:02:06,072
在最短的时间内算出结果的问题。”如果你仔细看看巴贝奇

24
00:02:06,072 --> 00:02:12,009
的分析机，会发现它有一个把手。巴贝奇事实上所关心

25
00:02:12,009 --> 00:02:17,060
的计算时间，就是必须转动把手的次数

26
00:02:17,060 --> 00:02:23,048
当今世界并没有太大的不同

27
00:02:23,048 --> 00:02:29,018
把手变成了某个电子器件，每秒钟工作十亿次。但

28
00:02:29,018 --> 00:02:34,041
我们依然想知道为了完成一项计算我们需要进行

29
00:02:34,041 --> 00:02:39,093
多少次操作。所以有各种原因要求我们分析算法

30
00:02:39,093 --> 00:02:45,032
这门课的内容中我们主要关心

31
00:02:45,032 --> 00:02:50,051
预测算法的性能，我们还想要比较完成同一任务不同

32
00:02:50,051 --> 00:02:54,768
算法的性能，并能得知在最坏情况下算法性能的底线

33
00:02:54,768 --> 00:03:00,058
同时，我们需要理解关于算法如何运行的一些理论基础

34
00:03:00,077 --> 00:03:05,780
但是首先，我们想要分析并理解算法的很实际的原因是

35
00:03:06,024 --> 00:03:11,098
为了避免性能错误。我们想

36
00:03:11,098 --> 00:03:16,050
对我们的算法在一定时间内完成任务有一些自信

37
00:03:16,050 --> 00:03:21,084
在今天的计算基础设施中常常能看到

38
00:03:21,084 --> 00:03:26,080
因为程序员没有理解算法的性能特征导致

39
00:03:26,080 --> 00:03:31,026
客户端的性能很差

40
00:03:31,026 --> 00:03:36,086
今天这堂课就是要避免这种情况出现

41
00:03:36,086 --> 00:03:42,087
这门课中我们将会重点关注性能和比较不同的算法

42
00:03:42,087 --> 00:03:48,064
在典型计算机科学课程安排中后续会有

43
00:03:48,064 --> 00:03:53,093
更多关于算法理论基础的内容

44
00:03:53,093 --> 00:03:59,090
一会我会稍微提一下。但是我们重点放在获得预测

45
00:03:59,090 --> 00:04:07,007
和比较算法性能的能力。现在我们能列出很多通过

46
00:04:07,030 --> 00:04:12,081
设计更优性能的算法以解决原先不能解决的问题

47
00:04:12,081 --> 00:04:19,025
的成功案例。我这里只给出几个例子

48
00:04:19,025 --> 00:04:25,346
第一个也是最著名的就是FFT（快速傅立叶变换）算法

49
00:04:25,346 --> 00:04:32,057
这个算法将信号的N个采样波形分为若干周期分量

50
00:04:32,057 --> 00:04:38,431
这是DVD和JPEG以及很多其他应用的基础

51
00:04:38,431 --> 00:04:44,296
有一个简单的方法需要正比于N^2的时间

52
00:04:44,296 --> 00:04:49,080
但是FFT算法只需要N log N 步。N log N 和

53
00:04:49,080 --> 00:04:55,002
 N^2的区别就是能否求解大型问题

54
00:04:55,002 --> 00:04:59,078
这个快速算法使得我们今天

55
00:04:59,078 --> 00:05:04,822
很多数字媒体技术成为可能。另一个例子

56
00:05:05,051 --> 00:05:11,232
实际上是Andrew Appel开发的，他现在是普林斯顿的计算机科学

57
00:05:11,232 --> 00:05:16,582
系主任。他还是本科生时做毕业论文的时候设计了这个算法

58
00:05:16,582 --> 00:05:22,725
这个算法能够快速求解N体仿真问题

59
00:05:22,725 --> 00:05:28,548
简单算法需要正比于N^2的时间，而Appel的算法是 N log N

60
00:05:28,548 --> 00:05:33,452
级别的算法。这意味着科学家能够运行巨大N值的N体仿真

61
00:05:33,452 --> 00:05:41,478
这个算法催生了新的研究。所以，我们常常面临的挑战是

62
00:05:41,478 --> 00:05:47,677
我的程序能否求解实际中大型输入？而实际上

63
00:05:47,677 --> 00:05:52,024
在工作中程序员时刻都在面临着这个挑战

64
00:05:52,024 --> 00:05:58,001
为什么我的程序运行得这么慢？为什么它耗尽了内存？

65
00:05:58,001 --> 00:06:05,000
为了处理这些问题程序员花费了大量时间，绞尽脑汁

66
00:06:05,000 --> 00:06:10,030
Knuth在1970年代的工作显示我们确实可以使用科学方法

67
00:06:10,030 --> 00:06:16,062
来理解运行中算法的性能。也许我们没有在破解

68
00:06:16,062 --> 00:06:23,010
宇宙新的奥秘，但是我们可以使用科学方法

69
00:06:23,010 --> 00:06:29,042
来研究计算机，并理解

70
00:06:29,042 --> 00:06:34,008
我们的程序是如何运行的。接下来我们详细讲一下

71
00:06:34,209 --> 00:06:39,063
这只是我们提到的科学方法的一个简短的概括

72
00:06:39,268 --> 00:06:44,086
到现在科学方法已经被成功使用了几个世纪。
所以我们要做的是

73
00:06:44,086 --> 00:06:50,008
从自然界中观察某些特征。对我们来说，就是

74
00:06:50,008 --> 00:06:54,857
程序在计算机上的运行时间。然后我们要提出假设

75
00:06:55,049 --> 00:06:59,079
一些与观察到的现象相一致的模型，而且我们希望

76
00:06:59,079 --> 00:07:04,040
假设是合理的并且能够让我们做一些预测

77
00:07:04,040 --> 00:07:09,031
一般用来预测更大问题规模或者另一台计算机上的运行时间

78
00:07:09,197 --> 00:07:13,097
接下来我们会做更多的观察来验证预测，直到

79
00:07:13,097 --> 00:07:18,058
我们的模型假设和观察都吻合，
证实我们的模型假设是正确的

80
00:07:18,058 --> 00:07:22,077
这是一种理解程序性能的方法

81
00:07:22,077 --> 00:07:28,056
使用科学方法，有一些基本原则

82
00:07:28,056 --> 00:07:33,082
第一，如果要做实验，你应该期望

83
00:07:33,082 --> 00:07:39,021
别人做同样的实验也能有相同的结果

84
00:07:39,021 --> 00:07:44,067
而假设必须具有某个特殊的性质，它能被实验

85
00:07:44,067 --> 00:07:49,736
证伪。所以提出假设必须小心谨慎

86
00:07:49,736 --> 00:07:55,433
我们一定会尽力完成。又说到了
我们研究的自然界的特征

87
00:07:55,433 --> 00:08:00,822
是自然界中存在的某些特定的计算机

88
00:08:00,822 --> 00:08:07,049
它将算法从抽象的事物变成类似计算机中奔腾的电子

89
00:08:07,049 --> 00:08:11,083
的某种实际的物理对象