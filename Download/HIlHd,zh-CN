1
00:00:02,006 --> 00:00:07,042
让我们以红黑树的实际应用
来结束这个课题

2
00:00:07,042 --> 00:00:13,038
B树是其中一个非常典型的版本

3
00:00:13,038 --> 00:00:20,797
B树的中心思想是什么呢
通常我们需要储存的数据非常大

4
00:00:20,797 --> 00:00:26,010
对于这么大量的数据

5
00:00:26,010 --> 00:00:32,103
我们要为外部存储
找到一个更通用的模型

6
00:00:32,103 --> 00:00:38,031
我们要处理连续的数据存储块
可能4、4千或更多数据 甚至整个文件

7
00:00:38,031 --> 00:00:43,301
并且我们希望能计算出第一次
获取某页数据的时间

8
00:00:43,301 --> 00:00:49,878
因为主要的时间开销就在于
如何找到特定的页

9
00:00:49,878 --> 00:00:56,455
一旦我们找到了第一页
就可以顺畅地读取后面的页

10
00:00:56,455 --> 00:01:02,117
因此外部存储不同于内存的主要特性
就是需要很多时间去定位特定页

11
00:01:02,117 --> 00:01:08,267
但是在页内读取数据是很迅速的
所以当我们想获取外部存储数据时

12
00:01:08,267 --> 00:01:14,858
我们想要用最少的时间来定位第一页

13
00:01:14,858 --> 00:01:22,423
这是一个切实可行的文件系统模型
B树就是一个平衡树的泛化

14
00:01:22,423 --> 00:01:30,116
它就可以帮我们实现这一目的
它的中心思想是

15
00:01:30,116 --> 00:01:38,021
每个节点不仅仅能有两三个键
而是可以有很多很多键 比如一页那么多

16
00:01:38,021 --> 00:01:45,401
比如有M=1000或是4000个键
根节点至少有两个键

17
00:01:45,401 --> 00:01:53,466
唯一另外的限制就是
我们不希望某些节点太空

18
00:01:53,466 --> 00:02:00,146
那会导致最后键数少于M
而我们希望至少有M/2个键

19
00:02:00,146 --> 00:02:06,578
然后你可以看到
这是两个三叉树的泛型

20
00:02:06,578 --> 00:02:12,650
这使我们可以建立一个
深度非常小的平衡树

21
00:02:12,650 --> 00:02:19,776
一般这些都是设置好的
所有的数据都存储在外部节点

22
00:02:19,776 --> 00:02:26,534
外部节点没有链接 只有键
他们是有序排列着的

23
00:02:26,534 --> 00:02:33,859
比如这是一个外部节点
M=6 这是一个外部5节点

24
00:02:33,859 --> 00:02:40,634
所以他有五个键
还有一个空的位置可以存放一个临时键

25
00:02:40,634 --> 00:02:46,292
如果插入一个满的节点
它会像之前一样分裂

26
00:02:46,292 --> 00:02:53,071
然后我们将分裂之后的键
向上一层传递

27
00:02:53,071 --> 00:02:59,955
内部节点的红键就是
复制向下一层级直接搜索所得的键

28
00:02:59,955 --> 00:03:06,946
这是一些额外的细节 使算法实现更容易
也是最常用的实现的方法

29
00:03:06,946 --> 00:03:13,777
所以目前为止 我们的核心思想是

30
00:03:13,777 --> 00:03:21,234
这是一个233的分叉
除非我们允许每个节点有更多的键

31
00:03:21,234 --> 00:03:27,982
当一个节点被塞满就会分裂为二
因此一个节点的键数总是在一半到占满之间

32
00:03:27,982 --> 00:03:33,339
因此如果到达1000
他就会分裂为二 每边500 

33
00:03:33,339 --> 00:03:39,145
然后我们就可以运用这些树的特性来分析
从而发现获取一个键并不需要那么多时间

34
00:03:39,145 --> 00:03:45,559
所以 现在 我们知道
就像我们刚刚所做的那样

35
00:03:45,559 --> 00:03:52,148
我们只需要将其推广
每个内部节点都有一个存储键的表

36
00:03:52,148 --> 00:03:59,857
键的链接会告诉我们
每个键会在哪儿

37
00:03:59,857 --> 00:04:07,332
这个链接服务于
B树中某个键和下一个键中间的键

38
00:04:07,332 --> 00:04:13,449
每个地方都是这样的结构

39
00:04:13,449 --> 00:04:18,571
所以如果我们要在这个B树中查找E
我们就要向左向下查找

40
00:04:18,571 --> 00:04:22,774
然后看到第二个链接
因为E是在D和H中间的

41
00:04:22,774 --> 00:04:27,228
然后当你到外部节点
我们只要找到E即可

42
00:04:27,228 --> 00:04:30,918
到部节点中 搜索结束
这就是全部的搜索过程了

43
00:04:30,918 --> 00:04:36,596
换句话说
这就是我们之前所讲的一个概括

44
00:04:36,596 --> 00:04:43,086
关于插入 也是一样的原理
我们到达底部 然后分裂

45
00:04:43,086 --> 00:04:49,012
让我们来看看在这个B树中插入A
A插入到左边的节点

46
00:04:49,012 --> 00:04:54,509
然后这使得这个节点满溢了
现在这里的键比它的容量多了一个键

47
00:04:54,509 --> 00:05:00,060
因此我们将它分裂为二
于是我们需要在内部节点添加新的入口

48
00:05:00,060 --> 00:05:06,658
在这个例子中 这个新入口是C
也就是新的这页中最小的一个键

49
00:05:06,658 --> 00:05:11,469
这个入口要被加进来
然后我们顺着位移其他的键

50
00:05:11,469 --> 00:05:15,626
这个内存模式有充足的时间做这些事
我们只需要计算定位这些页的时间

51
00:05:15,626 --> 00:05:19,623
位移的时间我们并不在意

52
00:05:19,623 --> 00:05:24,502
你也可以在这个内存模式中
用不同的混合的数据结构

53
00:05:24,502 --> 00:05:31,293
但是通常我们这么操作就可以了
现在这个也满溢了 它也需要分裂为二

54
00:05:31,293 --> 00:05:37,974
我们要创建新的寻路
就像我们之前所做的一样

55
00:05:37,974 --> 00:05:44,994
虽然我们还没有引入细节
但是基本的思路你应该已经明白了

56
00:05:44,994 --> 00:05:52,403
这个例子的这种方法也同样适用于
很多很多内存的处理

57
00:05:52,403 --> 00:05:58,429
所以 在顺序为M
也就是每页M个键的B树中搜索或者插入

58
00:05:58,429 --> 00:06:05,205
需要的时间在log(M-1) N 
和log(M/2) N之间

59
00:06:05,205 --> 00:06:11,481
这是一个非常小的数字
所以假设M是1000

60
00:06:11,481 --> 00:06:17,857
log(M/2) N就是log(500) N
所以要比N大 我们需要多少次幂呢

61
00:06:17,857 --> 00:06:24,182
实际上我们一般取4或5
我们可以把根页放在内存中

62
00:06:24,182 --> 00:06:30,233
因此对于一些可以信任的应用
我们可以快速定位任何一页数据

63
00:06:30,233 --> 00:06:36,833
即使它是含有万亿的数据的巨型文件

64
00:06:36,833 --> 00:06:42,846
我们可以在5-6次搜索内
获取任何一个数据

65
00:06:42,846 --> 00:06:49,058
这个速度是非常惊人的
在算法中这也算是个惊人的例子了

66
00:06:49,058 --> 00:06:55,117
一般你不会想
这事儿这么简单就能完成

67
00:06:55,117 --> 00:07:01,264
将很多的键值存储在一个动态搜索表中

68
00:07:01,264 --> 00:07:08,398
然后你就只需查找5到6个地方
就能获取任何一个键

69
00:07:08,398 --> 00:07:15,619
这就是B树的便利之处
这是一个成长的B树的仿真

70
00:07:15,619 --> 00:07:21,896
我们来看顶部的页 只有一页是满的
红色代表满了

71
00:07:21,896 --> 00:07:28,332
它就分裂为二 一半键到这边
一半键到另一边

72
00:07:28,332 --> 00:07:34,388
在这个表中 有些页得到了新的键
最终会有某些页满了 然后分裂为二

73
00:07:34,388 --> 00:07:40,467
现在我们这里有三页了
然后慢慢地又有某一页满了 分裂

74
00:07:40,467 --> 00:07:46,108
现在我们有四页了 然后第一页满了
再分裂 如此反复

75
00:07:46,108 --> 00:07:51,131
所以这些黑色的部分
是一页中被占据了的部分

76
00:07:51,131 --> 00:07:57,000
这些白色的就是空闲的部分
这些满了的页就将会向下分裂为二

77
00:07:57,000 --> 00:08:03,364
这就是建立一个大型的B树的过程

78
00:08:03,364 --> 00:08:09,569
你可以看到黑色的部分有多少
近乎一半都是空闲的

79
00:08:09,569 --> 00:08:16,045
事实上通常超过一半的部分是空闲的
如果需要的话

80
00:08:16,045 --> 00:08:22,077
人们有很多种这样的算法
来保留远多于一半的空闲空间

81
00:08:22,077 --> 00:08:29,283
所以 就像我之前所提到的那样
红黑树和B树广泛应用于系统符号表

82
00:08:29,283 --> 00:08:35,098
树型映射和树集的Java实现是红黑树

83
00:08:35,098 --> 00:08:42,019
C++标准模板库也使用红黑树

84
00:08:42,043 --> 00:08:48,096
它还应用于Linux内核中
以及很多其它的系统

85
00:08:48,096 --> 00:08:56,004
B树有许多不同的变体
提供不同的特性

86
00:08:56,052 --> 00:09:04,087
比如容量使用量和其它的一些特性
现在在大多数你可能用到的数据库中

87
00:09:04,087 --> 00:09:12,038
SQL、Oracle的数据库活着一些其它数据库
都是基于B树的变体的

88
00:09:12,065 --> 00:09:18,099
因为B树和它的变体都非常高效

89
00:09:18,099 --> 00:09:24,061
当你的数据结构或算法出现在主流文化中
你才会发现它们已经被很多人使用着了

90
00:09:24,061 --> 00:09:31,608
我的一个朋友 Philippe Flajolet (菲利普·弗拉若莱)
一位著名的法国数学家 最近去世了

91
00:09:31,608 --> 00:09:37,426
他在一天晚上发给我一封电子邮件
他非常激动 因为在法国电视台上

92
00:09:37,426 --> 00:09:43,331
他看到了一段英文的
加拿大电视节目的重播

93
00:09:43,331 --> 00:09:47,553
我不知道他花时间在做这些
但是他真的非常激动 因为看到这段片段

94
00:09:47,553 --> 00:09:51,093
"又是红色的门"
"我认为这红门是储物容器“

95
00:09:51,093 --> 00:09:53,953
"但是它已经不再红了
它是黑色的了"

96
00:09:53,953 --> 00:09:56,577
"所以红色转变成黑色意味着什么?"

97
00:09:56,577 --> 00:10:00,515
"预算赤字 红色墨水 黑色墨水"
"也可能是二叉搜索树"

98
00:10:00,515 --> 00:10:04,339
"红黑树追踪每个简单的路径
从一个节点到它的一个后代叶节点"

99
00:10:04,339 --> 00:10:08,565
"这个叶节点有着同样数目的黑色节点"
"这些信息是否有所帮助呢"

100
00:10:08,565 --> 00:10:12,663
不仅仅是这段对话非常令人激动
学术上它还是非常正确的

101
00:10:12,663 --> 00:10:16,540
在流行文化中这并不常见

102
00:10:16,540 --> 00:10:20,788
"红黑树追踪每个简单的路径
从一个节点到它的一个后代叶节点"

103
00:10:20,788 --> 00:10:26,226
"这个叶节点有着同样数目的黑色节点"
他们说得完全正确

104
00:10:26,226 --> 00:10:31,063
B树和这些方法都是非常高效
并且广泛应用的