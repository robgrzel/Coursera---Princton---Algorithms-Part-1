1
00:00:02,022 --> 00:00:08,015
이전에 설명한대로 QuickFind는 큰 문제에 대해서는 너무 느립니다.
 그래서 어떻게 더 잘 할 수

2
00:00:08,015 --> 00:00:14,035
있을까요?
우리의 첫 번째 시도는 Quick-union이라고하는 대안입니다.

3
00:00:14,035 --> 00:00:20,082
이 방식은 알고리즘 설계에서 (조급한(eager) 접근법과 대비되는)
 게으른 접근법(lazy apparoach)입니다. 이 방식은 우리가 정말 해야 할 때까지

4
00:00:20,082 --> 00:00:27,506
일을 하지 않는 방식입니다. 이 알고리즘은 같은 자료구조, 
즉 N 개의 크기를 가진 배열을 사용하지만

5
00:00:27,506 --> 00:00:34,280
이제는 다르게 해석을 붙이게 됩니다.
 우리는 배열이 오른쪽에 그려져 있는,

6
00:00:34,280 --> 00:00:41,298
숲(forest)이라고 불리는 
트리(tree) 구조들의 집합을 표현한다고 생각할겁니다.

7
00:00:41,298 --> 00:00:49,468
배열에 들어있는 각각의 값은 그것이 포함되어 있는 
트리에서의 부모 값을 의미합니다.

8
00:00:49,468 --> 00:00:57,425
예를들어서, 3의 부모는 4이고, 4의 부모는 9입니다.
 그래서 3번 인덱스의 값은 4이고

9
00:00:57,425 --> 00:01:06,681
4번 인덱스의 값은 9가 됩니다.
 이제 배열 안의 각 값은 루트로 연결됩니다.

10
00:01:06,681 --> 00:01:13,179
그것이 트리에서의 루트(root)입니다. 요소 하나로만 구성된 트리는

11
00:01:13,179 --> 00:01:19,303
스스로만이 연결 컴포넌트이므로, 자기 자신을 가리킵니다. 
그래서 1은 스스로를 가리키는 겁니다.

12
00:01:19,303 --> 00:01:26,108
하지만 9 또한 스스로를 가리키는데,
 9는 트리구조의 루트로, 2, 4 그리고 3을 포함합니다.

13
00:01:26,108 --> 00:01:32,419
그래서, 이런 자료구조로부터
 우리는 각각의 요소들을

14
00:01:32,419 --> 00:01:40,202
연결 컴포넌트를 대표하는
 루트와 대응시켜 생각할 수 있습니다.

15
00:01:40,202 --> 00:01:47,044
그래서 3의 루트는 따라올라가 보면 9입니다.
 이제 루트를 계산해낼 수 있으니

16
00:01:47,044 --> 00:01:52,956
우리는 단지 '두 개의 요소가
 같은 루트를 가져서 연결되는가'를

17
00:01:52,956 --> 00:01:57,592
체크함으로써 find 연산을 구현할 수 있습니다.

18
00:01:57,592 --> 00:02:02,373
이는 '두 요소가 같은 연결 컴포넌트에 포함되는가?'
 라고 말하는 것과 동치(equivalent)입니다.

19
00:02:02,373 --> 00:02:09,240
그래서 각 요소의 루트를 찾아가는 것은 좀 번거롭지만,
 Union 연산은 매우 쉽습니다.

20
00:02:09,240 --> 00:02:15,254
다른 컴포넌트에 있는 두 다른 요소 p, q가 포함되는
 새로운 컴포넌트를 생성하는 Merge를 위해

21
00:02:15,254 --> 00:02:21,613
우리가 해야할 것은 그냥 p의 루트의 id를 
q의 루트의 id로 설정해주는 것입니다.

22
00:02:21,613 --> 00:02:28,748
p의 트리가 q의 트리를 가리키도록 해봅시다.
 이 경우엔, 3과 5를 합치기 위해서

23
00:02:28,748 --> 00:02:35,027
우리는 id[9]의 값을 6으로 바꾸어야 합니다. 
단지 배열의 값 하나를 바꿈으로써

24
00:02:35,027 --> 00:02:41,317
3과 5를 포함하는 큰 2 개의 연결 컴포넌트들을

25
00:02:41,317 --> 00:02:46,295
서로 합칠 수 있습니다. 이것이 Quick-union 알고리즘입니다.
 Quick이라고 하는 건 이 Union 연산이

26
00:02:46,295 --> 00:02:52,429
오직 배열의 값 하나만을 바꾸기 때문입니다. 
Find 연산은 조금 더 많은 일을 해야 합니다.

27
00:02:52,429 --> 00:02:57,907
그럼 첫 번째로 연산 중 하나를
 구현한 데모를 살펴봅시다.

28
00:02:57,907 --> 00:03:03,569
그럼 다시 우리는 같은 방법으로 시작하지만
 이제 배열의 값은

29
00:03:03,569 --> 00:03:09,415
실제로 요소들 각자가 그 스스로를 가리키는
 노드 하나의 작은 트리 구조를

30
00:03:09,415 --> 00:03:15,284
이룬다는 의미입니다. 스스로는 각 트리 구조의
 루트이기도 하죠. 이제 (union(4, 3)이 주어졌으니) 우리가 4와 3을

31
00:03:15,284 --> 00:03:21,236
같은 구성 컴포넌트에 넣어야 하면, 
첫 번째 요소(4)를 포함하는 컴포넌트의 루트를 취해

32
00:03:21,236 --> 00:03:26,624
그 두 번째 요소(3)를 포함하는 컴포넌트의
 루트의 자식이 되게 하는 겁니다.

33
00:03:26,624 --> 00:03:33,029
이 경우에 우리는 단지 3을 4의 부모로 만들면 됩니다.

34
00:03:33,259 --> 00:03:39,823
이제 3과 8의 Union 연산이 주어졌네요.
 첫 번째 요소(3)를 
두 번째 요소(8)를 포함하는

35
00:03:39,823 --> 00:03:47,532
트리의 루트의 자식으로 만듭니다. 이제 3,4,8은 같은 구성 요소입니다.

36
00:03:47,532 --> 00:03:56,434
6과 5에 대한 Union 연산은 6을 5 밑으로
 보냅니다. 9와 4의 Union 연산을 하려면

37
00:03:56,434 --> 00:04:06,045
4를 포함하고 있는 트리의 루트는 8임을 안 뒤, 
 9를 포함하는 트리의 루트가

38
00:04:06,045 --> 00:04:13,745
9임을 알 수 있으므로, 우리는 9를 8의 자식으로 만듭니다.
 2와 1에 대한 Union 연산은 쉽네요.

39
00:04:14,007 --> 00:04:20,993
connected(8, 9)가 주어졌으니 8과 9를 연결되어 있는지 확인하려면,
 그 두 요소가 같은 루트를 가지고 있는지 확인해야 합니다.

40
00:04:20,993 --> 00:04:28,011
그리고 그들은 8이라는 같은 루트를 가지고 있으므로 
연결되어 있습니다. 5와 4의 연결성을 살펴보면, 4의 루트는 8이고,

41
00:04:28,011 --> 00:04:34,230
5의 루트는 5입니다. 다르네요.
 연결되어 있지 않음을 알 수 있습니다.

42
00:04:34,230 --> 00:04:42,339
5와 0에 대한 Union 연산은 5를 0의 자식으로
 보냅니다. 7과 2의 Union 연산이네요.

43
00:04:42,339 --> 00:04:52,836
7을 2의 루트인 1의 자식으로 보냅니다.
 6과 1의 Union 연산이죠. 6의 루트는 0이고

44
00:04:52,836 --> 00:05:00,636
1은 스스로가 루트이므로
 0이 1의 자식이 됩니다. 각각의 Union 연산은

45
00:05:00,636 --> 00:05:10,069
단지 배열의 값 하나만을 바꿉니다.
 마지막으로 7과 3에 대한 Union이네요.

46
00:05:10,069 --> 00:05:18,755
7의 루트는 1이고 3의 루트는 8이므로 1이 8의 자식이 되겠네요.

47
00:05:18,755 --> 00:05:26,012
좋아요, 이제 우리는 모든 항목을 포함하는
 하나의 연결 컴포넌트를 가집니다.

48
00:05:26,012 --> 00:05:32,668
자 이제 Quick-union을 구현한 코드를 살펴봅시다.
 생성자는 앞의 버전과 똑같습니다.

49
00:05:32,668 --> 00:05:40,967
우리는 배열을 만들고 각 항목들을 그 스스로의 루트로 설정해줍니다.
 이제 우리는

50
00:05:40,967 --> 00:05:46,005
해당 요소의 인덱스와 값이 같은 요소를 발견할 때 까지 
부모의 포인터를 따라감으로써

51
00:05:46,005 --> 00:05:51,352
루트를 찾는 과정을 구현한 private 메소드를 가집니다.
 인덱스 i와 값 id[i]가 같아질 때까지

52
00:05:51,352 --> 00:05:57,369
단순히 i 가 그 부모 id[i]를 가리키는 작업을 반복해
 인덱스 i와 값 id[i]가 일치해질 때, i를 리턴합니다.

53
00:05:57,369 --> 00:06:02,005
어느 노드에서 시작하더라도 
여러분은 인덱스 i와 값 id[i]가 일치할 때까지

54
00:06:02,005 --> 00:06:07,396
따라가면 루트에 도달합니다.
 이 메소드는 find 연산이나 connected 연산을

55
00:06:07,396 --> 00:06:11,959
구현하기 위해 사용할 수 있는 private 메소드입니다.

56
00:06:11,959 --> 00:06:17,316
connected 연산에선 단순히 p와 q의 루트를 찾아
 비교하기만 하면 됩니다.

57
00:06:17,316 --> 00:06:23,342
union 연산은 단순히 p와 q의 루트 i, j를 찾은 
뒤 p의 루트 i의 id 값, 즉 p의 루트를 기록한 id[i]를

58
00:06:23,342 --> 00:06:30,310
q의 루트 j로 변경하는 아이디어를 사용하면 됩니다.
 사실상 Quick Find 보다 코드가 적습니다.

59
00:06:30,310 --> 00:06:37,139
for 루프가 없으니까요.
 단지 하나의 while 루프만을 염려하면 됩니다.

60
00:06:37,139 --> 00:06:43,326
하지만 여기 있는 Quick-union 코드는
 동적 연결 문제를 푸는 빠르고 우아한 구현입니다.

61
00:06:43,326 --> 00:06:50,318
이제 우리는 이 코드가 커다란 문제에서도
 효율적으로 동작할지를 살펴볼 것입니다.

62
00:06:50,582 --> 00:06:57,657
불행히도 Quick-union은 더 빠르지만
 또한 너무 느리기도 합니다.

63
00:06:57,657 --> 00:07:04,042
Quick-find와는 다른 측면에서
 너무 느린 겁니다.

64
00:07:04,042 --> 00:07:10,005
빠른 경우도 있지만,
 너무 느린 경우도 있는 거죠.

65
00:07:10,005 --> 00:07:16,256
그리고 Quick-union의 결점은 트리구조가 
너무 길어질 수 있다는 점에서 옵니다.

66
00:07:16,256 --> 00:07:22,065
무슨 뜻이냐면, find 연산의 실행 시간이
 너무 오래 걸릴 수 있다는 겁니다.

67
00:07:22,065 --> 00:07:28,432
크고 마른 (long skinny) 트리를 생각해보세요.
 맨 아래의 요소에 대한 find 연산을

68
00:07:28,432 --> 00:07:33,976
하기 위해 각 요소가 트리의 모든 요소를
 계속 따라가야 할 수 있습니다.

69
00:07:34,183 --> 00:07:40,184
find 연산을 하기 위해 배열 접근을 하는
 비용이 있을 때

70
00:07:40,184 --> 00:07:44,013
많은 연산을 하게 되면 매우 느려질 수 있을 겁니다.