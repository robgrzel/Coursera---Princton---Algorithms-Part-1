1
00:00:01,065 --> 00:00:07,024
最后 我们说说稳定性
这确实是排序算法的性质之一

2
00:00:07,024 --> 00:00:11,029
但在我们已经学过几种算法的情况下
接着来谈会更容易些

3
00:00:11,029 --> 00:00:15,068
即使你不理解我们刚讲过的比较器
也真的没有关系

4
00:00:15,068 --> 00:00:21,022
那么典型的应用是我刚用来做为范例的
学生档案集合

5
00:00:21,022 --> 00:00:26,098
我们要把他们按姓名排列
也就是说

6
00:00:26,098 --> 00:00:31,884
就像在分发期末成绩之前一样排列
或许这第三列是期末成绩

7
00:00:31,884 --> 00:00:38,026
它们全都按姓名排序好了

8
00:00:38,026 --> 00:00:44,009
但为了按院系把成绩分发下去

9
00:00:44,009 --> 00:00:50,625
我们想要根据第二列按院系排序
问题是当我们这样做的时候

10
00:00:50,625 --> 00:00:57,945
按姓名的排列就会乱成一团
这让人有点生气

11
00:00:57,945 --> 00:01:04,329
试想一下 一旦你按姓名排列了之后
接着你想按第二项排列

12
00:01:04,329 --> 00:01:10,742
并且对于所有在第二项具有
相同键关键字的记录保持按姓名排列

13
00:01:10,742 --> 00:01:17,191
实际上 不是所有的排列都保留那个性质
这就是所谓的稳定性

14
00:01:17,191 --> 00:01:22,726
明显地 你的应用是否想要或者需要
一个稳定的排列

15
00:01:22,726 --> 00:01:28,039
这是值得好好思考的 同时对于很多人和
应用来说 这也是一件让人烦恼的惊喜

16
00:01:28,039 --> 00:01:33,659
一个稳定的排列是指保留了
拥有相同关键字记录的相对顺序

17
00:01:33,659 --> 00:01:38,956
到底哪种排序是稳定的呢？
这是我们正想谈论的有趣问题

18
00:01:38,956 --> 00:01:44,879
这些算法中插入排序和归并排序是稳定的

19
00:01:44,879 --> 00:01:52,238
但选择排序和希尔排序不是

20
00:01:52,238 --> 00:01:58,477
甚至在稳定的算法中
有些实现也是不稳定的

21
00:01:58,477 --> 00:02:04,158
你要仔细检查这些代码确保它们
都是稳定的 在这门课上我们总是

22
00:02:04,158 --> 00:02:10,834
会有一个判断这个排序是否稳定的练习题
或者考试题 所以学生们要学会判断

23
00:02:10,834 --> 00:02:16,709
这段代码是否是稳定的
这里有另一个典型的例子

24
00:02:16,905 --> 00:02:21,879
我们得到了按时间排列的序列 
我们想要的可能是这些重要的事件

25
00:02:22,050 --> 00:02:27,435
人们想买一场摇滚演唱会的门票
我将这些按地点排列

26
00:02:27,435 --> 00:02:31,702
我们所希望的是这些按地点排列的序列
同时能保持让时间排列

27
00:02:31,702 --> 00:02:36,640
但这是一个不稳定的排序 它不会保持
按时间的排序 按地点排序完了之后

28
00:02:36,640 --> 00:02:41,725
如果他们想用其中一个记录 他们还得
重新排列 但如果他们用得是稳定的排序

29
00:02:41,725 --> 00:02:47,692
这些记录还保持着按时间的排序
所以对很多的应用你都希望有稳定性

30
00:02:47,692 --> 00:02:54,015
好的 那么让我们来看看至今为止
我们学过的每一个算法

31
00:02:54,207 --> 00:02:59,097
插入排序 插入排序是稳定的
为什么它是稳定的呢?  嗯

32
00:02:59,097 --> 00:03:05,633
我们移动记录时从不越过相同值的记录
在这个例子中 当我们得到A1 

33
00:03:05,866 --> 00:03:12,141
在这种情况下 它的角标在数组中表示
为1 它只是A和B的角标

34
00:03:12,141 --> 00:03:18,763
当我们得到第二个A 
只要找到不小于它的记录就停止排列

35
00:03:18,763 --> 00:03:24,911
这俩是相等的 是不小于的 我们就
停止排序 所以从不越过相同值的记录 

36
00:03:24,911 --> 00:03:30,488
如果这里是小于或者等于 
那么它是行不通的 

37
00:03:30,488 --> 00:03:35,818
或者如果我们用另一种方法并据此运行
在这个代码中让相同值的记录从不越过彼此

38
00:03:35,818 --> 00:03:41,997
那么插入排序就是稳定的
但是选择排序是不稳定的

39
00:03:42,298 --> 00:03:49,529
通常而言 
看一个排序是不是稳定一般是看

40
00:03:49,529 --> 00:03:55,875
它是否有长距离的交换可能使得一条
记录越过某一条相同值的记录 那么

41
00:03:56,163 --> 00:04:02,245
[咳嗽] 在这个情形下 比如 对于
选择排序 当我们实行第一次交换操作时

42
00:04:02,245 --> 00:04:08,471
[咳嗽] 我们在0的位置
找到了最小的A和B

43
00:04:08,471 --> 00:04:14,951
我们进行一次长距离的交换
这次交换把第一条记录扔过一些记录

44
00:04:14,951 --> 00:04:21,249
其中可能有相同值的记录 这样就把
排序打乱了 并且这是不可修复的

45
00:04:21,249 --> 00:04:26,524
所以就导致选择排序是不稳定的
它可能把记录越过有相同值的记录

46
00:04:26,524 --> 00:04:32,601
这就导致了具有相同值得记录的排序
和在文件中的原始排序不同

47
00:04:32,601 --> 00:04:39,016
选择排序是不稳定的
希尔排序也有长距离的交换

48
00:04:39,016 --> 00:04:45,479
所以它也是不稳定的
它把键移动越过其他可能相等的键

49
00:04:45,479 --> 00:04:51,024
所以它容易造成和选择排序一样的情况
希尔排序也是不稳定的

50
00:04:51,024 --> 00:04:57,527
归并排序呢? 归并排序是挺稳定的
只要归并操作是稳定的 它就是稳定的

51
00:04:57,527 --> 00:05:02,923
这些操作是否稳定取决于
我们的代码怎么写

52
00:05:03,118 --> 00:05:09,232
在我们的代码中 如果两个键是相等的
它取来自左边子数组的值

53
00:05:09,232 --> 00:05:15,670
那么这意味着 如果有两组相等的键
它将总是取

54
00:05:15,670 --> 00:05:21,112
它将保存它们的相对顺序
这就足够表示归并操作是稳定的了

55
00:05:21,112 --> 00:05:26,672
因此归并排序是稳定的
稳定性是排序算法中一个重要的性质

56
00:05:26,672 --> 00:05:38,905
归并算法不仅高效而且也是稳定的