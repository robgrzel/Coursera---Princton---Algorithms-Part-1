1
00:00:02,000 --> 00:00:07,036
Приветствую! Сегодня мы обратимся к науке и математическим вычислениям. 

2
00:00:07,036 --> 00:00:11,055
Нам необходимо знать основы для понимания работы 

3
00:00:11,055 --> 00:00:15,075
алгоритмов, чтобы должным образом применять их на практике. Сегодня мы будем говорить,

4
00:00:15,275 --> 00:00:20,040
о том, как узнать характеристики производительности алгоритмов. Мы собираемся

5
00:00:20,040 --> 00:00:25,022
посмотреть как построить математическую модель алгоритма, а также как классифицировать алгоритмы относительно 

6
00:00:25,022 --> 00:00:30,010
роста времени их выполнения. Немного поговорим о теории алгоритмов

7
00:00:30,010 --> 00:00:35,790
а также об анализе количества используемой памяти.

8
00:00:35,790 --> 00:00:42,206
Мы обсудим данные проблемы с точки зрения различных героев.

9
00:00:42,206 --> 00:00:48,139
Первый из них - программист, которому требуется найти решение 

10
00:00:48,139 --> 00:00:54,270
и  заставить его работать. Второй - клиент, который

11
00:00:54,270 --> 00:01:00,167
воспользуется любой программой, чтобы завершить работу. Третий является теоретиком,

12
00:01:00,167 --> 00:01:06,424
а именно тем, кто хочет понимать как все на самом деле работает. И

13
00:01:06,424 --> 00:01:10,724
последний этак своего рода сборная базовых фундаметальных знаний, навыков, которые бывают необходимы

14
00:01:10,724 --> 00:01:15,790
для всей остальной работы. И понемногу будет от каждого

15
00:01:15,790 --> 00:01:21,110
в сегодняшней лекции. Во время 
обучения вам нужно быть готовым

16
00:01:21,110 --> 00:01:26,753
однажды сыграть одну из этих ролей
или даже их все. Очень важно

17
00:01:26,753 --> 00:01:31,522
понимать различные точки зрения. Ключевой момент

18
00:01:31,522 --> 00:01:38,205
на котором мы сфокусируемся - время выполнения. На самом деле идея понимания времени выполнения

19
00:01:38,205 --> 00:01:44,017
вычислений уходит во времени к Бэббиджу и вероятно даже ранее. И вот

20
00:01:44,017 --> 00:01:48,083
цитата Бэббиджа "Как только появится Аналитическая Машина, она 

21
00:01:48,083 --> 00:01:54,076
непремено задаст будущее развитие науки. Какой бы результат не искали с ее

22
00:01:54,076 --> 00:02:00,062
помощью, возникнет вопрос как организовать вычисления чтобы получить

23
00:02:00,062 --> 00:02:06,072
результат на это машине за кратчайшее время. Если вы посмотрите на машину Бэббиджа

24
00:02:06,072 --> 00:02:12,009
, называемую аналитическая машина,  у нее есть рычаг. И Бэббиджа буквально

25
00:02:12,009 --> 00:02:17,060
интересовало как долго будет длится вычисление, т.е. как

26
00:02:17,060 --> 00:02:23,048
много раз мы должны повернуть рычаг. И это не сильно отличается от того что есть сегодня.

27
00:02:23,048 --> 00:02:29,018
Рычагом может быть что-то электронное переключающееся миллиард раз в секунду. Но

28
00:02:29,018 --> 00:02:34,041
все так же мы ищем как много раз некоторая операция должна быть

29
00:02:34,041 --> 00:02:39,093
произведена для того чтобы вычисление было завершено. Есть много причин

30
00:02:39,093 --> 00:02:45,032
анализировать алгоритмы. В контексте этого курса мы в основном заинтересованы в 

31
00:02:45,032 --> 00:02:50,051
предсказании производительности. И мы также хотим сравнить производительность различных

32
00:02:50,051 --> 00:02:54,768
алгоритмов при решении одной и той же задачи, и быть способными предоставить некоторые гарантии того

33
00:02:54,768 --> 00:03:00,058
как они будут выполняться. Это понимание некоторых теоретических основ того

34
00:03:00,077 --> 00:03:05,780
как алгоритмы выполняются. Но в первую очередь, причина того что мы хотим 

35
00:03:06,024 --> 00:03:11,098
анализировать алгоритмы и понимать их это желание избежать плохой производительности. Мы хотим

36
00:03:11,098 --> 00:03:16,050
быть уверены что наши алгоритмы завершат работу

37
00:03:16,050 --> 00:03:21,084
за то время, что мы ожидаем. И очень, очень часто можно видеть

38
00:03:21,084 --> 00:03:26,080
в сегодняшних вычислениях, что клиент получает плухую

39
00:03:26,080 --> 00:03:31,026
производительность, потому сто программист не понял производительные

40
00:03:31,026 --> 00:03:36,086
характеристики алгоритма. И в сегодняшней лекции мы постараемся

41
00:03:36,086 --> 00:03:42,087
избежать этого. Мы сконцентрируемся на производительности и сравнении алгоритмов в 

42
00:03:42,087 --> 00:03:48,064
в этом курсе. Есть и другие курсы в стандартном учебном плане по компьютерным наукам, которые

43
00:03:48,064 --> 00:03:53,093
содержат больше информации о теоретическом базисе алгоритмов и я

44
00:03:53,093 --> 00:03:59,090
расскажу о них немного позже. Но наша цель - сфокусироваться на возможности предсказания

45
00:03:59,090 --> 00:04:07,007
производительности и сравнении алгоритмов. Существует много учспешных примеров

46
00:04:07,030 --> 00:04:12,081
разработки алгоритмов с лучшей производительностью, позволяющих решать

47
00:04:12,081 --> 00:04:19,025
задачи, которые иначе не могли быть решены. Я просто приведу пару 

48
00:04:19,025 --> 00:04:25,346
примеров. Один из первых и наиболее известных это алгоритм БПФ. Этот

49
00:04:25,346 --> 00:04:32,057
алгоритм для разбиения волны от n источников сигнала в переодические

50
00:04:32,057 --> 00:04:38,431
компоненты. И это основа для DVD и JPEG и многих других приложений.

51
00:04:38,431 --> 00:04:44,296
Есть простой способ сделать это, который занимает время пропорциональное N^2.

52
00:04:44,296 --> 00:04:49,080
А алгоритм БПФ занимает только NlogN шагов. И разница между NlogN и

53
00:04:49,080 --> 00:04:55,002
N^2, это разница между возможностью решить огромные задачи 

54
00:04:55,002 --> 00:04:59,078
и ее отсутствием. Множество цифровых технологий, цифровых медиа

55
00:04:59,078 --> 00:05:04,822
технологий, что мы имеет сегодня возможны благодаря быстрому алгоритму. Другой пример

56
00:05:05,051 --> 00:05:11,232
был разработан Андрю Аппелом, нынешним главой компьютерных наук 

57
00:05:11,232 --> 00:05:16,582
здесь в Принстоне. И он был разработан, когда он работал над своим

58
00:05:16,582 --> 00:05:22,725
дипломом. Это алгоритм для моделирования задачи N тел. Простой

59
00:05:22,725 --> 00:05:28,548
алгоритм занимает время пропорциональное N^2, но алгоритм Аппеля был NlogN

60
00:05:28,548 --> 00:05:33,452
алгоритмом, что означало что ученые могли делать моделирование N тел для 

61
00:05:33,452 --> 00:05:41,478
больших значений N. Что сделало возможным новые исследования. Итак задача которую мы 

62
00:05:41,478 --> 00:05:47,677
обычно встречаем, это будет ли моя программа способна работать с большой задаче. И 

63
00:05:47,677 --> 00:05:52,024
на самом деле, работающие программисты сталкиваются с этим все время.

64
00:05:52,024 --> 00:05:58,001
Почему моя программа работает так медленно? Почему ей не хватает памяти? И с этим

65
00:05:58,001 --> 00:06:05,000
программисты сталкиваются уже долгое время, и Deuter Kanoof для понимания

66
00:06:05,000 --> 00:06:10,030
того как это решить в 1970  предложил, что мы могли бы использовать научный метод

67
00:06:10,030 --> 00:06:16,062
что бы разобраться в производительности алгоритмов в операции. Может мы не 

68
00:06:16,062 --> 00:06:23,010
новый секрет вселенной, но мы можем использовать научный метод, и относиться

69
00:06:23,010 --> 00:06:29,042
к компьютерам, как к чему-то что может быть изучено и прийти к пониманию

70
00:06:29,042 --> 00:06:34,008
того как наша программа будет исполнятся. И давайте посмотрим на это детальнее.

71
00:06:34,209 --> 00:06:39,063
Итак это просто обзор того что мы понимаем под научным методом, который был

72
00:06:39,268 --> 00:06:44,086
успешным нескольких последних сотен лет. И то что мы собираемся сделать это

73
00:06:44,086 --> 00:06:50,008
наблюдать за некоторыми особенностями окружающего мира. В нашем случае это будет

74
00:06:50,008 --> 00:06:54,857
временем работы нашего компьютера. Затем мы разработаем гипотезу

75
00:06:55,049 --> 00:06:59,079
некоторую модель которая согласовывается с наблюдениями, и мы будем надеемся, что

76
00:06:59,079 --> 00:07:04,040
эта гипотеза достаточно хорошая, что позволит нам предсказать что-нибудь.

77
00:07:04,040 --> 00:07:09,031
Обычно предсказывается время работы для задачи большого размера, или на разных компьютерах.

78
00:07:09,197 --> 00:07:13,097
И затем мы проверяем предсказания делая еще больше наблюдений и утверждений, 
до тех пор

79
00:07:13,097 --> 00:07:18,058
пока мы удостоверимся, что наша модель и наблюдения согласованны. 

80
00:07:18,058 --> 00:07:22,077
Этот способ быть уверенным что мы понимаем производительность нашей

81
00:07:22,077 --> 00:07:28,056
программы. Вместе этим научным методом, есть некоторые базовые принципы и

82
00:07:28,056 --> 00:07:33,082
первое это что если вы собираетесь запустить эксперименты, вы должны ожидать что

83
00:07:33,082 --> 00:07:39,021
кто-то другой смог бы запустить эксперименты  и получить те же результаты. 

84
00:07:39,021 --> 00:07:44,067
Так же гипотез должна иметь свойства того что эксперименты могут показать 

85
00:07:44,067 --> 00:07:49,736
ее ошибочность. Она должны быть аккуратно составлена, и мы должны обязательно

86
00:07:49,736 --> 00:07:55,433
пробовать сделать это. Таким образом, и снова будущее мира природы, что мы 

87
00:07:55,433 --> 00:08:00,822
изучаем некоторый конкретный компьютер, который существует в природном мире. Он меняет 

88
00:08:00,822 --> 00:08:07,049
алгоритм с абстрактного на некоторый  реальный физический процесс

89
00:08:07,049 --> 00:08:11,083
происходящий как электронная гонка внутри компьютера.