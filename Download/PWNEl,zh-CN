1
00:00:01,076 --> 00:00:06,044
接下来，我们将学习从下往上方式的归并排序。归并排序作为

2
00:00:06,044 --> 00:00:11,006
递归程序是简单易理解的。虽然这个从下往上的方式不是递归

3
00:00:11,006 --> 00:00:16,814
但也比较容易理解。其基本方法为

4
00:00:16,814 --> 00:00:23,057
把开始未排序的每一个元素视为已排序的序列

5
00:00:23,057 --> 00:00:28,065
该序列长度为一。接下来此方法将遍历并合并

6
00:00:28,065 --> 00:00:33,048
一对长度为一的子序列，成为一组长度为二的子序列

7
00:00:33,048 --> 00:00:38,038
然后对长度为二的子序列进行合并再排序

8
00:00:38,038 --> 00:00:43,059
这样我们就有一组长度为四的已排序的子序列，然后合并长度为八

9
00:00:43,059 --> 00:00:49,036
以此类推。从这个例子中我们可以看出，从长度为一的子序列开始

10
00:00:49,036 --> 00:00:55,360
合并排序成长度为二的子序列E，M，然后

11
00:00:55,360 --> 00:01:01,001
不断重复这一过程

12
00:01:01,001 --> 00:01:06,088
直到我们从十六个长度为一的子序列变为两组长度为八的子序列

13
00:01:06,090 --> 00:01:12,012
在第二轮中，我们将E，M与另一组G，R

14
00:01:12,012 --> 00:01:17,735
合并排序为EGMR，以及E，S与O，R合并为EORS，以此类推

15
00:01:17,735 --> 00:01:22,744
我们有四组长度为四的子序列，第三轮我们将每两组合并

16
00:01:22,745 --> 00:01:29,304
得到两组长度为八的子序列，最后一轮的到一个完全排序的序列。这样做的好处是

17
00:01:29,304 --> 00:01:34,943
这一操作遍历整个序列并且不需要递归

18
00:01:34,943 --> 00:01:41,338
从以下代码可以看出它非常容易编写

19
00:01:41,338 --> 00:01:47,442
采用同样的合并代码并运用嵌套循环

20
00:01:47,442 --> 00:01:53,373
这个数是子序列的大小，这一层循环是logN时间复杂度，因为每次

21
00:01:53,373 --> 00:02:00,162
我们合并序列为两倍长，直到长度为N。然后我们从low到low+size-1排列

22
00:02:00,449 --> 00:02:07,553
接着是low+size+size-1

23
00:02:07,553 --> 00:02:13,307
直到我们达到序列最末，最末的子序列也许

24
00:02:13,307 --> 00:02:19,397
长度不够sz。这就是一个完全达到业界标准的排序代码

25
00:02:19,397 --> 00:02:25,756
相对普通归并排序，它的唯一负面影响在于需要额外

26
00:02:25,756 --> 00:02:31,956
存储空间，大小与序列长度有关。除了这点外这是一个很好的

27
00:02:31,956 --> 00:02:39,857
归并排序方法。以上是从下往上的归并排序。这个视屏演示了它

28
00:02:39,857 --> 00:02:45,477
的操作过程。最初是完全未排序的

29
00:02:45,477 --> 00:02:49,712
然后合并子序列长度为4，8，16直到32

30
00:02:49,712 --> 00:02:55,320
在这个例子中，倒数第二轮的第二个子序列长度更小，但对于合并操作来说

31
00:02:55,320 --> 00:03:01,225
这没什么影响。你可以合并不同长度的序列

32
00:03:01,225 --> 00:03:07,106
最后我们的到一个完全排序的序列。无论大小，从下往上的归并排序

33
00:03:07,106 --> 00:03:13,833
时间复杂度为logN。而每一轮需要进行N次比较，因此总复杂度为NlogN