1
00:00:02,014 --> 00:00:08,087
现在我们将学习KD树，这是一个BST的拓展，它让我们可以

2
00:00:08,087 --> 00:00:16,057
高效地处理空间中的数据点，且十分灵活

3
00:00:16,057 --> 00:00:24,003
被广泛应用。现在我们将API扩展讨论

4
00:00:24,003 --> 00:00:29,077
二维键。你可以将二维键想象成

5
00:00:29,077 --> 00:00:35,044
二维几何空间中的点。我们将要

6
00:00:35,044 --> 00:00:41,089
讨论插入和搜索。我们不会讨论删除和范围搜索和范围技术

7
00:00:41,089 --> 00:00:47,057
现在我们想要插入和删除点。你可以将

8
00:00:47,057 --> 00:00:53,318
二维键想象成二维空间中的点。我们想要

9
00:00:53,318 --> 00:00:58,227
能够找到任意在二维范围中的键。这是一个长方形

10
00:00:58,227 --> 00:01:03,042
我们之前提到过，在一个二维范围中对键计数

11
00:01:03,042 --> 00:01:08,075
这里是键或点在几何平面的表示

12
00:01:08,075 --> 00:01:14,002
我们有一个2D范围，一个与横向和纵向对齐的长方形

13
00:01:14,021 --> 00:01:20,675
我们想要能够找到

14
00:01:20,675 --> 00:01:27,230
或计算这个长方形中的点。这一例子有许多应用

15
00:01:27,230 --> 00:01:33,162
我们稍后会涉及。比如将"点"具体化

16
00:01:33,162 --> 00:01:40,042
在数据空重你可能想要得到收入在1000000到

17
00:01:40,042 --> 00:01:45,988
10000000，年龄40到50岁的人。这类算法和数据结构对此类应用

18
00:01:45,988 --> 00:01:51,961
是很有用的。现在我们来解决这个问题

19
00:01:51,961 --> 00:01:57,935
如何实现API？我们构造一个数据结构

20
00:01:57,935 --> 00:02:03,740
此结构包含支持高效范围搜索的点和范围技术。一个

21
00:02:03,740 --> 00:02:09,999
的办法是将一个空间分割成方格网格

22
00:02:09,999 --> 00:02:16,949
我们用参数M将空间分成M乘M个方格

23
00:02:16,949 --> 00:02:23,312
然后处理所有的点并对每个方格中的点列表

24
00:02:23,312 --> 00:02:30,073
我们可以用二位数组对其直接编号，按方格划分

25
00:02:30,073 --> 00:02:36,277
对于插入，你要找到X，Y对应那个方格。只要将其除以M

26
00:02:36,277 --> 00:02:42,290
即可在二位数组中找到所属的方格，然后将

27
00:02:42,290 --> 00:02:47,049
该点加入到对应的方格中

28
00:02:47,049 --> 00:02:52,144
对于范围搜索，只需要找到与待查询点有关的方格并处理

29
00:02:52,144 --> 00:02:59,830
对于参数M的值

30
00:02:59,830 --> 00:03:06,914
是空间/时间的交易。其所需空间为M^2+N。你需要

31
00:03:06,914 --> 00:03:14,527
一个链表或其他结构来表示每一点

32
00:03:14,527 --> 00:03:20,336
而每一个方格所需的时间为总时间除以M^2。你的点分布在

33
00:03:20,336 --> 00:03:26,668
N个不同的方格中。因此平均下来你在每个方格中查找了N/M^2次

34
00:03:26,668 --> 00:03:33,451
因此你不想让M太大，这会需要许多存储空间，也不想

35
00:03:33,451 --> 00:03:39,219
让M太小，这样你会需要很多时间。因此我们要

36
00:03:39,219 --> 00:03:45,427
选择让二者平衡的方格大小，显然，我们希望

37
00:03:45,427 --> 00:03:51,898
M大约是N的开平方，从而你的空间大小

38
00:03:51,898 --> 00:03:58,321
是N的常数倍，而时间大小是常数

39
00:03:58,321 --> 00:04:04,675
因此如果所有的点是随机分布的，这是最理想的情况。它让我们用线性时间

40
00:04:04,675 --> 00:04:11,069
初始化数据结构。对于一个范围内的点插入和搜索

41
00:04:11,069 --> 00:04:17,094
它也用常数时间。当所有的点平均分布时，这是一个

42
00:04:17,094 --> 00:04:23,388
有效且易于实现的方法。然而

43
00:04:23,388 --> 00:04:28,812
大多数情况中，这些点的几何分布并不是均匀的

44
00:04:28,812 --> 00:04:34,289
有一个普遍的现象叫集群，意为

45
00:04:34,289 --> 00:04:39,203
数据点并不会平均散落在整个范围中

46
00:04:39,203 --> 00:04:44,827
在网格的实现方式中，可能所有的点都集中在一个

47
00:04:44,827 --> 00:04:49,694
方格上。因此每个表的平均长度很短

48
00:04:49,694 --> 00:04:56,022
这与我们在哈希表中遇到的问题类似。如果所有的点在一个方格中

49
00:04:56,022 --> 00:05:01,986
你的平均值还是N/M^2，但所有的点都在那一个长列表中

50
00:05:01,986 --> 00:05:08,138
如果算法基于这个长列表将会很慢

51
00:05:08,138 --> 00:05:14,442
因此我们需要一种能够更好适应不同数据分布的数据结构

52
00:05:14,442 --> 00:05:21,640
再次强调，多数情况下数据的几何分布都有不均的问题

53
00:05:21,640 --> 00:05:28,779
这里有个例子，关于美国的城市分布。有13000个点

54
00:05:28,779 --> 00:05:34,924
但如果你试图用网格的方法实现，你会发现

55
00:05:34,924 --> 00:05:41,883
大约有一半的方格会是空的。有一半的点分布在百分之十的

56
00:05:41,883 --> 00:05:47,426
方格中。因此，数据的集群将降低算法的效率

57
00:05:47,426 --> 00:05:52,875
我们需要适应数据分布，这是数据几何分布的非常典型的情况

58
00:05:52,875 --> 00:05:58,491
尤其在高维数据中，我们将会看到

59
00:05:58,491 --> 00:06:05,027
因此，人们发明了各种方法来适应数据分布

60
00:06:05,027 --> 00:06:11,027
我们将要学习最广泛使用的一种

61
00:06:11,027 --> 00:06:17,050
那就是使用树来表示递归细分的平面，二维空间

62
00:06:17,050 --> 00:06:22,451
它是递归实现的。它将

63
00:06:22,451 --> 00:06:30,322
根据数据将平面平分。它是许多方法中的一种

64
00:06:30,322 --> 00:06:36,856
简单且广泛被使用

65
00:06:36,856 --> 00:06:44,803
比如，你玩游戏Doom或模拟飞行

66
00:06:44,803 --> 00:06:51,380
这类的动画和画面模拟只能用空间分割树实现

67
00:06:51,380 --> 00:06:58,422
比如2d树和4d树

68
00:06:58,422 --> 00:07:05,689
以及在科学数据处理的时候这些是非常重要的方面

69
00:07:05,689 --> 00:07:11,061
对于几何分布数据做某种几何范围搜索

70
00:07:11,061 --> 00:07:17,058
最接近的点在哪？我如何高效找到近的点？

71
00:07:17,058 --> 00:07:23,315
有哪些点在附近？等等。可以肯定

72
00:07:23,315 --> 00:07:29,660
这一类的算法是这类程序的核心，即

73
00:07:29,660 --> 00:07:35,550
如何处理几何分布的数据。这里有两个例子

74
00:07:35,550 --> 00:07:41,091
我们来看看，一个2D树，再次强调，将是一个

75
00:07:41,091 --> 00:07:47,070
基于一堆点的数据结构，它可以高效低处理这些数据点

76
00:07:47,070 --> 00:07:53,093
就像我们对符号表的处理，使用键

77
00:07:54,015 --> 00:07:59,065
对于各个点，我们将构造一个数据结构

78
00:07:59,065 --> 00:08:05,030
概念是，构造一个可以

79
00:08:05,030 --> 00:08:10,079
划分空间平面的树。我们第一个点将随机地把空间

80
00:08:11,000 --> 00:08:16,084
分成两部分。现在

81
00:08:17,004 --> 00:08:22,063
在右边图中，所有的在划分点左边的点将

82
00:08:22,063 --> 00:08:27,099
在左平面，右边的点归为右平面

83
00:08:27,099 --> 00:08:32,094
在第一次划分后，你将在右边。但当我们看第二个点

84
00:08:32,094 --> 00:08:38,048
我们将对按水平线划分。因此对于第二个点

85
00:08:38,071 --> 00:08:45,035
左子树对应所有在水平面下的点，而右子树对应水平向上的点

86
00:08:45,035 --> 00:08:52,022
同样对于第三个

87
00:08:52,022 --> 00:08:58,083
在左边的点，我们将按照通过该点的水平线划分

88
00:08:58,083 --> 00:09:05,060
因此当我们继续向左这意味着所有在一号点左边和上边。因此由

89
00:09:05,060 --> 00:09:12,029
通过三和一划分线形成了左上角的方格

90
00:09:12,029 --> 00:09:18,025
类似的，我们向下看一级

91
00:09:18,025 --> 00:09:23,052
我们改成垂直线划分。我们用水平和垂直

92
00:09:23,052 --> 00:09:29,001
交替划分平面。这是一个常规的二叉搜索树。但它

93
00:09:29,001 --> 00:09:34,084
在几何数据中的表示，就是我们对于每一级的key

94
00:09:34,084 --> 00:09:40,073
对于按x轴还是y轴划分交替进行

95
00:09:40,073 --> 00:09:45,092
这对应了对于平面的分割。现在我们看第五个，它在

96
00:09:45,092 --> 00:09:50,055
四的左边，因为是按照垂直分割，而五将要按照

97
00:09:50,055 --> 00:09:59,083
水平分割。这是一个简单完善的将平面分割

98
00:09:59,083 --> 00:10:08,041
为二叉树的方法。现在，第九个点在第八个点的左上方

99
00:10:08,041 --> 00:10:13,085
对应于水平分割

100
00:10:13,085 --> 00:10:19,066
第十个点在一的右边，在二的左下边

101
00:10:19,066 --> 00:10:28,088
在七的右边，因此有图中是7的右子数

102
00:10:28,088 --> 00:10:33,463
以上是根据平面分割构造二叉树的方法。

103
00:10:33,463 --> 00:10:38,171
而它基本上就是二叉搜索树。唯一区别是我们交替使用

104
00:10:38,171 --> 00:10:42,593
不同坐标作为键。在偶数层，我们用垂直线划分

105
00:10:42,593 --> 00:10:47,614
左子树包含所有左边的点，右子树包含所有右边的点

106
00:10:47,614 --> 00:10:52,765
在奇数层，我们按水平线划分，所有以下的点在左子树

107
00:10:52,765 --> 00:10:57,762
以上的点在右子树

108
00:10:57,762 --> 00:11:03,037
实现它的代码和二叉搜索树一样简单

109
00:11:03,057 --> 00:11:08,078
唯一不同是我们用坐标来比较。以上是2D树的实现

110
00:11:08,078 --> 00:11:14,032
现在我们将来解决一个对于

111
00:11:14,032 --> 00:11:20,001
2D树的范围搜索问题。现在我们有一个图中绿色的长方形

112
00:11:20,001 --> 00:11:25,055
我们想要找到所有落于这个长方形内的点

113
00:11:25,055 --> 00:11:31,016
我们将用2D树来表示这些点并

114
00:11:31,016 --> 00:11:37,035
利用该树的结构和定义来帮助我们找到

115
00:11:37,035 --> 00:11:43,091
长方形中的点。如果根节点落于此长方形中

116
00:11:43,091 --> 00:11:51,301
我们返回那个点， 再继续看root两边的点

117
00:11:51,301 --> 00:11:57,419
如果长方形在根节点的左边，我们只需要看左子树

118
00:11:57,419 --> 00:12:06,248
以此类推。我们在demo中看一下这个过程

119
00:12:06,248 --> 00:12:11,088
好了我们现在要找到所有在绿色方块中的点。

120
00:12:11,088 --> 00:12:17,098
第一件事是检查根节点是否落于方块内

121
00:12:17,098 --> 00:12:23,051
这里答案是没有。因为方块在根节点的左边

122
00:12:23,051 --> 00:12:29,033
我们只需要看左子树

123
00:12:29,033 --> 00:12:34,078
我们将要看它是否包含,3。它不含

124
00:12:34,078 --> 00:12:42,041
,3, 那么我们应该搜索哪边的子树呢？这里，因为该长方形覆盖了一个

125
00:12:42,041 --> 00:12:48,055
分割线，所以我们需要搜索两边的子树，即水平线上

126
00:12:48,055 --> 00:12:55,024
和线下。我们先来搜索左子树，即水平线下的是否

127
00:12:55,024 --> 00:13:01,014
包含,4?不，它在四的左边因此我们将搜索

128
00:13:01,014 --> 00:13:07,650
,4的左子树。我们查看左子树发现它包含五

129
00:13:07,650 --> 00:13:12,830
我们将返回五。它包含了五的分割线的两边

130
00:13:12,830 --> 00:13:18,026
因此我们要搜索两边的子树，这里两边都是

131
00:13:18,026 --> 00:13:24,022
空的。因此我们完成这一部分但需要返回并搜索

132
00:13:24,022 --> 00:13:30,464
三另一边的子树。因此现在我们检查,6是否在

133
00:13:30,464 --> 00:13:35,527
方形区域中，这里答案是否。我们还需要继续搜索

134
00:13:35,527 --> 00:13:41,126
,6的左子树，这里为空，因此我们可返回并完成了所有搜索

135
00:13:41,126 --> 00:13:47,110
当我们的方形区域覆盖了分割线我们需要

136
00:13:47,110 --> 00:13:52,348
深入两边的分支，但这仍是一个高效的算法

137
00:13:52,348 --> 00:13:57,401
介于这个长方形区域很小，它和

138
00:13:57,401 --> 00:14:04,620
普通的二叉树搜索几乎一样

139
00:14:04,620 --> 00:14:10,025
下面我们来分析它的时间复杂度。这个典型例子中

140
00:14:10,025 --> 00:14:15,582
一个小的长方形区域对应我们只需要检查树的某一分枝

141
00:14:15,582 --> 00:14:21,639
也许在那个分枝上只有几个节点，返回所需的时间

142
00:14:21,639 --> 00:14:27,444
将取决于返回点的个数加logN。对于几何数据

143
00:14:27,444 --> 00:14:33,650
最坏的情况会很坏，比如所有的点都落于这一范围内

144
00:14:33,650 --> 00:14:40,158
所有不同类型的问题都会出现这一情况，有一定难度

145
00:14:40,158 --> 00:14:46,963
经证明及时树是平衡的，你可以得到最坏的情况是

146
00:14:46,963 --> 00:14:53,456
与N的开平方有关。对于2D树的分析目前不再讨论范围

147
00:14:53,456 --> 00:14:59,987
但在实际应用中它们简单易实现并且值得使用

148
00:14:59,987 --> 00:15:06,241
让我们来看另一个2D树来解决的问题，最邻近搜索

149
00:15:06,241 --> 00:15:12,046
现在，取代长方形的是一个查询点

150
00:15:12,046 --> 00:15:17,956
我们的目标是找到离它最近的点。这里那个绿色的是我们的查询点

151
00:15:17,956 --> 00:15:23,231
我们的算法将返回0,5，那是距离查询点最近的结果

152
00:15:23,231 --> 00:15:30,263
现在我们来看一个demo。同样的，我们从

153
00:15:30,263 --> 00:15:38,969
根节点开始。如何做呢？每当在一个节点

154
00:15:38,969 --> 00:15:44,074
它代表平面中的点因此我们将

155
00:15:44,074 --> 00:15:50,053
计算这一点到查询点的距离。

156
00:15:50,053 --> 00:15:56,074
当它是我们目前找到的最近的点，我们将保留其为最优

157
00:15:56,074 --> 00:16:02,080
因此从第一个点开始，它是我们目前找到离查询点最近的

158
00:16:02,080 --> 00:16:09,015
我们只需要考虑找到

159
00:16:09,015 --> 00:16:15,043
比一更近的可能性。我们只需要利用这个距离迭代搜索

160
00:16:15,043 --> 00:16:23,050
树的每一个可能含有更近点的部分部分

161
00:16:23,050 --> 00:16:28,092
这里查询点在分割线的左边

162
00:16:28,092 --> 00:16:34,090
我们总是想要更靠近查询点，这里我们

163
00:16:35,011 --> 00:16:40,068
需要搜索两边来看是否右边的子数

164
00:16:40,088 --> 00:16:46,004
有可能比一更近

165
00:16:46,004 --> 00:16:51,005
我们已经知道两边都要检查现在我们将

166
00:16:51,005 --> 00:16:57,013
与查询点比较是否有更近的点。这里

167
00:16:57,013 --> 00:17:03,613
我们来到,3。 计算得到更近距离因此

168
00:17:03,613 --> 00:17:09,891
我们更新点三为最优。现在我们将要寻找

169
00:17:09,891 --> 00:17:16,502
树中是否有部分可以给我们比三离查询点更近的点

170
00:17:16,502 --> 00:17:22,613
这意味着我们搜索点一的时候我们不搜索其右子树

171
00:17:22,613 --> 00:17:28,571
因为在分割线的右边可能没有点

172
00:17:28,571 --> 00:17:34,113
现在让我们比三更接近查询点，这个方法将使我们

173
00:17:34,113 --> 00:17:39,551
将树切割成不同部分

174
00:17:39,551 --> 00:17:44,947
我们从点三开始看两边的子树

175
00:17:44,947 --> 00:17:50,545
有时候我们看两边子树直到

176
00:17:50,545 --> 00:17:55,826
越来越近，只看一个数。现在我们还是来看点三

177
00:17:55,826 --> 00:18:02,911
同样的，向着查询点，我们从顶部开始

178
00:18:02,911 --> 00:18:10,018
我们找到了六。六并不比三更近，因此不更新最优

179
00:18:10,018 --> 00:18:17,624
接下来我们看到6的左子树为空而右

180
00:18:17,624 --> 00:18:23,307
子树不可能更近，我们不需要看六的右子树

181
00:18:23,307 --> 00:18:29,296
因为我们不可能在六右边长方区域中有点比三更近

182
00:18:29,296 --> 00:18:35,482
因此我们从六返回来看

183
00:18:35,482 --> 00:18:41,264
三的分割线下边。这将我们带到四

184
00:18:41,264 --> 00:18:47,577
而四并没有更近。因此三仍是我们的最优

185
00:18:47,577 --> 00:18:54,208
我们将继续搜索四的左子树，因为查询点在

186
00:18:54,208 --> 00:18:59,742
四分割线的左边。这将我们带到五而五成为我们的最优点

187
00:18:59,742 --> 00:19:06,529
现在五是我们的最近点。有可能出现比五

188
00:19:06,529 --> 00:19:13,766
离查询点更近的右子树上的节点吗？

189
00:19:13,766 --> 00:19:19,303
我们看到

190
00:19:19,303 --> 00:19:25,649
五对应的右子树为空。现在我们回到四。我们需要搜索

191
00:19:25,649 --> 00:19:32,281
四的右子树吗？不，因为四的右子树上不可能有比五

192
00:19:32,281 --> 00:19:38,745
更近的点了。现在完成了四的搜索，我们回到三

193
00:19:38,745 --> 00:19:45,508
我们将会在三完成搜索返回到一

194
00:19:45,508 --> 00:19:50,504
我们应该搜索右子树但我们可以断定最近邻

195
00:19:50,504 --> 00:19:56,489
不可能在右子树上。现在我们完成了整个搜索的到最近的点为五

196
00:19:56,489 --> 00:20:01,419
这将是很高效的搜索，因为当我们离查询点

197
00:20:01,419 --> 00:20:07,057
越来越近，我们剔除所有相对远离的子树

198
00:20:07,057 --> 00:20:12,098
在实际情况中，该算法的运行时间将接近

199
00:20:12,098 --> 00:20:17,970
对数级。再次总结，在典型的情况下

200
00:20:17,970 --> 00:20:23,376
2D树的最近邻搜索运行时间将是对于级的。有一种极端情况是

201
00:20:23,376 --> 00:20:29,073
可能所有的点都要遍历

202
00:20:29,274 --> 00:20:35,059
比如所有的点几何分布为一个圆周而你的另近点是该圆心

203
00:20:35,059 --> 00:20:40,757
但对于普通的数据它是非常有效的。现在我们来看看一个

204
00:20:40,757 --> 00:20:46,598
对于自然现象的模拟应用

205
00:20:46,598 --> 00:20:52,910
八哥，鹅，鹤和鱼还有萤火虫按照

206
00:20:52,910 --> 00:21:02,461
什么样的模式群居在一起呢？我们来看一个对此的模拟

207
00:21:02,461 --> 00:21:52,239
然后，当时机适当，它们的行动将看起来毫无可能发生

208
00:21:52,239 --> 00:22:48,657
[音乐]而这样的事在冬天每天都发生

209
00:22:48,657 --> 00:22:57,639
离我家门几英里的地方……

210
00:22:57,639 --> 00:23:05,159
这里我们可以看到一个很久以前来自Graig Reynolds的简单模型

211
00:23:05,159 --> 00:23:10,722
称作光圈。它的概念是用三个简单的规则来得到

212
00:23:10,722 --> 00:23:15,397
与这复杂的群聚行为类似的东西。你试图

213
00:23:15,397 --> 00:23:21,500
避免碰撞到k个最邻近的圈

214
00:23:21,500 --> 00:23:27,615
你试图找到那K个最邻近圈的中心

215
00:23:27,615 --> 00:23:33,372
并跟上邻近k个圈移动的速度

216
00:23:33,372 --> 00:23:42,004
这个算法是这样的，在这个例子中

217
00:23:42,004 --> 00:23:47,020
2D树对于快速处理大量几何数据及其有效

218
00:23:47,020 --> 00:23:52,071
更多的，它可以拓展到更多维

219
00:23:52,071 --> 00:23:59,002
利用一个简单的修改，我们可以将2D树创造为

220
00:23:59,002 --> 00:24:04,088
KD树，即对K维

221
00:24:04,088 --> 00:24:11,004
我们将每次迭代分割一维

222
00:24:11,004 --> 00:24:17,043
我们叫它KD树，利用与2D树同样的方法，但

223
00:24:17,043 --> 00:24:23,878
将水平和垂直交替分割替代成，循环每一维

224
00:24:23,878 --> 00:24:30,076
比如在三位空间中，我们用一个平面对每一维分割为上和下

225
00:24:30,076 --> 00:24:35,884
在I级上，我们将

226
00:24:35,884 --> 00:24:41,749
第I级坐标小于P的放到左子树，将第I级坐标

227
00:24:41,749 --> 00:24:48,252
放到右子树，然后循环k除I的余数次

228
00:24:48,252 --> 00:24:54,019
我们用那一维德点来做比较

229
00:24:54,019 --> 00:24:59,075
该算法实现很简单，除了比较的部分

230
00:24:59,075 --> 00:25:05,044
我们需要以某种方式分割三维数据，这样我么可以

231
00:25:05,044 --> 00:25:11,026
在三位空间中做光圈，或扩展到更多维的数据库。

232
00:25:11,046 --> 00:25:16,095
对于更高维数据，我们可以找到最近邻的点并做高效的范围搜索

233
00:25:16,095 --> 00:25:23,048
这是一个非常有效和简单的数据结构

234
00:25:23,048 --> 00:25:29,592
针对K维数据处理的广泛应用。它关注的是

235
00:25:29,592 --> 00:25:35,069
数据群，尤其高维数据。有一点要提到的是

236
00:25:35,069 --> 00:25:41,023
这个算法是由一名叫做

237
00:25:41,023 --> 00:25:47,055
John Bentley在算法课上发明的，来自

238
00:25:47,055 --> 00:25:53,030
斯坦福大学。这是一个解决专家科学家们都很头痛的问题的简单方法

239
00:25:53,030 --> 00:25:59,061
针对大量几何数据，Bentley找到了这种方法，可以

240
00:25:59,061 --> 00:26:05,070
高效地处理数据并被广泛沿用至今

241
00:26:05,070 --> 00:26:12,078
尤其是另一个例子，当我们考虑一个

242
00:26:13,005 --> 00:26:20,057
经典物理学问题N体模拟，有N个粒子互相

243
00:26:20,057 --> 00:26:28,063
受到引力作用，我们想要计算基于每一对

244
00:26:28,063 --> 00:26:36,007
粒子之间的相互作用力，这里将会有共同的相互拉力

245
00:26:36,007 --> 00:26:43,031
[]这是当有大量

246
00:26:43,031 --> 00:26:49,085
粒子共同作用时宇宙中会发生情况的模拟

247
00:26:49,085 --> 00:26:56,065
对这些模拟进行计算然后与

248
00:26:56,065 --> 00:27:03,081
宇宙中观察到的现象比较。现在真对每一对粒子

249
00:27:03,081 --> 00:27:11,312
你有M个粒子，你需要对每一对左计算，即M^2

250
00:27:11,312 --> 00:27:17,447
那么科学研究的进度将取决于对庞大数量

251
00:27:17,447 --> 00:27:24,723
的粒子相互作用如何进行快速运算

252
00:27:24,723 --> 00:27:32,005
宇宙中有无数粒子。你不可能对一个很大的N做平方级运算

253
00:27:32,005 --> 00:27:38,986
因而另一个本科生在算法课上发现了这个适用于N体模拟的算法

254
00:27:38,986 --> 00:27:45,699
名叫Andrew Appel。他的方法是如果某些粒子距离某个群很远

255
00:27:45,699 --> 00:27:51,039
我们可以将那个群当作一个聚合的粒子

256
00:27:51,039 --> 00:27:57,042
从而不需要针对该群中每一个粒子与我们

257
00:27:57,042 --> 00:28:03,052
的粒子的相互作用做计算，而是用中心质量

258
00:28:03,052 --> 00:28:10,048
你会得到一个对N体问题的非常精确的近似

259
00:28:10,048 --> 00:28:16,037
而他所使用的算法就是实用3D树。将N个粒子做为节点，每个节点上

260
00:28:16,037 --> 00:28:23,581
存储子树的中心质量。要得到总的力

261
00:28:23,581 --> 00:28:31,045
通过遍历树得到所有信息，完成N体计算

262
00:28:31,045 --> 00:28:38,283
但时间复杂度更接近于NlgN而不是N^2。

263
00:28:38,283 --> 00:28:45,000
这就是不需要N^2复杂度的算法，利用几何算法

264
00:28:45,000 --> 00:28:52,692
比如3D树，你可以得到复杂度NlgN。这一发现

265
00:28:52,692 --> 00:29:00,296
为各种科学探索开启了新的可能