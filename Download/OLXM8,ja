1
00:00:01,006 --> 00:00:06,058
良いでしょう。もう私たちは巨大な対象に対する
統合問題を解くための

2
00:00:06,058 --> 00:00:12,025
効率的な実装を見てきましたから、
どのようにその実装が応用されているか

3
00:00:12,025 --> 00:00:17,095
見ていきましょう。
Union-findのアプリケーションは数多くあります。

4
00:00:17,095 --> 00:00:24,005
私たちはネットワーク上の動的接続性について
話しましたが、それ以外にも

5
00:00:24,005 --> 00:00:30,008
計算機基盤では問題例がたくさんあります。
一番下には、画像処理の分野での

6
00:00:30,008 --> 00:00:36,018
画像内の領域へのラベル付け問題という
重要な問題の例がありますね。

7
00:00:36,018 --> 00:00:41,057
後ほど、クラスカルの最小スパニングツリー
アルゴリズムを見ていきます。

8
00:00:41,057 --> 00:00:48,009
これは、グラフ処理のアルゴリズムで、
サブルーチンとしてUnion-findを使います。

9
00:00:48,009 --> 00:00:54,077
物理学の分野でも例に示すとおり、
物理現象の理解のためのアルゴリズムがありますし、

10
00:00:55,000 --> 00:01:00,064
このリストには他にもたくさんあります。
それでは、ここではそのうちの１つ、浸透問題についてお話します。

11
00:01:00,086 --> 00:01:07,046
多くの物理系のモデルであり、
ここでは抽象化したモデルを示し

12
00:01:07,046 --> 00:01:13,063
物理系にどのように応用されているか
簡単にお話します。

13
00:01:13,063 --> 00:01:20,076
サイトと呼ばれるn×nのグリッドを
考えましょう。各サイトが

14
00:01:21,001 --> 00:01:27,076
確率pで開いているとき白で、

15
00:01:27,076 --> 00:01:34,029
確率(1-p)で閉じているとき黒で表示しています。
このとき、系が浸透されているとは

16
00:01:34,029 --> 00:01:40,059
開いているサイトで上下が
接続されていることを言います。

17
00:01:40,059 --> 00:01:46,089
左側の絵の系では、上下が白の
四角で通れる道が見つかりますが、

18
00:01:46,089 --> 00:01:53,019
右側の絵の系では浸透しません。

19
00:01:53,019 --> 00:02:00,017
上下が白い四角でつながる道がないからです。

20
00:02:00,017 --> 00:02:05,098
これは多くの系に対するモデルになっています。
電気回路を考えれば良いでしょう。

21
00:02:05,098 --> 00:02:11,091
白のサイトはコンダクタで、
黒のサイトは絶縁されていると考えます。

22
00:02:11,091 --> 00:02:17,091
上下間でコンダクタがあれば電気が通じます。

23
00:02:17,091 --> 00:02:23,039
あるいは、何か多孔質物質に
水を通す場合などを考えても良いでしょう。

24
00:02:23,039 --> 00:02:28,055
この場合、空きサイトは空洞で、
黒サイトは何か物質があります。

25
00:02:28,055 --> 00:02:34,030
それで、上から下に向かって水が通るか
どうか、という問題です。

26
00:02:34,030 --> 00:02:39,869
あるいはソーシャルネットワークを
考えても良いでしょう。この場合、対象は人であり、

27
00:02:39,869 --> 00:02:46,063
２人の間がつながっているかどうか、
あるグループから別のグループへの

28
00:02:46,063 --> 00:02:52,076
つながりがソーシャルネットワークに
あるかが問題になります。

29
00:02:52,076 --> 00:02:58,089
これらが浸透問題のちょっとした例です。
ランダム化したモデルで話すと、

30
00:02:58,089 --> 00:03:05,075
サイトは与えられた確率で空きになります。
そのため、空きの確率pが

31
00:03:06,005 --> 00:03:11,087
低い左の図の場合ですと、
２つ図面の例がありますが、

32
00:03:11,087 --> 00:03:17,002
浸透しないのは極めて明快です。

33
00:03:17,002 --> 00:03:22,016
上下が接続できるだけの空きサイトが
十分にないですから。

34
00:03:22,016 --> 00:03:26,002
確率が大きいと空きサイトがたくさん
ありますので、間違いなく浸透するでしょう。

35
00:03:26,002 --> 00:03:30,055
上下間を行き来できる道はたくさんできるでしょう。
しかし、真ん中の例のように

36
00:03:30,055 --> 00:03:35,067
確率が中くらいの場合、浸透するかしないかは疑問です。

37
00:03:35,067 --> 00:03:40,065
ですので、このモデルから得られる
科学的、あるいは数学的問題というのは

38
00:03:41,005 --> 00:03:46,062
浸透するのかしないのかを
どうやって知るのかということです。

39
00:03:46,062 --> 00:03:52,034
この問題や多くの似た問題に
相転移というものがあります。

40
00:03:52,034 --> 00:03:56,072
これは、確率が低ければ浸透しませんし、
高ければ浸透しますが、

41
00:03:56,072 --> 00:04:02,003
実際には浸透するかしないかの
境にある閾値は

42
00:04:02,003 --> 00:04:07,092
とても鋭いものです。
そして実際に、Nが大きくなると

43
00:04:07,092 --> 00:04:13,089
確率がある値より小さいと
ほぼ確実に浸透せず、

44
00:04:13,089 --> 00:04:19,045
ある値より大きいとほぼ確実に浸透する、
という値があります。問題はその値がいくつか、です。

45
00:04:19,045 --> 00:04:26,051
これは数学モデルの一例で、
とても歯切れの良いものです。

46
00:04:26,051 --> 00:04:32,092
閾値がいくつか、なのですから。
しかし、この数学的問題の解を誰も知りません。

47
00:04:32,092 --> 00:04:37,032
この問題の唯一の解は計算モデルから
得られるものです。

48
00:04:37,032 --> 00:04:42,082
実際にシミュレーションを実行し、
確率値を決定しているのです。

49
00:04:42,082 --> 00:04:47,093
これらのシミュレーションは、
高速Union-findアルゴリズムをもってのみ解決できます。

50
00:04:47,093 --> 00:04:53,024
これが高速Union-findアルゴリズムが必要となる
動機付けになる例です。では見てみましょう。

51
00:04:53,024 --> 00:04:59,053
ここで動かしているのはいわゆる
モンテカルロシミュレーションです。

52
00:04:59,053 --> 00:05:06,063
ここでは、いったんすべてのグリッドを
黒にしておき、ランダムに

53
00:05:06,063 --> 00:05:12,096
空きサイトにします。これを続けていき、
空きサイトを増やすごとに

54
00:05:12,096 --> 00:05:18,095
系が浸透するかどうか確認します。
これを系が浸透する点に達するまで

55
00:05:18,095 --> 00:05:24,026
続けます。そのとき、浸透したときの
空きサイト率がわかるので、

56
00:05:24,026 --> 00:05:29,080
それが閾値の推測値ということになります。

57
00:05:29,080 --> 00:05:35,008
ですので、ここで行いたいことは、
この実験を数百万回と計算機上でできる限り行いたいのです。

58
00:05:35,008 --> 00:05:40,069
浸透するかしないかの計算を
効率よく行ってです。

59
00:05:40,069 --> 00:05:45,064
これがモンテカルロシミュレーションで、
計算機上の問題であり、このような

60
00:05:45,084 --> 00:05:51,012
科学的問題で、数学的に誰も
解き方が分からない問題を解くことができます。

61
00:05:51,012 --> 00:05:56,097
それでは、モンテカルロ法を用いるために
動的接続問題をどのように使っているか

62
00:05:56,097 --> 00:06:03,092
もう少し詳しく見てみましょう。
各サイトに対応したオブジェクトを

63
00:06:03,092 --> 00:06:09,093
作るということは明らかですね。そして、
ここに示すように、各サイトに

64
00:06:09,093 --> 00:06:16,091
0からNの２乗マイナス１の名前を付けます。
そしてこれらを接続します。

65
00:06:16,091 --> 00:06:23,029
左図の浸透モデルが右図の接続モデルに

66
00:06:23,029 --> 00:06:28,089
対応します。これは今まで私たちが
行ってきたものですね。

67
00:06:28,089 --> 00:06:33,081
ここでやりたいのは、一番下の列の
どのサイトでも良いのですが、

68
00:06:33,081 --> 00:06:39,039
それが一番上の列のサイトに
接続されているかを確認することです。

69
00:06:39,039 --> 00:06:44,091
これを解く際の問題は、総当たりアルゴリズム
でしょう。それですと２乗の

70
00:06:44,091 --> 00:06:50,030
計算量になってしまいます。接続されているかを
確認するためにfindをNの２乗回呼ぶからです。

71
00:06:50,030 --> 00:06:55,048
一番上の列の各サイトについて、
一番下の列の各サイトへの接続を確認します。

72
00:06:55,048 --> 00:07:01,024
これはとても遅いです。代わりに、一番上および
一番下に仮想サイトを１つ作ります。

73
00:07:01,024 --> 00:07:06,087
それからこの系が浸透するかどうかを知りたいとすれば、

74
00:07:06,087 --> 00:07:14,025
仮想的な一番上のサイトから一番下のサイトまで
連結しているかを確認すれば良いことになります。

75
00:07:14,025 --> 00:07:20,097
新しいサイトを開けるにはどうすれば
良いでしょう？それには、単純に

76
00:07:20,097 --> 00:07:28,034
周辺の開きサイトと連結させれば良いだけです。
これはUnion操作を数回実行するだけなので、実装は簡単です。

77
00:07:28,034 --> 00:07:34,092
この関係性だけを用いて、
コードを実際に書き、

78
00:07:34,092 --> 00:07:42,000
この連結問題に関する
シミュレーションを実行してみました。

79
00:07:42,000 --> 00:07:48,082
ここで得られた答えは、十分大きなNに対して
十分な回数を行ったところ、

80
00:07:49,007 --> 00:07:55,409
浸透する閾値はおおよそ0.592746です。

81
00:07:55,409 --> 00:08:01,693
この高速なアルゴリズムを用いれば、
科学的問題に対しても正確な答えが得られるのです。

82
00:08:01,693 --> 00:08:06,822
もし遅いUnion-findアルゴリズムを使っていたら、
とても大きな問題には実行できなかったでしょうし、

83
00:08:06,822 --> 00:08:11,979
正確な値は得られなかったでしょう。
まとめますと、重要な問題を取り上げました。

84
00:08:11,979 --> 00:08:17,359
動的接続問題です。私たちはこの問題を
モデル化し、問題を解くのに必要な

85
00:08:17,359 --> 00:08:22,109
データ構造やアルゴリズムがどんなものか
正確に理解しようとしました。

86
00:08:22,109 --> 00:08:26,676
この問題を解く簡単なアルゴリズムを
見て、すぐにそれが

87
00:08:26,676 --> 00:08:31,953
巨大な問題を相手にするには不適切だと見抜きました。
しかし、より効率的なアルゴリズムを使ってどのように改良するかを見て、

88
00:08:31,953 --> 00:08:37,300
それから、このような効率の良いアルゴリズムを

89
00:08:37,300 --> 00:08:42,768
用いなくては解けない応用問題も見ました。
これらはすべて科学的な方法です。

90
00:08:42,768 --> 00:08:47,954
アルゴリズムの設計では、
数学モデルを開発しようと努めて、

91
00:08:47,954 --> 00:08:52,343
これから開発しようとするアルゴリズムの
特性の理解に役立てようとしました。

92
00:08:52,343 --> 00:08:56,675
実験を通してこのモデルをテストし、

93
00:08:56,675 --> 00:09:02,363
アルゴリズムを改良できるようにしました。
繰り返し、より良いアルゴリズムを開発し、

94
00:09:02,363 --> 00:09:07,061
より良いモデルを作り、それを関心のある問題を
実用的に解くのに必要なところまで改良しました。

95
00:09:07,061 --> 00:09:12,165
この方法が、本コースを通して使用していく
アルゴリズム学習のための

96
00:09:12,165 --> 00:09:14,036
全体像となります。