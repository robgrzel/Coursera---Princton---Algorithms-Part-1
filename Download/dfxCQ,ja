1
00:00:01,087 --> 00:00:07,024
実際のところ、計算量増加量の分類は
とても重要なもので、

2
00:00:07,024 --> 00:00:13,038
近年膨大な量の研究につながっています。
ここでは、それらについて簡単にお話しします。

3
00:00:13,038 --> 00:00:19,692
最後の例で示されたものより、
人生はもう少し複雑なものです。

4
00:00:19,692 --> 00:00:25,747
１つの問題は、入力によってアルゴリズムの性能が
大きく変わってきてしまうことが

5
00:00:25,747 --> 00:00:31,076
あることです。そこで、しばしば入力に依存した
アルゴリズム解析とは異なる

6
00:00:31,076 --> 00:00:37,001
考え方をする必要があります。つまり、実行時間は最善の場合と

7
00:00:37,001 --> 00:00:42,014
最悪の場合との間のどこかになるでしょう。
最善の場合は、アルゴリズムのコストの

8
00:00:42,014 --> 00:00:48,008
下限値です。アルゴリズムはいつでも、最善の場合より実行時間が大きいか、

9
00:00:48,008 --> 00:00:53,368
それを下回ることはありません。そして、最悪の場合もあり、これは

10
00:00:53,368 --> 00:00:58,562
最も難しい入力です。最悪値を分析すると、アルゴリズムの実行時間が

11
00:00:58,562 --> 00:01:04,327
この値より大きくなることはないと保証できます。
そして、多くの状況では、

12
00:01:04,327 --> 00:01:11,078
入力はランダムであると考えるでしょう。
ですので、何らかのモデルが必要で、

13
00:01:11,078 --> 00:01:17,577
解いている問題についてランダム値が入った時の
モデルが必要なのですが、モデル化することのできる状況は

14
00:01:17,577 --> 00:01:24,680
たくさんあり、そのため、入力が広範囲に
ばらけていたとしても性能予測が

15
00:01:24,680 --> 00:01:33,369
できるわけです。ですので、例えば
３つの数字の和の場合、いつでも同じ種類になります。

16
00:01:33,617 --> 00:01:39,441
チルダ記法を用いていますが、このアルゴリズムが変動する要因は

17
00:01:39,441 --> 00:01:46,514
カウンタ値を何回加算するかだけですので、
その意味で小さな違いしかなく、

18
00:01:46,514 --> 00:01:53,318
分析で深く追求する必要はありません。

19
00:01:53,318 --> 00:02:00,553
２分探索では、すぐに一定時間となる場合を見つけられるでしょうし、
平均および最悪の場合は

20
00:02:00,553 --> 00:02:08,205
どちらもlog2Nだと分かります。
他の場合では、分布が

21
00:02:08,205 --> 00:02:17,256
対等になる場合もあります。
このように、入力に従って、

22
00:02:17,256 --> 00:02:22,398
異なる分析方法があります。
しかし、問題なのは、実際に顧客が解こうとしている

23
00:02:22,398 --> 00:02:28,543
問題ではどうかということです。ですので、
アルゴリズムの性能を理解するためには

24
00:02:28,543 --> 00:02:33,933
このことも理解する必要があります。この点については、

25
00:02:33,933 --> 00:02:40,346
成功している２つの方針があります。
１つは最悪の場合を想定したデザインです。

26
00:02:40,346 --> 00:02:45,403
皆さんのアルゴリズムが常に高速に動き、間違いなく
理想的であることを保証する、ということです。

27
00:02:45,403 --> 00:02:50,794
もう１つは、理想を追えないならランダム値を使い、

28
00:02:50,794 --> 00:02:55,769
何か確率的に保証できるものを頼りにするやり方です。
私たちはこれから、両方の例について、コースを進めながら見ていきます。

29
00:02:55,769 --> 00:03:00,546
さて、考えるべきことなのですが、

30
00:03:00,546 --> 00:03:06,058
計算量の増加の考え方を知っていますが、このことからいわゆる、
私がこう呼んでいるのですが、「アルゴリズムの理論」の

31
00:03:06,058 --> 00:03:12,022
議論ができます。ここでの目標は、3値の足し算のような
解きたい問題があるとして、

32
00:03:12,022 --> 00:03:17,500
それがどのくらい困難な問題かを知りたいと
いうことです。その問題を解くのに

33
00:03:17,500 --> 00:03:24,302
最善なアルゴリズムを見つけたいのです。
計算機科学の研究者が使う手法は

34
00:03:24,302 --> 00:03:30,091
詳細な部分は、分析の際には極力省略する、というやり方です。

35
00:03:30,091 --> 00:03:37,015
単に実行時間を定数倍にまで落として分析するのです。
ここで計算量というものが出てきます。

36
00:03:37,015 --> 00:03:42,831
それから、入力モデルをまったく心配しないようにしたいのです。

37
00:03:42,831 --> 00:03:48,070
ですので、最悪の場合について焦点を当てます。

38
00:03:48,090 --> 00:03:54,372
これで、私たちは計算量の増加だけでアルゴリズムの性能に
ついて語ることができます。

39
00:03:54,372 --> 00:03:59,357
非常に厳密な方法でこれを行うことが実際できます。

40
00:03:59,357 --> 00:04:04,692
このやり方によって、問題を解く難しさについて
たくさんのことを学べます。

41
00:04:04,692 --> 00:04:11,326
私たちの目標は最適なアルゴリズムを見つけることです。
任意の入力に対して、定数倍の範囲で実行できる保証のあるものです。

42
00:04:11,326 --> 00:04:17,735
最悪の場合が分かっているので。
しかし、

43
00:04:17,735 --> 00:04:24,022
より良い性能を保証するアルゴリズムが分からないものも
あることは認める必要があります。これについては、

44
00:04:24,022 --> 00:04:31,549
いくつか簡単な例を出そうと思います。
さて、この分析を行うためには、一般的に使われている記法があります。

45
00:04:31,549 --> 00:04:39,745
大文字のセータ、大文字O、大文字オメガ表記と呼ばれるものです。

46
00:04:40,033 --> 00:04:47,396
定義はこのように与えられています。大文字セータ表記は単に

47
00:04:47,396 --> 00:04:53,733
計算量の増加を表す方法だということです。
セータNの２乗とは、Nの２乗の倍数を短く表記したものです。

48
00:04:53,733 --> 00:05:00,393
この値はNの２乗の上限と下限で抑えられます。
これを用いて実際に

49
00:05:00,393 --> 00:05:05,730
アルゴリズムを分類します。大文字O表記もあり、こちらは実行時間の

50
00:05:05,730 --> 00:05:11,360
最大値を表します。私たちがOのN２乗と言ったら、
実行時間はNが増えたとき、Nの２乗のある定数倍よりは

51
00:05:11,360 --> 00:05:17,569
少ない時間だということです。大文字オメガ表記は、下限値を表すのに使います。
つまり、実行時間はNが増えたとき

52
00:05:17,569 --> 00:05:23,694
Nの２乗の定数倍より大きい時間だということです。
これら３つの表記を用いて

53
00:05:23,918 --> 00:05:30,113
アルゴリズムを分類できます。次に例を示します。

54
00:05:30,113 --> 00:05:36,725
１値、２値、３値の合計の例を挙げるとはっきりわかりやすいでしょう。

55
00:05:36,725 --> 00:05:42,829
我々の目標は問題の難易度をはっきりさせ、
最適なアルゴリズムを開発することです。

56
00:05:42,829 --> 00:05:48,999
１値の和の問題では、配列に00が入っているとします。
この問題の難易度の上限は

57
00:05:48,999 --> 00:05:54,299
ある特定のアルゴリズムです。例えば、総当たりアルゴリズムでは

58
00:05:54,299 --> 00:06:00,049
配列要素をすべて見ますが、これなどがそのアルゴリズムです。

59
00:06:00,049 --> 00:06:06,490
O(N)時間かかります。定数Nの定数倍より小さい値です。

60
00:06:06,490 --> 00:06:12,307
ですので、最適なアルゴリズムの実行時間は
O(N)である必要があります。

61
00:06:12,307 --> 00:06:17,616
なぜなら、特定のアルゴリズムが最適なアルゴリズムの
実行時間の上限を与えているからです。

62
00:06:17,616 --> 00:06:23,431
しかし、この例の場合、下限を求めるのも容易であり、

63
00:06:23,431 --> 00:06:29,052
総当たりより優れたアルゴリズムが
ないことの証明になります。

64
00:06:29,052 --> 00:06:34,536
1値の和問題では、配列の全要素を
検査する必要があります。１つ見落とすと、

65
00:06:34,536 --> 00:06:40,016
それが０であるかもしれません。このことにより
最適なアルゴリズムでは

66
00:06:40,016 --> 00:06:46,270
実行時間は少なくともNの定数倍になり、
実行時間はオメガNとなります。

67
00:06:46,270 --> 00:06:52,287
この例では上限値、下限値が一致します。

68
00:06:52,287 --> 00:06:59,133
ですので、定数倍を使えば、１値の和問題では
総当たりアルゴリズムが最適という証明になります。

69
00:06:59,133 --> 00:07:05,459
実行時間はセータNで、オメガNで、O(N)でもあります。

70
00:07:05,459 --> 00:07:11,576
簡単な問題でしたら、最適なアルゴリズムを
得るのは大丈夫なのですが、より複雑な問題ですと

71
00:07:11,576 --> 00:07:17,027
上限値と下限値のバランスを得るのが
より困難になります。

72
00:07:17,027 --> 00:07:22,617
特に上限と下限値が一致するものを得るのは困難です。
例えば、３値の和問題を見てみましょう。

73
00:07:22,617 --> 00:07:30,211
３値の和問題では、上限値は例えば
総当たりアルゴリズムですが、これが

74
00:07:30,211 --> 00:07:37,375
最適なアルゴリズムの実行時間を保証しますが、O(N)の３乗です。

75
00:07:37,375 --> 00:07:43,691
しかし、私たちはより良いアルゴリズムを見つけていて、
この実行時間はO(N)の２乗のlogNです。これがより良い上限値ですね。

76
00:07:43,691 --> 00:07:49,526
下限値ですが、すべての要素を
検査しなくてはなりません。再度になりますが、

77
00:07:49,526 --> 00:07:56,274
１つ読み飛ばすと、それが３値の和を0にする
構成要素かもしれないからです。

78
00:07:56,274 --> 00:08:02,304
ですので、最適なアルゴリズムの実行時間はO(N)と
いう証明になりますが、3値の和については、

79
00:08:02,304 --> 00:08:08,280
これより大きな下限値を誰も知りません。
ですので、上限値と下限値に差があり、未だに解かれていません。

80
00:08:08,280 --> 00:08:14,237
3値の和問題の最適なアルゴリズムは
存在しているのでしょうか？分かりません。

81
00:08:14,237 --> 00:08:20,592
私たちは、実行時間がO(N)の2乗未満のアルゴリズムが

82
00:08:20,592 --> 00:08:27,130
あるのかどうかさえ分からないのです。
より高い下限値があるのかも分かりません。

83
00:08:27,130 --> 00:08:33,181
これが「アルゴリズムの理論」における
未解決の問題の例であり、3値の和問題を

84
00:08:33,181 --> 00:08:40,448
解く難しさがどの程度か分かっていません。
ともあれ、この考え方は、ここ数十年間で非常に成功しています。

85
00:08:40,448 --> 00:08:45,958
新しい問題を生み出し、あるアルゴリズムを開発し、
ある下限値の証明ができています。

86
00:08:45,958 --> 00:08:51,679
上限下限の間に隔たりがあれば、
上限値を下げる新しいアルゴリズムを探すか、

87
00:08:51,679 --> 00:08:56,527
あるいは下限値を切り上げる方法を見つけようとします。
通常、自明ではない下限値を証明するのはとても困難です。

88
00:08:56,527 --> 00:09:02,164
すべての入力値を見るというような自明な下限値であれば

89
00:09:02,164 --> 00:09:07,435
それほど難しくありません。たとえばですが、

90
00:09:07,435 --> 00:09:13,251
Union-find問題で話している証明はとても難しいですね。

91
00:09:13,251 --> 00:09:20,081
最近の数十年で、問題に対する計算の難しさに
ついて人々は学んできており、

92
00:09:20,081 --> 00:09:26,124
着実に上限値を切り下げられないか試しています。

93
00:09:26,124 --> 00:09:31,979
とても多数の重要な問題について、最悪の場合でも
より良いアルゴリズムが出てきています。

94
00:09:31,979 --> 00:09:37,944
同時に最適なアルゴリズムと上限下限の差の
問題が多く残されています。

95
00:09:37,944 --> 00:09:43,617
たくさんの人々が研究しているとても魅力的な領域です。
ここで、いくつか本コースでの

96
00:09:43,617 --> 00:09:48,770
意味における注意事項があります。１つ目は、最悪の場合について

97
00:09:48,770 --> 00:09:54,409
オーバーに悲観的に見ているかもしれないことです。
データがそこにあり、解かなくてはならない問題があるとします。

98
00:09:54,409 --> 00:09:59,786
そのデータは最悪の場合ではなく、工学や科学の分野で
たくさんあるものかもしれません。

99
00:09:59,786 --> 00:10:05,194
最悪の場合など注目していないものです。
本コースでは最悪の場合とは、

100
00:10:05,194 --> 00:10:10,708
雷に打たれたようなもので、オーバーであって、
対処する想定をしていないものでしょう。

101
00:10:10,708 --> 00:10:16,301
同様に、アルゴリズムについても当てはまります。
入力値の属性を理解して、

102
00:10:16,301 --> 00:10:21,252
それに対して十分なアルゴリズムを
発見することに注目すべきかもしれません。

103
00:10:21,252 --> 00:10:26,645
もう１つは、実際に性能を予測して
アルゴリズムを比較するために、

104
00:10:26,645 --> 00:10:33,210
定数倍以内よりも小さい差の分析をする必要があります。

105
00:10:33,210 --> 00:10:39,719
そこで、アルゴリズムの理論で使われる
大文字セータや大文字O、オメガ表記内の

106
00:10:39,719 --> 00:10:46,161
チルダ記述について話します。実際に、
アルゴリズム理論の研究著書で

107
00:10:46,161 --> 00:10:51,608
多くの人が大文字O記述の結果解釈を間違えています。

108
00:10:51,608 --> 00:10:56,964
本来は問題の困難度について改善された
上限値を与えるべきところを

109
00:10:56,964 --> 00:11:02,179
実行時間の近似モデルとして与えてしまっています。
これは全くの間違いです。

110
00:11:02,179 --> 00:11:07,619
そこで、本コースでは、近似モデルに焦点を当てます。

111
00:11:07,619 --> 00:11:12,738
チルダ記述を確実に使うようにして、
注目しているデータ量と

112
00:11:12,738 --> 00:11:17,766
実行時にはっきりと決まらない任意の定数、

113
00:11:17,766 --> 00:11:22,271
マシンやシステムの属性に依存する定数について
具体的な結果を与えるようにしてみます。

114
00:11:22,271 --> 00:11:27,542
それによって、性能やアルゴリズムの比較が

115
00:11:27,542 --> 00:11:29,013
できるようにします。