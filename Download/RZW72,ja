1
00:00:02,041 --> 00:00:07,088
良いでしょう。私たちは高速な
UnionおよびFindアルゴリズムを見てきました。

2
00:00:07,088 --> 00:00:13,034
どちらも実装は簡単ですが、巨大な
接続問題をサポートできません。

3
00:00:13,034 --> 00:00:18,151
では、どのように改善したら良いでしょうか？
それを次に見ていきます。

4
00:00:18,151 --> 00:00:23,731
非常に効果的な改善案は、重み付けと
呼ばれるものです。このコースのような

5
00:00:23,731 --> 00:00:28,764
アルゴリズムの講義を見ると
出会っていたかもしれませんね。考え方としては、

6
00:00:28,764 --> 00:00:34,735
高速なUnionアルゴリズムを実装する際に
段階を踏んで、高い木を作らないようにすることです。

7
00:00:34,735 --> 00:00:41,873
大きな木と小さな木とを接続させるとき、

8
00:00:41,873 --> 00:00:48,184
試したいことは大きな木を下に
付けないようにすることです。こうすることで、

9
00:00:48,184 --> 00:00:54,376
長く高い木を作らないようにします。これを実装するのには
比較的簡単なやり方があります。

10
00:00:54,376 --> 00:01:00,577
付いているオブジェクトの数をそれぞれの木で追跡しておき、
バランスを維持するようにします。

11
00:01:03,558 --> 00:01:05,049
小さい方の木のルートを大きい方の木のルートに
必ず接続するようにすることで実現します。

12
00:01:06,539 --> 00:01:12,176
これで、私たちは最初の状況、
大きい方の木が下に来る、という状況を

13
00:01:12,176 --> 00:01:18,053
回避できます。重み付け
アルゴリズムでは、常に小さい木が下に来ます。

14
00:01:18,053 --> 00:01:27,470
では、どのように実装するのかを見てみましょう。
まずデモを見ましょう。

15
00:01:27,470 --> 00:01:34,790
最初は通常の開始状態と同じところから始めます。
それぞれが自分自身の木にいます。

16
00:01:35,059 --> 00:01:42,249
2つのアイテムしか接続しない場合は、
従来と同じように動きます。

17
00:01:42,249 --> 00:01:48,725
しかし、ここで要素8を4と3に接続する際には、
8を子にします。

18
00:01:48,725 --> 00:01:56,408
引数順に関係なく、8の方が小さい木だからです。

19
00:01:56,408 --> 00:02:02,368
6と5の接続は問題ないですね。どちらが
下でも問題ありません。

20
00:02:02,368 --> 00:02:09,710
9と4ですが、9の方が小さい木で、
4の方が大きい木ですから、9が下に置く木になります。

21
00:02:09,710 --> 00:02:20,136
2と1、5と0。ここで、5の方が大きい木ですから、

22
00:02:20,136 --> 00:02:33,812
0が下に来ます。7と2ですが、
2の方が大きい木ですので7が下に来ます。

23
00:02:33,812 --> 00:02:46,129
6と1ですが、これらは同じ大きさの木ですね。

24
00:02:46,129 --> 00:02:59,272
そして7と3ですが、3の方が小さい木ですので、
下につきます。このように、重み付けアルゴリズムでは

25
00:02:59,272 --> 00:03:08,686
小さい方の木が必ず下に配置されます。ここで、再び

26
00:03:08,686 --> 00:03:15,571
すべてのオブジェクトを表現する1本の木に巻き取りましたが、
今度は、ある保証があります。

27
00:03:15,571 --> 00:03:21,267
つい先ほどお話ししたとおり、ルートから
遠く離れた要素は存在しない、ということです。

28
00:03:21,267 --> 00:03:27,980
これが、重み付け高速Unionを行った効果を示した例です。

29
00:03:27,980 --> 00:03:35,236
ここでは、同じUnionコマンドを行った際に、
小さい方の木が常に下に置かれるようになっています。

30
00:03:35,236 --> 00:03:42,939
これは100のサイトに88回Union操作を
行ったものです。上の例では

31
00:03:42,939 --> 00:03:49,768
大きな木があり、中に少しの木とノードがあり、
ルートからとても離れていますね。

32
00:03:49,768 --> 00:03:55,908
下の例では、重み付けアルゴリズムの場合で、ノードは
すべてルートから4の距離までしか離れていません。

33
00:03:55,908 --> 00:04:01,207
ルートからの平均距離はずっとずっと小さいのです。

34
00:04:01,207 --> 00:04:06,557
Javaの実装を見て、詳しいところを、
定量的な情報を見てみましょう。

35
00:04:06,557 --> 00:04:12,286
私たちは同じデータ構造を使いますが、
今回は追加の配列が必要です。

36
00:04:12,286 --> 00:04:17,569
これは、各要素について、その要素に
到達するまでのツリー内のオブジェクト数を与えます。

37
00:04:17,569 --> 00:04:22,971
この配列がunion操作を管理します。
findの実装は

38
00:04:22,971 --> 00:04:28,589
高速unionと同じです。ルートが同一か
どうかをチェックするだけです。

39
00:04:28,589 --> 00:04:34,009
union操作については、サイズを
チェックするコードを変更します。

40
00:04:34,009 --> 00:04:40,118
それぞれの場合で、小さい方の木のルートを
大きい方の木のルートに接続します。

41
00:04:40,118 --> 00:04:46,049
idのリンクを変更した後、size配列も変更します。

42
00:04:46,049 --> 00:04:52,241
idを i から j の子に変更したら、
j の木のサイズを i の木のサイズだけ増やします。

43
00:04:52,241 --> 00:04:58,495
逆の場合では、i の木のサイズを
j の木のサイズ分だけ増やす必要があります。

44
00:04:58,495 --> 00:05:04,849
白地になっているところが
高速union全体のコードです。

45
00:05:04,849 --> 00:05:12,424
それほどコードは大きくないですが、
ずっと良いパフォーマンスが得られます。

46
00:05:12,424 --> 00:05:19,194
実際、数学的に実行時間を分析できます。

47
00:05:19,194 --> 00:05:25,225
定義した操作を行う時間は、ノードがどれだけ
木の深い位置にあるかに比例しますが

48
00:05:25,225 --> 00:05:31,445
どのノードも木の深さが高々底が２のlogNに

49
00:05:31,445 --> 00:05:37,989
収まることが保証されていることが分かります。

50
00:05:37,989 --> 00:05:43,974
ここでlgは底が２のlogを常に表します。

51
00:05:43,974 --> 00:05:49,246
ですので、Nが1000なら10ですし、
百万なら20、10億なら30です。

52
00:05:49,246 --> 00:05:55,745
Nに比べれば非常に小さな数です。
ではこの証明を見てみましょう。

53
00:05:55,745 --> 00:06:02,046
このコースでは、時々数学的証明をします。
今回のように重要な場面では。

54
00:06:02,046 --> 00:06:07,981
なぜ、どのノードxについても高さが
高々底が２のlogNになるのでしょうか。

55
00:06:07,981 --> 00:06:13,850
理解する鍵は、任意のノードの深さが
増加するのはどんなときなのか

56
00:06:13,850 --> 00:06:21,347
どんなときに木を深くたどることに
なるのかを正確に見ていくことです。

57
00:06:21,347 --> 00:06:29,697
この図に示すT1という木が他の木に
結合するとき、Xの深さは1増加します。

58
00:06:29,697 --> 00:06:37,835
この図ではT2ですね。このとき、T2の大きさが
T1より大きいか等しいときときだけ

59
00:06:37,835 --> 00:06:45,331
結合が行われると言えます。
ですので、Xの深さが増加するときには

60
00:06:45,331 --> 00:06:52,662
木のサイズは少なくとも2倍になります。ここが鍵です。

61
00:06:52,662 --> 00:06:58,305
Xを含む木のサイズは、最大でもlogN回で
倍になります。なぜなら

62
00:06:58,305 --> 00:07:05,205
1から始めてlogN回だけ2倍していけばNに到達し、
木にはN個のノードしかないことになるからです。

63
00:07:05,205 --> 00:07:11,631
これが任意のノードXの深さは高々底が２の
logNだという大まかな証明の流れです。

64
00:07:11,631 --> 00:07:18,605
この事実が、このアルゴリズムの性能に
深い影響を与えています。

65
00:07:18,605 --> 00:07:24,548
ここで、初期化は常にNに比例する時間がかかりますが、

66
00:07:24,548 --> 00:07:31,010
union、結合、find操作は底が２のlogNに比例します。

67
00:07:31,010 --> 00:07:37,477
これがスケールできるアルゴリズムです。
Nが100万から10億に増えたとしても、

68
00:07:37,477 --> 00:07:43,668
計算コストは20から30に増えるだけです。
これならとても受け入れられるものです。

69
00:07:43,668 --> 00:07:50,089
さて、このアルゴリズムは実装が
とても簡単で実行もすぐ終わりますが、

70
00:07:50,089 --> 00:07:57,004
通常はアルゴリズムのデザインを変えると、
性能を上げることができるということが理解できます。

71
00:07:57,004 --> 00:08:02,075
このアルゴリズムを見直すと、
さらに良くできるだろうと思います。

72
00:08:02,075 --> 00:08:09,072
この場合、もっとずっと簡単に改良できます。
そのアイディアはパス圧縮です。

73
00:08:09,072 --> 00:08:17,066
このアイディアとは、与えられた
ノードを含んだ木のルートを探そうとするとき、

74
00:08:17,066 --> 00:08:24,361
そのノードからルートまでの
すべてのノードを触っています。

75
00:08:24,568 --> 00:08:30,422
その際に、通った各ノードがルートを
指すようにしてしまうのが良いでしょう。

76
00:08:30,422 --> 00:08:37,299
そうしない理由もないですから。
ですので、ノードPのルートを探そうと検索しているとき、

77
00:08:37,299 --> 00:08:43,580
探し終わった後でそのまま戻って、

78
00:08:43,580 --> 00:08:51,046
パス上のノードはすべてルートを指すようにします。
一定量の追加コストはかかるでしょうが、

79
00:08:51,046 --> 00:08:57,088
いったんルートを見つけたら
パスを持ち上げて、木をより平坦にしていきます。

80
00:08:57,088 --> 00:09:03,099
そうしないでおく理由がないでしょう。

81
00:09:03,099 --> 00:09:10,016
驚くことに、木を平坦化するための
コードは1行です。実際、1行のコードで

82
00:09:10,016 --> 00:09:15,058
1つの変数だけで、パス内の他のノードすべてを

83
00:09:15,058 --> 00:09:19,885
2世代前のノードを指すようにできます。
実際には、全体を平坦化するよりは良くないですが、

84
00:09:21,000 --> 00:09:26,077
十分良いものです。

85
00:09:26,077 --> 00:09:32,555
このように、1行足すだけで
木を概ね完全に平坦化できます。

86
00:09:32,828 --> 00:09:41,987
このアルゴリズムを、人々は
重み付けアルゴリズムを発見してから比較的早く見つけ出し

87
00:09:41,987 --> 00:09:49,588
かなり本コースの範囲を外れるほど
解析がイライラするものだと判明していますが、

88
00:09:49,588 --> 00:09:55,749
この例に触れることで、簡単な
アルゴリズムであっても

89
00:09:55,749 --> 00:10:02,203
面白く、複雑な解析が必要なものに
なることを示しました。Hopcroft,Ulman,Tarjanによると、

90
00:10:02,203 --> 00:10:07,792
N個オブジェクトがある場合、M個のunion-find操作をすると

91
00:10:07,792 --> 00:10:16,014
配列を高々c(N+Mlg*N)回しか
触らないことが証明されています。

92
00:10:16,248 --> 00:10:22,067
lg*Nは変わった関数で、logN個の中から
1を取得するのにかかる回数を指します。

93
00:10:22,067 --> 00:10:28,061
これを反復log関数と呼びます。
実世界では、

94
00:10:28,061 --> 00:10:36,126
この値は5より小さいと考えておくのが最善です。
なぜなら、lg*2の65536乗が5だからです。

95
00:10:36,126 --> 00:10:42,528
ですので、重み付け高速Unionで、
パス圧縮を施した方式の実行時間は、

96
00:10:42,784 --> 00:10:49,990
実世界では線形になるでしょう。

97
00:10:49,990 --> 00:10:56,504
そして、もっと興味深いアッカーマン関数と
呼ばれる関数まで改良できるでしょう。

98
00:10:56,504 --> 00:11:03,611
この関数はlg*よりもずっと
遅くしか値が増えていきません。<i>もう１つのポイントは、</i>

99
00:11:03,611 --> 00:11:09,813
このアルゴリズムは線形に近づいてきているので、
N×時間に比例するようになるように見えます。

100
00:11:09,813 --> 00:11:15,925
成長の遅い関数×Nではなくて、です。
線形になる簡単なアルゴリズムがあるでしょうか。

101
00:11:15,925 --> 00:11:22,008
人々は、長い時間それを探していて、

102
00:11:22,008 --> 00:11:27,700
そのようなアルゴリズムは実際には
存在しないことが証明できました。

103
00:11:27,700 --> 00:11:32,502
ですので、私たちが使っているアルゴリズムの
背後にはたくさんの理論があり、

104
00:11:32,502 --> 00:11:38,022
その理論を知ることは重要であり、
実際どのアルゴリズムを選べば良いか、

105
00:11:38,022 --> 00:11:43,480
どこにより良いアルゴリズムを用いようと
努力を傾けるかを決める手助けになります。

106
00:11:43,480 --> 00:11:48,796
FriedmanとSachsによって、
このunion-find問題を解くアルゴリズムに

107
00:11:48,796 --> 00:11:54,181
線形時間で終わるものがないと
証明されたのは驚きです。

108
00:11:54,181 --> 00:12:00,293
しかし、パス圧縮付きの
重み付けアルゴリズムは実用上は

109
00:12:00,293 --> 00:12:05,844
巨大は問題を解くことができる
ようになるには十分です。

110
00:12:05,844 --> 00:12:11,713
では、動的接続問題を解く
アルゴリズムについてのまとめです。

111
00:12:11,713 --> 00:12:17,128
重み付けアルゴリズムとパス圧縮を用いると、
他のアルゴリズムでは

112
00:12:17,128 --> 00:12:23,109
対応ができなかった問題を解くことができます。
たとえば、10億個オブジェクトがあって

113
00:12:23,109 --> 00:12:28,845
10億回操作があった場合、
前に述べたように、30年かかるでしょう。

114
00:12:28,845 --> 00:12:34,212
それを６秒で行うことができます。
このアルゴリズムについて認識する上で最も重要なことは、

115
00:12:34,212 --> 00:12:40,012
アルゴリズムのデザイン如何で
問題を解くことができる、ということです。

116
00:12:40,012 --> 00:12:45,529
高速なコンピュータを持ってきても
あまり役に立ちません。スパコンを数百万台使って良いなら

117
00:12:45,529 --> 00:12:51,165
30年かかるところを6年でできるかもしれません。
あるいは2ヶ月とかかもしれませんね。

118
00:12:51,165 --> 00:13:02,056
しかし、高速なアルゴリズムを用いれば
皆さんのPCでも数秒で解くことができるのです。