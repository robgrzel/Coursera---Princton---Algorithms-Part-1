1
00:00:01,006 --> 00:00:06,058
好，我们已经见识了算法的高效实现

2
00:00:06,058 --> 00:00:12,025
可以求解巨大的并查集问题。我们看一看能如何应用它

3
00:00:12,025 --> 00:00:17,095
并查集算法有大量的应用

4
00:00:17,095 --> 00:00:24,005
在网络中我们讨论的是动态连通性。而在我们的计算基础设施中

5
00:00:24,005 --> 00:00:30,008
还有很多例子。在底层应用中其中一个很重要的是

6
00:00:30,008 --> 00:00:36,018
在图像处理中如何标记图像中的区域

7
00:00:36,018 --> 00:00:41,057
后续的课程中我们会看到Kruskal最小生成树算法，这是一个

8
00:00:41,057 --> 00:00:48,009
使用并查集作为子程序的图处理算法。我们接下来会看一个例子

9
00:00:48,009 --> 00:00:54,077
是物理中用来理解物理现象的一个算法。这个列表里还有很多其他例子

10
00:00:55,000 --> 00:01:00,064
好，我们现在要讲的这个叫渗滤

11
00:01:00,086 --> 00:01:07,046
这是很多物理系统的模型。我会给出抽象模型，然后

12
00:01:07,046 --> 00:01:13,063
简要提一下它是如何应用到物理系统中的。我们考虑一个

13
00:01:13,063 --> 00:01:20,076
n×n的方形网格，小方格叫做位。每个位是开放的概率为p

14
00:01:21,001 --> 00:01:27,076
如图中为白色方格。位是闭合的概率为1-p，如图中为黑色方格

15
00:01:27,076 --> 00:01:34,029
我们定义一个系统是渗滤的

16
00:01:34,029 --> 00:01:40,059
如果顶端和底端被开放的位连通。所以左边的系统中

17
00:01:40,059 --> 00:01:46,089
可以找到一条通过白色方格从上到下的路径

18
00:01:46,089 --> 00:01:53,019
而右边的系统不是渗滤的。不存在通过白色方格

19
00:01:53,019 --> 00:02:00,017
从上到下的路径。这是很多系统的模型

20
00:02:00,017 --> 00:02:05,098
你可以认为它是电力系统，可以认为开放的位是

21
00:02:05,098 --> 00:02:11,091
导体，闭合的位是绝缘体。所以如果存在

22
00:02:11,091 --> 00:02:17,091
从上到下的导体那么系统就是导电的。或者可以认为

23
00:02:17,091 --> 00:02:23,039
水流过某种多孔的物质，开放位就是空的

24
00:02:23,039 --> 00:02:28,055
闭合位有一些材料，是否渗滤就是水能否从上端流到下端

25
00:02:28,055 --> 00:02:34,030
或者可以认为这个系统是社交网络

26
00:02:34,030 --> 00:02:39,869
人们互相有联系，两个人之间可能有

27
00:02:39,869 --> 00:02:46,063
也可能没有联系。系统是否是渗滤的就是是否存在一条路径一群人可以通过社交网络联系另一群人

28
00:02:46,063 --> 00:02:52,076
这只是渗滤模型的几个例子

29
00:02:52,076 --> 00:02:58,089
如果我们讨论一个位以一定的概率是开放的随机模型

30
00:02:58,089 --> 00:03:05,075
我们可以很清楚地看到

31
00:03:06,005 --> 00:03:11,087
如左侧两个图中位是开放的概率比较低的话

32
00:03:11,087 --> 00:03:17,002
系统不是渗滤的。开放的位不够形成

33
00:03:17,002 --> 00:03:22,016
从上到下的连接。如果位开放的概率大

34
00:03:22,016 --> 00:03:26,002
就会有很多开放的位，系统就绝对是渗滤的

35
00:03:26,002 --> 00:03:30,055
从上到下会有很多条通路。但是中间的情况

36
00:03:30,055 --> 00:03:35,067
开放概率中等的条件下，系统是否渗滤就是存疑的了。所以这个模型中的科学问题

37
00:03:35,067 --> 00:03:40,065
或者说数学问题是我们如何知道

38
00:03:41,005 --> 00:03:46,062
系统会不会是渗滤的？这个问题以及很多相似的问题中

39
00:03:46,062 --> 00:03:52,034
存在“相变”。就是说，当概率p很小

40
00:03:52,034 --> 00:03:56,072
系统不渗滤。当概率p很大，系统就是渗滤的。实际上

41
00:03:56,072 --> 00:04:02,003
系统是否渗滤的概率p阈值非常陡峭

42
00:04:02,003 --> 00:04:07,092
而且存在一个值当N非常大时p小于该值时

43
00:04:07,092 --> 00:04:13,089
系统基本肯定不是渗滤的，如果大于该值基本

44
00:04:13,089 --> 00:04:19,045
一定会渗滤。问题就是那个值是多少。这是一个

45
00:04:19,045 --> 00:04:26,051
问题被数学模型精确描述的例子

46
00:04:26,051 --> 00:04:32,092
没有人知道那个数学问题的解

47
00:04:32,092 --> 00:04:37,032
我们有的唯一的解来自计算模型

48
00:04:37,032 --> 00:04:42,082
我们用仿真试图决定那个概率的值

49
00:04:42,082 --> 00:04:47,093
而要实现那些仿真必须使用快速并查集算法

50
00:04:47,093 --> 00:04:53,024
这个例子说明了我们需要快速并查集算法的动力

51
00:04:53,024 --> 00:04:59,053
我们要运行的就是所谓的蒙特卡罗仿真

52
00:04:59,053 --> 00:05:06,063
首先将整个网格初始化为闭合的，全是黑色的，然后随机加上开放的位

53
00:05:06,063 --> 00:05:12,096
每次加上一个开放位后，检查

54
00:05:12,096 --> 00:05:18,095
是否使系统变得渗滤的。持续这个过程直到

55
00:05:18,095 --> 00:05:24,026
系统变得是渗滤的。我们可以证明系统变得渗滤时开放位的比例

56
00:05:24,026 --> 00:05:29,080
是要求的阈值的估计。我们要做的是

57
00:05:29,080 --> 00:05:35,008
将这个实验运行上百万次，这我们可以在计算机上完成

58
00:05:35,008 --> 00:05:40,069
只要我们能够高效地计算当前系统是否渗滤

59
00:05:40,069 --> 00:05:45,064
这就是蒙特卡罗仿真，这个计算问题

60
00:05:45,084 --> 00:05:51,012
为这个尚无人知道如何求解的科学或者数学问题给出的解决办法

61
00:05:51,012 --> 00:05:56,097
那么，我们再稍微看一些使用动态连通性模型的细节

62
00:05:56,097 --> 00:06:03,092
很显然，对应每个位我们要创建一个对象

63
00:06:03,092 --> 00:06:09,093
然后赋予他们一个名字，像这里表示的从0到N^2-1

64
00:06:09,093 --> 00:06:16,091
然后如果位和开放位连在一起，我们就把它们连接在一起

65
00:06:16,091 --> 00:06:23,029
所以左边的渗滤模型对应右边的连接模型

66
00:06:23,029 --> 00:06:28,089
从我们之前做的工作就能看出。现在你可能会说

67
00:06:28,089 --> 00:06:33,081
我们要做的就是检查最下面一行中是否有位

68
00:06:33,081 --> 00:06:39,039
与最上面一行任何一个位连通，并使用并查集来完成。这么做的问题在于

69
00:06:39,039 --> 00:06:44,091
这是一个暴力算法，需要平方时间

70
00:06:44,091 --> 00:06:50,030
显然，它需要调用查找N^2次来检查它们是否连通

71
00:06:50,030 --> 00:06:55,048
对于最上一行每个位，都要检查最下一行每个位，这太慢了

72
00:06:55,048 --> 00:07:01,024
我们有个好办法，在顶端和底端各加一个虚拟位

73
00:07:01,024 --> 00:07:06,087
那么想知道系统是否渗滤时，只需要检查

74
00:07:06,087 --> 00:07:14,025
虚拟顶端位和虚拟底端位是否连通

75
00:07:14,025 --> 00:07:20,097
那么我们要怎么对开放新位建模呢？开放一个位我们只需要将它和它周围的开放位连通

76
00:07:20,097 --> 00:07:28,034
所以需要调用几次合并操作，不过这很容易实现

77
00:07:28,034 --> 00:07:34,092
有了这个简单的关系之后我们就完全可以用我们之前开发的代码

78
00:07:34,092 --> 00:07:42,000
对这个连通性问题进行仿真

79
00:07:42,000 --> 00:07:48,082
我们在足够大的N上运行足够多次的仿真获得结果

80
00:07:49,007 --> 00:07:55,409
渗滤阈值大约是0.592746。使用快速的算法

81
00:07:55,409 --> 00:08:01,693
关于这个科学问题我们获得了一个精确的答案。如果我们选用的并查集算法太慢

82
00:08:01,693 --> 00:08:06,822
我们无法在很大的问题上运行它，我们也无法获得

83
00:08:06,822 --> 00:08:11,979
非常精确的结果。总结一下，我们选取了一个重要的问题——动态连通性问题

84
00:08:11,979 --> 00:08:17,359
我们通过对问题建模试图精确理解

85
00:08:17,359 --> 00:08:22,109
我们需要什么样的数据结构和算法来解决它。然后我们先

86
00:08:22,109 --> 00:08:26,676
提出了几个可以解决问题的简单算法，并很快发现它们

87
00:08:26,676 --> 00:08:31,953
不足以处理巨大问题。但之后我们发现了如何改进它们，得到了

88
00:08:31,953 --> 00:08:37,300
高效的算法。最后我们遇到了必须使用高效算法才能解决的

89
00:08:37,300 --> 00:08:42,768
应用问题。整个流程涉及科学方法

90
00:08:42,768 --> 00:08:47,954
算法设计中我们试图构建数学模型帮助我们

91
00:08:47,954 --> 00:08:52,343
理解我们要设计的算法的性质，之后

92
00:08:52,343 --> 00:08:56,675
我们通过实验，在模型上进行测试，使得我们能够

93
00:08:56,675 --> 00:09:02,363
不断改进算法，迭代开发更好的算法和更细致的模型，直到

94
00:09:02,363 --> 00:09:07,061
得到用来解决我们感兴趣的实际问题所需要的算法

95
00:09:07,061 --> 00:09:12,165
这将会是我们这门课中将要用来学习算法的

96
00:09:12,165 --> 00:09:14,036
整体框架