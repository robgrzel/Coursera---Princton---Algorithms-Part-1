1
00:00:01,024 --> 00:00:06,048
我们要讲的第一个基本排序方法很简单

2
00:00:06,048 --> 00:00:11,083
叫做选择排序。选择排序的思想如下：从未排序

3
00:00:11,083 --> 00:00:17,101
数组开始，我们用这些扑克牌举例，在第 i 次迭代中

4
00:00:17,101 --> 00:00:22,867
我们在数组剩下的项中找到最小的，这个情况下

5
00:00:22,867 --> 00:00:28,693
2是所有项中最小的，然后，我们将它和数组中的第一项交换

6
00:00:28,693 --> 00:00:34,199
这一步就完成了。选择排序就是基于这样的思想迭代操作

7
00:00:34,199 --> 00:00:39,376
好，基本的选择排序方法是在第 i 次迭代中

8
00:00:39,376 --> 00:00:44,626
在数组中第i项右边剩下的或者索引比i更大的项中找到最小的

9
00:00:44,626 --> 00:00:50,252
一项，然后和第 i 项交换。开始i是0，从最左端开始

10
00:00:50,252 --> 00:00:55,711
扫描所有右边剩下的项

11
00:00:55,711 --> 00:01:02,516
最小的是2，右起第3项，那么我们交换这两项

12
00:01:02,516 --> 00:01:08,889
这是第一步。i左边这部分数组就是排过序的

13
00:01:08,889 --> 00:01:15,193
我们继续。现在最小的是3，与第i项交换

14
00:01:15,193 --> 00:01:21,511
i加1。现在2、3已经就位了，继续如此操作

15
00:01:21,511 --> 00:01:27,958
找最小的，4，和第 i 项交换，i 加1。找最小的

16
00:01:27,958 --> 00:01:34,712
5，和第 i 项交换，i 加1。找最小的，和第 i 项交换，i 加1

17
00:01:34,712 --> 00:01:40,689
为了寻找最小的项都要扫描全部剩下的项

18
00:01:40,689 --> 00:01:45,788
但一旦找到之后，只需要交换两张牌

19
00:01:45,979 --> 00:01:52,898
这是两条是选择排序的关键性质。现在8是最小的，交换

20
00:01:52,898 --> 00:01:59,486
这时，我们知道已经是有序的了，但是程序不知道，所以必须

21
00:01:59,486 --> 00:02:06,816
检查并且做决定。i和min相同，和自己交换，最后一次迭代

22
00:02:06,816 --> 00:02:13,226
也是如此。这个过程结束后，我们知道整个数组

23
00:02:13,226 --> 00:02:19,445
已经是最终状态，是有序的了。理解

24
00:02:19,445 --> 00:02:24,768
算法工作方式的一个办法是考虑不变性

25
00:02:24,768 --> 00:02:30,924
对于选择排序，我们有个指针，变量i，从左到右扫描

26
00:02:30,924 --> 00:02:36,345
在这个图中用红色箭头表示

27
00:02:36,345 --> 00:02:42,235
不变性就是箭头左边的项不会再变了

28
00:02:42,235 --> 00:02:48,743
它们已经是升序了。箭头右边的项都比箭头左边的项大

29
00:02:48,743 --> 00:02:54,859
这是我们确立的机制。算法

30
00:02:54,859 --> 00:03:00,837
通过找到右边最小的项，并和箭头所指的右边下一项交换来

31
00:03:00,837 --> 00:03:06,827
维持不变性。实现不变性的代码如下：向右移动指针

32
00:03:06,827 --> 00:03:12,739
i 加1。现在不变性有可能被破坏了，我们要修复它

33
00:03:12,739 --> 00:03:18,425
有可能因为在指针右边有一个元素比

34
00:03:18,425 --> 00:03:23,812
指针所指的元素小导致不变性被破坏了

35
00:03:23,812 --> 00:03:29,143
我们要做的是找到最小项的索引，然后交换

36
00:03:29,143 --> 00:03:34,170
一旦我们完成了交换，我们又一次保留了不变性

37
00:03:34,170 --> 00:03:38,846
这时指针左边元素不会再变了

38
00:03:38,846 --> 00:03:44,536
右边也没有更小的元素

39
00:03:44,768 --> 00:03:52,713
这也就给出了实现选择排序的代码。我们将

40
00:03:52,713 --> 00:03:59,009
数组的长度记为N，for循环遍历数组中每个元素

41
00:03:59,009 --> 00:04:05,112
变量min用来存储指针i

42
00:04:05,112 --> 00:04:10,045
右边最小元素的索引

43
00:04:10,045 --> 00:04:15,626
内层的j的for循环，如果找到更小的值，则重设min

44
00:04:15,626 --> 00:04:21,509
一旦检查完i右侧所有的元素，将最小的和第i项交换

45
00:04:21,509 --> 00:04:27,083
这就是选择排序的完整实现。为选择排序的开销

46
00:04:27,083 --> 00:04:34,073
建立数学模型非常容易

47
00:04:34,073 --> 00:04:42,054
这个命题描述了选择排序使用大约N^2 / 2个比较以及

48
00:04:42,056 --> 00:04:48,011
整整N次交换。只要看看这个选择排序

49
00:04:48,011 --> 00:04:55,525
运行的跟踪记录，这就是这个命题的图形证明

50
00:04:55,525 --> 00:05:00,493
图中，黑色的项是每次为了寻找最小项检查的项

51
00:05:00,493 --> 00:05:06,621
最小项是红色的。灰色的项是未检查的项

52
00:05:06,621 --> 00:05:12,492
已经在最终位置了。你可以看到这基本就是

53
00:05:12,492 --> 00:05:19,709
N×N的正方形，其中大约一半的元素是黑色的，即大约

54
00:05:19,709 --> 00:05:27,029
N^2 / 2，你也能看出准确的表达式(N - 1) + (N - 2)等等就是

55
00:05:27,245 --> 00:05:33,329
总共比较的次数。然后在变量i的这N个取值各有

56
00:05:33,329 --> 00:05:40,218
一次交换，所以这是交换次数的开销

57
00:05:40,218 --> 00:05:48,070
关于选择排序的这个命题说明了很有意思的一点

58
00:05:48,070 --> 00:05:54,257
就是它和输入的序列本身的顺序无关。选择排序需要

59
00:05:54,257 --> 00:06:00,458
平方时间因为它总要查看所有的项寻找最小项

60
00:06:00,458 --> 00:06:06,752
另一个性质就是要完成排序这已经是移动开销最小的了

61
00:06:06,752 --> 00:06:12,842
选择排序只需要线性次数的交换。每一项都是

62
00:06:12,842 --> 00:06:19,459
仅仅一次交换就放在了最终位置。我们看看

63
00:06:19,459 --> 00:06:25,693
选择排序运行的动画。你可以看到指针由左至右扫描

64
00:06:25,693 --> 00:06:31,919
每次扫描找到右边最小的项，交换到它最终的位置上

65
00:06:31,919 --> 00:06:39,637
如果数组一部分已经排好序了，这对选择排序不影响

66
00:06:39,637 --> 00:06:45,854
依然要一遍一遍扫描，即使是完全有序的，依然要

67
00:06:45,854 --> 00:06:51,359
扫描右边的项来找最小的元素。这就是选择排序

68
00:06:51,359 --> 00:06:59,072
我们第一个基本排序方法