1
00:00:01,078 --> 00:00:08,004
Теперь посмотри на нашу первую реализацию алгоритма решения проблемы 

2
00:00:08,004 --> 00:00:14,012
динамический связности, называемой Quick-Find. Это так называемый  жадный алгоритм для

3
00:00:14,012 --> 00:00:20,013
решения такой задачи. Структура данных которую мы будем использовать для

4
00:00:20,013 --> 00:00:25,082
алгоритма это просто целочисленный массив проиндексированный объектами.

5
00:00:25,082 --> 00:00:31,099
Будем считать что два объекта P и Q соединены тогда и только тогда если

6
00:00:31,099 --> 00:00:39,005
их элементы в этом массива одинаковы. Так в этом примере с десятью

7
00:00:39,005 --> 00:00:46,099
объектами массив который описывает ситуацию после семи соединений

8
00:00:46,099 --> 00:00:53,349
представлен в центре слайда. И так точки 0, 5

9
00:00:53,349 --> 00:00:59,578
и 6 принадлежат одной компоненте, потому что имеют одинаковое значение

10
00:00:59,578 --> 00:01:05,171
в массиве, 0. У 1, 2 и 7 значение в массиве 1. А у 3, 4, 8,

11
00:01:05,171 --> 00:01:10,664
и 9 - значение 8. Такое представление показывает как они

12
00:01:10,664 --> 00:01:16,636
соединены. Ясно что это обеспечит быструю реализацию операции

13
00:01:16,636 --> 00:01:22,439
поиска. Мы просто проверяем элементы массива, равны они или нет. Проверяем имеют ли 

14
00:01:22,439 --> 00:01:27,904
P и Q один ID. Так 6 и 1 имеют разные ID. У 1 ID 1, а у 6 

15
00:01:27,904 --> 00:01:34,171
- 0.  Они не в одной связной компоненте. Объединение более сложно.

16
00:01:34,171 --> 00:01:40,981
Для того чтоб объединить компоненты содержащие два данных объекта, мы должны изменить

17
00:01:40,981 --> 00:01:47,755
элементы массива, чьи ID равны одному из них на другой. И произвольно мы

18
00:01:47,755 --> 00:01:53,634
выбираем изменить те что равны P на те что равны Q.

19
00:01:53,634 --> 00:01:58,898
Так если мы объединяем 6 и 1, мы должны изменить элементы 0, 5. 

20
00:01:58,898 --> 00:02:04,741
 и 6. Все из той же связной компоненты что и 6. От 0 до 1. И

21
00:02:04,741 --> 00:02:10,917
это, как мы увидим,  проблема когда когда имеем дело с большим количеством

22
00:02:10,917 --> 00:02:16,927
объектов, потому что есть большое значений который могут меняться. Но это легко 

23
00:02:16,927 --> 00:02:23,263
реализуемо,  и это будет нашей стартовой точкой. Итак мы начнем с демонстрации

24
00:02:23,263 --> 00:02:31,189
как это работает. Изначально мы задаем массив ID, где каждый элемент равен 

25
00:02:31,189 --> 00:02:37,932
его индексу. И все что можно сказать это то, что все объекты независимы. Они 

26
00:02:37,932 --> 00:02:43,918
принадлежат собственной связной компоненте. Теперь когда мы делаем операцию объединения, скажем,

27
00:02:43,918 --> 00:02:49,694
 4 должно быть объединено с 3. Тогда мы должны изменить все элементы

28
00:02:49,694 --> 00:02:56,190
 чью ID равны ID первого на второго. Так в этом случае содинения

29
00:02:56,190 --> 00:03:02,061
3 и 4 нам нужно изменить 4 на 3. И 

30
00:03:02,061 --> 00:03:10,259
мы сделаем еще несколько раз, чтобы вы поняли как это работает. Теперь 3 и

31
00:03:10,259 --> 00:03:13,657
8 должны быть соединены, т.е . сейчас 3 и 4 должны быть соединены с

32
00:03:13,657 --> 00:03:19,950
8. И оба элемента должны измениться на 8. Ясно? А как теперь с

33
00:03:19,950 --> 00:03:26,026
6 и 5. Мы снова меняем первую на вторую. Так для

34
00:03:26,026 --> 00:03:32,332
соединения 6 и 5 мы меняем, 6 на 5. Что насчет 9 и 4? Теперь

35
00:03:32,332 --> 00:03:39,789
мы должны соединить 9 и 4, мы должны изменить элемент 9 на тот 

36
00:03:39,789 --> 00:03:45,325
же что у 4. И мы получаем 3, 4, 8 и 9. Все имеют элементом

37
00:03:45,325 --> 00:03:52,365
8. Они все в одной связной области. 2 и 1 значит что мы

38
00:03:52,365 --> 00:04:00,013
соединяем 2 и 1 изменяя 2 на 1. 8 и 9 уже соединены. Они

39
00:04:00,013 --> 00:04:06,660
имеют одинаковые элементы в массиве.  Так запрос connected возвращает true

40
00:04:06,660 --> 00:04:13,096
что они уже соединены. 5 и 0 имеют разные компоненты. Они 

41
00:04:13,096 --> 00:04:21,780
несоединены, и мы должны вернуть false в этом случае, не соединены. И затем если мы

42
00:04:21,780 --> 00:04:31,617
хотим объединить 5 и 0. Тогда мы как обычно соединим, элемент

43
00:04:31,617 --> 00:04:39,855
соответствующий 5 и 6 установим на 0. 7 и 2, объединение 7 и 2.

44
00:04:39,865 --> 00:04:49,623
Делается легко. Объединение 6 и 1, здесь 3 элемента что должны быть 

45
00:04:49,623 --> 00:04:57,899
изменены. Все эти 0 должны замениться на 1. Это была короткая демонстрация 

46
00:04:57,899 --> 00:05:04,126
Quick-find. Теперь мы посмотрим на код реализующий все что выше. 

47
00:05:04,126 --> 00:05:10,628
Имея предыдущую демонстрацию переход к программированию этого алгоритма 

48
00:05:10,628 --> 00:05:16,518
достаточно простой. Хотя это интересное упражнение на программирование которое

49
00:05:16,518 --> 00:05:23,312
многие из нас могут с первой попытки сделать не верно. Итак 

50
00:05:23,312 --> 00:05:29,125
начнем с конструктора, у нас есть private  целочисленный массив. Это наш массив ID. Эту структуру данных

51
00:05:29,125 --> 00:05:33,953
будем использовать в нашей реализации. Конструктор должен 

52
00:05:33,953 --> 00:05:40,637
создать массив и затем задать значение соответственно индексу i к i 

53
00:05:40,637 --> 00:05:47,200
Это просто. Операция поиска или проверки связности. Тоже довольно

54
00:05:47,200 --> 00:05:53,024
легкая. Это Quick-find алгоритм. Она просто принимает два

55
00:05:53,024 --> 00:05:58,552
 аргумента P и Q и проверяет равны ли их ID и возвращает

56
00:05:58,552 --> 00:06:04,077
значение. Если равно возвращает true, если не равны - false. 

57
00:06:04,077 --> 00:06:09,942
Более сложная реализация у операции объединения. В этом случае

58
00:06:09,942 --> 00:06:15,803
мы сперва находим ID соответсвующий первому аргументу, затем ID соответсвующий

59
00:06:15,803 --> 00:06:21,018
второму аргументу. А затем проходим весть массив в поиске

60
00:06:21,018 --> 00:06:27,068
элементов чьи ID равны ID первого аргумента и приравниваем 

61
00:06:27,068 --> 00:06:32,565
их к ID второго аргумента. Это довольно простая реализация. И

62
00:06:32,565 --> 00:06:38,156
я упоминал что многие поняли бы это неправильно. Ошибка которую здесь можно сделать это 

63
00:06:38,156 --> 00:06:43,660
использовать здесь id[p] место того чтобы запомнить это значение. Мы можете подумать о

64
00:06:43,660 --> 00:06:48,672
причине этого. Это коварная ошибка. Так это 

65
00:06:48,672 --> 00:06:54,900
реализация QuickFind и теперь необходимо выяснить насколько эффективным 

66
00:06:54,900 --> 00:07:01,152
будет этот алгоритм. И мы обсудим как 

67
00:07:01,152 --> 00:07:07,088
сделать это, но для этого случая важным будет оценить число 

68
00:07:07,088 --> 00:07:12,901
доступов к массиву в программе. Как вы видели, когда мы делали реализацию, обе 

69
00:07:12,901 --> 00:07:19,019
операции инициализации и объединения включали цикл-for по всем элементам

70
00:07:19,019 --> 00:07:25,469
массива

71
00:07:25,469 --> 00:07:32,155
 Операция поиска быстрее, за константное время она проверяет

72
00:07:32,155 --> 00:07:37,829
 элементы массива. И проблема в том что операция объединения слишком 

73
00:07:37,829 --> 00:07:45,708
затратная. В частности если произвести N операций объединения на N объектах что

74
00:07:45,708 --> 00:07:52,515
бывает необходимо. Независимо соединены они или нет, это займет квадратичное время.

75
00:07:52,515 --> 00:07:58,458
И одна из идей с которой мы встретимся по всему курсу снова и снова

76
00:07:58,458 --> 00:08:04,531
это то что квадратичное время слишком медленно.  И мы не можем позволить использовать алгоритмы с

77
00:08:04,531 --> 00:08:10,796
квадратичным временем на больших задач. Причина в том что они не масштабируются. При ускорении,

78
00:08:10,796 --> 00:08:16,305
 улучшении компьютеров, квадратичные алгоритмы фактически замедляются. Теперь

79
00:08:16,305 --> 00:08:22,464
приблизительно обсудим что я имею ввиду. В настоящее время, грубо говоря

80
00:08:22,464 --> 00:08:29,206
есть компьютеры которые могут делать по миллиарду операций в секунду 

81
00:08:29,206 --> 00:08:34,815
и по миллиарду единиц памяти. Это значит что вы могли бы

82
00:08:34,815 --> 00:08:40,916
считать всю память за секунду. Это своего рода удивительный

83
00:08:40,916 --> 00:08:46,907
факт приблизительно уже актуален 50-60 лет. Компьютеры становятся

84
00:08:46,907 --> 00:08:52,735
больше и быстрее, так чтобы доступ ко все памяти занимал 

85
00:08:52,735 --> 00:08:57,403
несколько секунд. Это было верно когда компьютеры имели тысячи единиц

86
00:08:57,403 --> 00:09:04,657
 памяти, это верно и сейчас когда с миллиардом и более. 

87
00:09:04,657 --> 00:09:11,873
 Это значит что с большим объемом памяти мы можем

88
00:09:11,873 --> 00:09:17,712
решить большие задачи. Так мы можем иметь миллиард объектов и хотим сделать

89
00:09:17,712 --> 00:09:23,608
миллиард операций объединения с ними. Но такая задача с алгоритмом

90
00:09:23,608 --> 00:09:29,770
 Quick-Find  может занять 10^18 операций, или доступов  

91
00:09:29,770 --> 00:09:35,098
к памяти/массиву. И если посчитать, выйдет что это займет примерно 30 лет

92
00:09:35,098 --> 00:09:42,033
вычислений на компьютере. Очевидно что не практично решать такую задачу на современом

93
00:09:42,033 --> 00:09:48,057
компьютере. И причина в том что квадратичные алгоритмы не 

94
00:09:48,057 --> 00:09:54,097
масштабируются вместе с технологиями. С компьютером который в 10 раз быстрее

95
00:09:54,097 --> 00:10:00,033
вы могли бы решить задачу в 10 раз больше. Но с квадратичным

96
00:10:00,033 --> 00:10:06,028
алгоритмом, это будет в 10 раз медленнее. Такого рода

97
00:10:06,028 --> 00:10:11,048
ситуации мы будем стараться избегать, разрабатывая более эффективные алгоритмы

98
00:10:11,048 --> 00:10:13,020
решающие задачи подобные этой.