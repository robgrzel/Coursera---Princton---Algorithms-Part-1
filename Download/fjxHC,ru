1
00:00:00,000 --> 00:00:04,085
Добро пожаловать на курс алгоритмов. Сегодня мы поговорим о системе непересекающихся множеств

2
00:00:04,085 --> 00:00:09,098
— наборе алгоритмов для решения так называемой проблемы динамический связности.

3
00:00:09,098 --> 00:00:14,091
Мы рассмотрим два классических алгоритма: Quick Find и Quick Union,

4
00:00:14,091 --> 00:00:20,078
и их приложения и улучшения.

5
00:00:20,078 --> 00:00:27,039
Цель сегодняшней лекции в том, чтобы пройти шаги, которые Вы будете повторять снова и снова

6
00:00:27,039 --> 00:00:32,039
при разработке полезного алгоритма. Первый шаг — моделирование задачи. Попытаться

7
00:00:32,039 --> 00:00:37,031
понять, в общих чертах, что является основными элементами решаемой задачи.

8
00:00:37,031 --> 00:00:41,681
Далее, мы находим какие-нибудь алгоритмы, решающие задачу. В большинстве случаев

9
00:00:41,681 --> 00:00:46,486
наш первый алгоритм будет достаточно быстрым и, может быть, будет помещаться в память,

10
00:00:46,486 --> 00:00:52,024
так что мы будем использовать его. Но во многих других случаях наш алгоритм, возможно,

11
00:00:52,024 --> 00:00:56,074
не будет столь быстр или же у нас будет меньше доступной памяти. Таким образом, наша задача

12
00:00:56,074 --> 00:01:01,037
выяснить, почему это так, и постараться решить проблему, найдя

13
00:01:01,037 --> 00:01:06,051
новый алгоритм и продолжать, пока требуемый результат не будет достигнут. Это — научный подход

14
00:01:06,051 --> 00:01:11,099
к разработке и анализу алгоритмов, где мы строим математические модели, описывающие

15
00:01:11,099 --> 00:01:17,061
происходящее, а затем проводим эксперимент для проверки и улучшения

16
00:01:17,061 --> 00:01:22,089
наших моделей. Итак, для начала мы поговорим о задаче динамической связности,

17
00:01:22,089 --> 00:01:29,021
модели задачи для систем непересекающихся множеств. Идея состоит в следующем:

18
00:01:29,021 --> 00:01:33,090
Пусть у нас есть множество из N объектов. Неважно, каких. Мы будем использовать

19
00:01:33,090 --> 00:01:39,002
числа от 0 до N для моделирования наших объектов. Также

20
00:01:39,002 --> 00:01:43,082
у нас будет понятие связи между двумя объектами и команда,

21
00:01:43,082 --> 00:01:48,057
соединяющая два объекта. По двум объектам она устанавливает

22
00:01:48,057 --> 00:01:53,093
связь между ними. Основная часть задачи

23
00:01:53,093 --> 00:01:59,097
ответить на вопрос, есть ли путь, соединяющий два объекта. Например,

24
00:01:59,097 --> 00:02:05,021
в этом наборе из 10 объектов, уже рассмотренном нами, набор команд union,

25
00:02:05,021 --> 00:02:10,278
соединяющих 4 и 3, 3 и 8, 6 и 5, 9 и 4

26
00:02:10,278 --> 00:02:16,526
2 и 1. И теперь у нас есть запрос связности, спрашивающий,

27
00:02:16,526 --> 00:02:22,713
соединены ли 0 и 7? В данном случае связи нет, так что ответ — нет. Но если мы

28
00:02:22,713 --> 00:02:28,281
спросим, соединены ли 8 и 9, ответом будет да, несмотря на то, что нет прямого

29
00:02:28,281 --> 00:02:33,629
соединения между ними. Есть путь 8 → 3 → 4 → 9

30
00:02:33,629 --> 00:02:39,783
Наша задача — поддерживать эти две команды для данного набора объектов.

31
00:02:39,783 --> 00:02:45,444
Допустим, мы объединили 5 и 0.

32
00:02:45,444 --> 00:02:51,026
Теперь у нас есть связь между 5 и 0. union(7, 2) образует

33
00:02:51,026 --> 00:02:56,744
связь между 7 и 2. Объединим ещё 6 и 1. Теперь, если мы зададимся вопросом,

34
00:02:56,744 --> 00:03:02,836
соединены ли 0 и 7… Объединим ещё 1 и 0, хотя это избыточное соединение.

35
00:03:02,836 --> 00:03:08,528
Теперь, если мы зададимся вопросом, соединены ли 0 и 7, ответом будет

36
00:03:08,528 --> 00:03:13,858
да. В этом и состоит наша задача — имея перемешанные команды union и connected,

37
00:03:13,858 --> 00:03:18,991
уметь поддерживать их для большого количества

38
00:03:18,991 --> 00:03:23,833
объектов. Вот пример побольше. Как видно, для него нужен эффективный алгоритм.

39
00:03:23,833 --> 00:03:28,128
Во-первых, конечно же, понадобится компьютер.

40
00:03:28,128 --> 00:03:33,085
Человеку понадобилось бы существенное количество времени, чтобы определить

41
00:03:33,085 --> 00:03:38,205
есть ли здесь связь. В данном случае — есть.

42
00:03:38,205 --> 00:03:43,805
Алгоритмы, что мы рассмотрим сегодня, не смогут выдать нам самого пути, соединяющего два объекта,

43
00:03:43,805 --> 00:03:48,847
они лишь смогут сказать, есть ли путь.

44
00:03:48,847 --> 00:03:53,721
В части второй этого курса мы рассмотрим алгоритмы, находящие пути.

45
00:03:53,721 --> 00:03:59,220
Они не столь эффективны как система непересекающихся множеств, так как им приходится выполнять больше операций.