1
00:00:02,079 --> 00:00:07,071
Наблюдение того, что происходит, как мы делали в предыдущем разделе, дает нам способ

2
00:00:07,071 --> 00:00:12,075
предсказать производительность, но это на самом деле не помагает нам понять что алгоритм

3
00:00:12,075 --> 00:00:17,056
делает. И далее мы рассмотрим математическую модель. Таким способом получим лучшее

4
00:00:17,056 --> 00:00:24,080
представление  о том что на самом деле происходит. Эта идея была разработана и

5
00:00:24,080 --> 00:00:33,047
популяризирована Доном Кнутом в конце 60х. В то время, компьютерные системы

6
00:00:33,047 --> 00:00:40,068
впервые стали по-настоящему  сложными. И ученные были

7
00:00:40,068 --> 00:00:46,015
обеспокоены тем, что моги ли мы понять что

8
00:00:46,015 --> 00:00:52,043
происходит. И Кнут был очень прямолинеен говоря, что кое-что мы можем 

9
00:00:52,043 --> 00:00:56,884
сделать. Мы можем посчитать полное время работы,

10
00:00:57,087 --> 00:01:02,059
определив все базовые операции, вычислив затраты, вычислив

11
00:01:02,059 --> 00:01:07,043
частоту  выполнения и просуммировав затраты на частоту для всех

12
00:01:07,043 --> 00:01:11,083
операций. Вы должны проанализировать программу чтобы определить набор

13
00:01:11,083 --> 00:01:17,004
операций и затраты зависящие от компьютера,

14
00:01:17,004 --> 00:01:22,038
о чем мы говорили ранее. 

15
00:01:22,038 --> 00:01:27,369
Кнут написал серию книг, которые дают очень 

16
00:01:27,369 --> 00:01:34,678
детальный и точный анализ для определенной компьютерной модели для

17
00:01:34,678 --> 00:01:39,997
широкого круга алгоритмов. Благодаря Кнуту, мы знаем что в принципе мы может получить точную

18
00:01:39,997 --> 00:01:46,700
математическую модель для производительности алгоритмов или программ.

19
00:01:46,700 --> 00:01:53,156
Так как этот процесс выглядит. Вы можете, если хотите

20
00:01:53,156 --> 00:01:59,044
запустить эксперимент. В прежние времена, мы бы посмотрели в рукоподство к компьютеру

21
00:01:59,044 --> 00:02:04,621
и каждый компьютер имел такое руководство, в котором  говорилось точно сколько занимает каждая 

22
00:02:04,621 --> 00:02:09,589
инструкция. Но сегодня, это стало сложнее. И мы запускаем миллиард

23
00:02:09,589 --> 00:02:15,079
экспериментов со сложением и находим, что на нашем компьютере 

24
00:02:15,079 --> 00:02:20,432
это примерно занимает 2.1 наносекунду. Или вы можете делать более сложные функции

25
00:02:20,432 --> 00:02:25,126
как например минус или арктангенс, хотя это уже ближе к 

26
00:02:25,126 --> 00:02:30,644
анализу алгоритмов. Итак, существуют способы определить затраты

27
00:02:30,644 --> 00:02:38,182
базовых операций. В большинстве случаев мы просто

28
00:02:38,182 --> 00:02:44,137
условимся считать их некоторыми константами, и вы можете найти что это за константы.

29
00:02:44,137 --> 00:02:49,477
Когда вы работаете с набором объектов время

30
00:02:49,477 --> 00:02:54,845
будет пропорционально N, как происходит

31
00:02:54,845 --> 00:03:00,591
при аллоцировании массива размера N, оно занимает время пропорциональное N, т.к. в Java

32
00:03:00,591 --> 00:03:06,061
по умолчанию все элементы инициализируются нулем. В других

33
00:03:06,061 --> 00:03:11,951
системах это зависит от системной реализации,  еще важно упомянуть  

34
00:03:11,951 --> 00:03:17,503
конкатенацию строк. Если вы объединяете две строки, то время выполнения

35
00:03:17,503 --> 00:03:23,832
будет пропорционально длине строки. Многие новички в Java, делают

36
00:03:23,832 --> 00:03:30,713
ошибку полагая, что это константное время. Это

37
00:03:30,713 --> 00:03:39,428
затраты каждой операций. Более интересно будет частота выполнения

38
00:03:39,428 --> 00:03:46,229
 операций. Вот простой вариант задачи 

39
00:03:46,229 --> 00:03:50,237
суммы трех. Это задача суммы одного. Как много чисел 

40
00:03:50,237 --> 00:03:54,333
равны нулю. Это задача суммы одного. Здесь будет

41
00:03:54,333 --> 00:03:59,111
только один цикл for, и проходя по всем числам мы проверяем на равенство нулю и увелчиваем

42
00:03:59,111 --> 00:04:05,417
счетчик. Анализируя этот код вы можете видеть что i и count должны быть объявлены

43
00:04:05,417 --> 00:04:11,511
и затем приравнены к нулю. Здесь есть сравнение i и N,

44
00:04:11,511 --> 00:04:17,484
 их N + 1.  Сравнений A[i] и нуля - N. 

45
00:04:17,484 --> 00:04:23,985
N доступов к массиву. И еще количество инекреметаций

46
00:04:23,985 --> 00:04:30,251
I увеличивалось N раз, а count может увеличен как ни разу так и 

47
00:04:30,251 --> 00:04:37,432
N раз. Это зависит от входных данных

48
00:04:37,432 --> 00:04:43,369
Нам может потребоваться модель для описания всего этого.

49
00:04:43,369 --> 00:04:48,289
 Теперь рассмотрим следующую

50
00:04:48,289 --> 00:04:53,678
более сложную задачу, и найдем частоты выполнения инструкций в

51
00:04:53,678 --> 00:04:59,039
программе для задачи о сумму двух - как много целых чисел в сумму дают ноль.

52
00:04:59,324 --> 00:05:06,207
В этом случае, нужно будет сделать не много больше расчетов, когда

53
00:05:06,465 --> 00:05:14,510
i проходит от 0 до N, а j - от i+1 до N число сравнений

54
00:05:14,510 --> 00:05:21,812
и доступов к массиву это два на каждую проверку if

55
00:05:21,812 --> 00:05:28,044
что производится для A[i]  и A[j]. Сперва выполнится N-1 раз

56
00:05:28,044 --> 00:05:34,394
заме N-2 и т.д. Это будет сумма целых чисесл от

57
00:05:34,637 --> 00:05:40,395
0 до N-1 что есть 0,5(N)(N-1), а 

58
00:05:40,395 --> 00:05:47,383
т.к. доступов к массиву производится по два то это будет N(N-1).

59
00:05:47,383 --> 00:05:54,516
Мы можем продолжать и производить такие точные вычисления. Но это уже

60
00:05:54,516 --> 00:06:01,465
становится утомительно.  И еще Тюринг

61
00:06:01,465 --> 00:06:06,921
знал что нам нужна мера количества работы вовлеченной в

62
00:06:06,921 --> 00:06:12,909
процесс. Он осознавал, что необязательно углубляться во

63
00:06:12,909 --> 00:06:18,975
все детали.  Все равно полезно иметь грубую оценку. Можно было бы подсчитать

64
00:06:18,975 --> 00:06:24,920
число раз сколько каждая операция выполняется, рассчитать ее вес, и так для всех. 

65
00:06:24,920 --> 00:06:32,113
Но может нам просто следует подсчитать замую

66
00:06:32,113 --> 00:06:39,614
затратную. Вот что сказал Тьюринг в 1947. И это то как мы делаем 

67
00:06:39,614 --> 00:06:46,852
в наши дни. Вместо того чтобы считать каждую маленькую деталь, мы берем

68
00:06:46,852 --> 00:06:52,856
некоторую базовую операцию, возможно, самую дорогую или

69
00:06:53,071 --> 00:06:59,480
выполняющуюся чаще других. И используем ее

70
00:06:59,480 --> 00:07:05,075
для приближения времени выполнения. Важно при составлении гипотезы учитывать, что время

71
00:07:05,075 --> 00:07:10,237
выполнения растет. В данном случае мы

72
00:07:10,237 --> 00:07:15,278
вы берем доступ к массиву. Это первое упрощение. Второе это то,

73
00:07:15,278 --> 00:07:20,383
что мы будем игнорировать величины низшего порядка в формулах

74
00:07:20,383 --> 00:07:26,239
которые мы выводим. Есть простой способ сделать это. Он называется tilda notation

75
00:07:26,481 --> 00:07:33,552
его идея в том, что когда  в формулах как эта N большое, N^3 гораздо

76
00:07:33,552 --> 00:07:40,492
больше чем N или 16. По факту настолько больше что мы бы 

77
00:07:40,773 --> 00:07:47,845
с трудом заметили  члены меньшего порядка. Все эти формулы примерно 

78
00:07:47,853 --> 00:07:54,344
1/6N^3 и это хорошее приближение этих  

79
00:07:54,344 --> 00:08:00,766
величин. Это значительно упрощает их вычисление.

80
00:08:00,766 --> 00:08:05,963
Сфокусировавшись на одной операции и отбросив члены

81
00:08:05,963 --> 00:08:11,653
низшего порядка. Вот формальное определение соотношения ~

82
00:08:11,885 --> 00:08:16,868
f(N)~g(~) означает что предел f(N)/g(N) равны 1. 

83
00:08:16,868 --> 00:08:23,395
И вы можете проверить, что достоверность в наших случаях. Это значительно 

84
00:08:23,395 --> 00:08:30,482
упрощает подсчет частоты. Мы выберем только доступ в массиву ~N^2

85
00:08:30,482 --> 00:08:36,049
и может быть еще ~N^2 инкрементирования в задаче

86
00:08:36,049 --> 00:08:41,323
суммы двух. Когда N большое остальными членами можно пренебречь, а когда

87
00:08:41,323 --> 00:08:46,493
N мало, нельзя, но на самом деле это нам 

88
00:08:46,493 --> 00:08:51,522
не важно, так как мы пытаемся оценить время для больших N и  время запуска на малых N будет

89
00:08:51,522 --> 00:08:57,491
и так мало. Используя оба упращения

90
00:08:57,491 --> 00:09:04,228
можем просто сказать что наша программа использует ~N^2 

91
00:09:04,228 --> 00:09:11,630
обращений к массиву,  и гипотезой будет то, что время работы

92
00:09:11,630 --> 00:09:18,362
будет ~cosnt*N2 . 

93
00:09:18,362 --> 00:09:25,618
Теперь разберемся с задачей о сумму трех. У нас есть тройной цикл. И более

94
00:09:25,618 --> 00:09:32,888
сложная комбинаторная задача, но это не слишком

95
00:09:33,151 --> 00:09:40,710
 мы ищем  число способов выбрать три числа из N

96
00:09:40,963 --> 00:09:48,188
и это биномиальный коэффициент. И снова проведя вычисления

97
00:09:48,188 --> 00:09:54,284
получим что это ~N^3/6, а доступов к массиву

98
00:09:54,284 --> 00:10:01,006
~N^3/2. Мы не считаем и не складываем затраты всех операций, это

99
00:10:01,006 --> 00:10:07,581
требует слишком много работы. Мы  выбираем самые затратные и повторяющиеся,

100
00:10:07,795 --> 00:10:15,170
оцениваем их и пытаемся получить хорошую модель времени работы.

101
00:10:15,462 --> 00:10:22,422
Мы не собираемся пройти всю дискретную математики в этом курсе,

102
00:10:22,422 --> 00:10:29,101
но вот некоторые базовые вещи, которые мы будет использовать, и которые

103
00:10:29,101 --> 00:10:35,245
легко понять. Часто нам нужно будет необходимо оценивать

104
00:10:35,245 --> 00:10:40,872
дискретные суммы, как мы делали для 1 до N, или суммы квадратов или 

105
00:10:41,118 --> 00:10:48,044
другие вещи как сумма по тройному циклу. И один из способов как можно

106
00:10:48,044 --> 00:10:53,351
с ними разобраться это заменить суммы интегралами.

107
00:10:53,351 --> 00:10:58,158
Это обычно работает, и мы можем использовать так называемую

108
00:10:58,158 --> 00:11:03,920
формулу суммирования Эйлера-Маккларена чтобы получить верное приближение. 

109
00:11:03,920 --> 00:11:10,409
это будет ~1/N^2.

110
00:11:10,409 --> 00:11:16,378
сумма 1 +1/2+1/3 + ... + 1/N. Это как интеграл от 1 до N

111
00:11:16,378 --> 00:11:22,262
и это logN. Для суммироанвия по трем циклам тоже

112
00:11:22,262 --> 00:11:27,214
используем множественный интеграл, и получит N^3/6.

113
00:11:27,438 --> 00:11:33,368
Есть много других методов которые мы можем использовать для этого. Но мы не будем

114
00:11:33,368 --> 00:11:38,774
изучать их все, но иногда будем ссылаться на их результаты.

115
00:11:38,774 --> 00:11:45,637
Кнут говорил, что в принципе точные модели доступны, 

116
00:11:45,637 --> 00:11:52,928
практике мы получаем очень сложные формулы. И возможно нам 

117
00:11:52,928 --> 00:11:59,568
потребуется некоторая продвинутая математика, которую 

118
00:11:59,799 --> 00:12:06,565
люди изучающие алгоритмы в первый раз могут и не знать.

119
00:12:06,565 --> 00:12:12,338
В итоге точные модели лучше оставить для экспертов.

120
00:12:12,338 --> 00:12:19,079
С другой стороны приближенные модели определено стоят внимания.

121
00:12:19,079 --> 00:12:25,087
 И для всех алгоритмов, что мы рассматриваем, мы попытаемся дать

122
00:12:25,087 --> 00:12:31,656
достоверную приближенную модель, которая может использоваться для описания

123
00:12:31,656 --> 00:12:38,035
времени работы. Иногда мы будем давать математическое доказательство, а 

124
00:12:38,035 --> 00:12:48,060
иногда просто цитировать работу экспертов.