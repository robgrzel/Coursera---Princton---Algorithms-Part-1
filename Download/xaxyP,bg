1
00:00:02,000 --> 00:00:07,036
Добре дошли отново. Днес ще се занимаваме с малко математика и малко наука. Не много, но 

2
00:00:07,036 --> 00:00:11,055
ще имаме нужда от научна основа за да разберем  производителността на нашите

3
00:00:11,055 --> 00:00:15,075
алгоритми, за да ги прилагаме правилно в практиката. Така че днес ще говорим

4
00:00:15,275 --> 00:00:20,040
за това, как да наблюдаваме показателите на производителността на алгоритмите. Ще

5
00:00:20,040 --> 00:00:25,022
разгледаме как се правят математически модели и как да класифицираме алгоритми според

6
00:00:25,022 --> 00:00:30,010
степента на нарастване на тяхното време за изпълнение. Ще говорим малко за теорията на

7
00:00:30,010 --> 00:00:35,790
алгоритмите и също как да анализираме употребата на паметта. За да погледнем от тази гледна точка,

8
00:00:35,790 --> 00:00:42,206
ще поразсъждаваме относно тези проблеми от гледна точка на различни типове

9
00:00:42,206 --> 00:00:48,139
персонажи. Първият е програмистът, който трябва да реши дадена задача

10
00:00:48,139 --> 00:00:54,270
 и да накара решението да работи. Вторият е клиентът, който иска да използва

11
00:00:54,270 --> 00:01:00,167
програмата за да си свърши работата. Третият е теоретикът,

12
00:01:00,167 --> 00:01:06,424
това е някой, който горещо иска да разбере какво се случва. И, и 

13
00:01:06,424 --> 00:01:10,724
последният тип е нещо като съвкупност - онова базово блокиране и боричкане, понякога необходимо 

14
00:01:10,724 --> 00:01:15,790
за да станат нещата готови. Така че има по малко от всеки

15
00:01:15,790 --> 00:01:21,110
от тези типажи в днешната лекция. И всъщност като студенти, вие трябва да имате предвид, 

16
00:01:21,110 --> 00:01:26,753
че един ден може да попаднете в една от тези роли, или във всички наведнъж. Затова е много

17
00:01:26,753 --> 00:01:31,522
важно да се разберат различните гледни точки. Ключът върху който ще 

18
00:01:31,522 --> 00:01:38,205
се фокусираме е 'времето за изпълнение'. Всъщност идеята за анализа на времето за изпълнение на

19
00:01:38,205 --> 00:01:44,017
дадена сметка датира още от времето на Бабидж (Babbage) и вероятно преди него. И ето един

20
00:01:44,017 --> 00:01:48,083
цитат от Бабидж - "Щом се появи аналитична машина, тя 

21
00:01:48,083 --> 00:01:54,076
задължително ще поведе бъдещото развитие на науката. Когато се потърсят резултати от

22
00:01:54,076 --> 00:02:00,062
помощта й, ще се появи въпросът 'с каква последователност от изчисления могат тези резултати

23
00:02:00,062 --> 00:02:06,072
 да бъдат получени от машината за най-кратко време'". Ако погледнете машината на Бабидж

24
00:02:06,072 --> 00:02:12,009
наречена 'аналитичната машина', ще видите, че има ръчка на нея. И буквално проблемът, 

25
00:02:12,009 --> 00:02:17,060
който Бабидж е имал бил колко пъти

26
00:02:17,060 --> 00:02:23,048
трябва да се дръпне ръчката на машината. Не е, не е много по-различно и в съвременния свят. 

27
00:02:23,048 --> 00:02:29,018
Ръчката може да е нещо електронно, което се случва милиард пъти в секунда. Но

28
00:02:29,018 --> 00:02:34,041
ние отново се интересуваме колко пъти дадена дискретна (изброима) операция трябва да бъде

29
00:02:34,041 --> 00:02:39,093
приложена за да направим някакво изчисление. Така че в крайна сметка имаме много причини за да

30
00:02:39,093 --> 00:02:45,032
анализираме алгоритми. В контекста на този курс, ние се интересуваме основно от

31
00:02:45,032 --> 00:02:50,051
предсказването на производителността. Също искаме да сравняваме производителността на различни

32
00:02:50,051 --> 00:02:54,768
алгоритми за една и съща задача и да може да предоставим някои гаранции за това колко 

33
00:02:54,768 --> 00:03:00,058
добре се представят. Заедно с това и да разберем някои теоретични основи за

34
00:03:00,077 --> 00:03:05,780
това как се представят алгоритмите. Но основната, практическата причина, поради която искаме

35
00:03:06,024 --> 00:03:11,098
да анализираме алгоритми и да ги разбираме е да избегнем бъгове заради производителността. Бихме искали

36
00:03:11,098 --> 00:03:16,050
да имаме известна увереност, че нашите алгоритми ще завършат изпълнението си в

37
00:03:16,050 --> 00:03:21,084
рамките на времето, което, което предполагаме, че ще е необходимо. И е много, много често срещано явление

38
00:03:21,084 --> 00:03:26,080
в съвременната изчислителна инфраструктура, ситуацията в която клиентът получава слаба

39
00:03:26,080 --> 00:03:31,026
производителност заради това, че програмистът не е разбирал

40
00:03:31,026 --> 00:03:36,086
характеристиките на производителността на алгоритъма. И целта на днешната лекция е да се опитаме да избегнем

41
00:03:36,086 --> 00:03:42,087
това. Сега ще се фокусираме върху производителността и сравнението на алгоритмите от

42
00:03:42,087 --> 00:03:48,064
този курс. Има курсове в програмата по компютърна наука, които 

43
00:03:48,064 --> 00:03:53,093
съдържат повече информация относно теоретичната основа на алгоритми и аз ще

44
00:03:53,093 --> 00:03:59,090
разкажа малко за това на по-късен етап. Но нашият фокус е върху това да успеем да предсказваме

45
00:03:59,090 --> 00:04:07,007
производителността и да сравняваме алгоритми. Има дълъг списък от успешни примери за

46
00:04:07,030 --> 00:04:12,081
дизайн на алгоритъм с по-добра производителност, давайки решение

47
00:04:12,081 --> 00:04:19,025
на задачи, които иначе биха били нерешими. Ще дам няколко

48
00:04:19,025 --> 00:04:25,346
примера. Един от първите и най-известни е тъй нареченият FFT алгоритъм. Това е

49
00:04:25,346 --> 00:04:32,057
алгоритъм за разбиването вълновата форма на N извадки от сигнал на периодични

50
00:04:32,057 --> 00:04:38,431
 компоненти. И това е в основата на DVD-тата и JPEG компресията, както и на много други приложения.

51
00:04:38,431 --> 00:04:44,296
Има лесен начин това да се направи, който отнема време за изпълнение пропорционално на N^2. Но

52
00:04:44,296 --> 00:04:49,080
FFT алгоритъмът отнема само N log N стъпки. И разликата между N log N

53
00:04:49,080 --> 00:04:55,002
и N^2 е, е разликата между това да можеш да решиш тежка задача и

54
00:04:55,002 --> 00:04:59,078
да не можеш да я решиш. Много от цифровите технологии, цифровите медии

55
00:04:59,078 --> 00:05:04,822
 които имаме в наши дни, са имплементирани с този бърз алгоритъм. Друг пример

56
00:05:05,051 --> 00:05:11,232
беше реално разработен от Андрю Апел (Andrew Appel), който сега ръководи катедрата по компютърна наука

57
00:05:11,232 --> 00:05:16,582
тук в Принстън. И го беше разработил докато беше студент

58
00:05:16,582 --> 00:05:22,725
като дипломна работа. Това е бърз алгоритъм решаващ задачата за "N body simulation". Лесният

59
00:05:22,725 --> 00:05:28,548
алгоритъм отнема време пропорционално на N^2, но алгоритъмът на Апел отнемаше N log N

60
00:05:28,548 --> 00:05:33,452
което означаваше, че учените могат да правят "N body simulation" за

61
00:05:33,452 --> 00:05:41,478
големи стойности на N. И това предизвиква нови проучвания. Така че предизвикателството, с което 

62
00:05:41,478 --> 00:05:47,677
обикновено се сблъскваме е, ще може ли моята програма да обработи голям, практически полезен вход? И, и

63
00:05:47,677 --> 00:05:52,024
всъщност, работещият програмист е изправен пред този проблем през цялото време.

64
00:05:52,024 --> 00:05:58,001
Защо, защо програмата ми работи толкова бавно? Защо й свършва паметта? И това

65
00:05:58,001 --> 00:06:05,000
е занимавало програмистите наистина дълго време, като  прозрението как може да се реши този проблем... Дойтер Кануф (Deuter Kanoof)

66
00:06:05,000 --> 00:06:10,030
през 1970-те години, открил, че наистина може да се ползва научният подход за да

67
00:06:10,030 --> 00:06:16,062
 се разбере производителността на алгоритмите в действие. Може би не отключваме

68
00:06:16,062 --> 00:06:23,010
нови тайни на вселената, но ние можем да използваме научният подход и да се отнасяме

69
00:06:23,010 --> 00:06:29,042
към компютъра като нещо, което може да бъде изучавано по този начин и така да разберем

70
00:06:29,042 --> 00:06:34,008
каква ще бъде производителността на нашата програма. Нека да разгледаме това по-детайлно.

71
00:06:34,209 --> 00:06:39,063
Та това е просто кратко резюме на това какво разбираме като ползваме понятието "научен подход", ползван

72
00:06:39,268 --> 00:06:44,086
успешно в продължение на няколко века. Така че, това което ще направим,

73
00:06:44,086 --> 00:06:50,008
е да наблюдаваме някоя характеристика на естественият свят. В този случай това ще бъде

74
00:06:50,008 --> 00:06:54,857
времето за изпълнение на нашата програма на компютър. После ще изработим хипотеза

75
00:06:55,049 --> 00:06:59,079
някакъв модел, който се доближава до направените наблюдения, а след това ще се надяваме

76
00:06:59,079 --> 00:07:04,040
че, че хипотезата е достатъчно добра за да ни даде възможност да предскажем нещо.

77
00:07:04,040 --> 00:07:09,031
Обикновено да предскажем времето за изпълнение на по-тежка задача или на различен компютър.

78
00:07:09,197 --> 00:07:13,097
И след това ще проверим дали предсказването е било вярно, като направим още наблюдения и валидираме

79
00:07:13,097 --> 00:07:18,058
докато моделът и наблюденията не съвпаднат достатъчно задоволително.

80
00:07:18,058 --> 00:07:22,077
Това е начин да се сдобием със самочувствието, че разбираме производителността на нашите

81
00:07:22,077 --> 00:07:28,056
програми. Сега, в научния подход, има някои основни принципи и

82
00:07:28,056 --> 00:07:33,082
първият е, че ако ще правиш експерименти, трябва да очакваш, че

83
00:07:33,082 --> 00:07:39,021
някой друг също ще може да ги изпълни и да получи същите резултати. И

84
00:07:39,021 --> 00:07:44,067
също така хипотезите трябва да притежават специфична характеристика, така че чрез експериментите

85
00:07:44,067 --> 00:07:49,736
да се покаже дали хипотезата е вярна или не. Затова трябва да е внимателно изработена и ние ще

86
00:07:49,736 --> 00:07:55,433
се опитаме да направим точно това. Така че, отново, бъдещето на естествения свят, който 

87
00:07:55,433 --> 00:08:00,822
изучаваме е някой конкретен компютър, който съществува в естествения свят. Това променя

88
00:08:00,822 --> 00:08:07,049
алгоритъма от абстракция, в нещо, в нещо като истинско материално нещо

89
00:08:07,049 --> 00:08:11,083
което се случва, като надбягващи се електрони в компютър.