1
00:00:02,022 --> 00:00:08,015
好吧，快速查找对于巨大问题太慢了。所以我们如何才能做得更好？

2
00:00:08,015 --> 00:00:14,035
我们的第一个尝试是一个叫做快速合并的替代算法。这在

3
00:00:14,035 --> 00:00:20,082
算法设计中是所谓的“懒策略”，我们尽量避免计算直到不得不进行计算

4
00:00:20,082 --> 00:00:27,506
它使用相同的数据结构，大小为N的id数组，但是

5
00:00:27,506 --> 00:00:34,280
数组有了不同的含义。我们把数组看作

6
00:00:34,280 --> 00:00:41,298
一组树即一片森林的表示，如右图所示。那么

7
00:00:41,298 --> 00:00:49,468
数组中每一项则包含它在树中的父节点。比如

8
00:00:49,468 --> 00:00:57,425
3的父节点是4，4的父节点是9。所以数组中3对应的项是4

9
00:00:57,425 --> 00:01:06,681
4对应的项是9。现在每个记录都有对应的根节点

10
00:01:06,681 --> 00:01:13,179
是其所在树的根节点。彼此不相连的对象

11
00:01:13,179 --> 00:01:19,303
在各自的连通分量中，记录中的父节点则指向自己，所以1指向自己

12
00:01:19,303 --> 00:01:26,108
但是9也指向自己，因为它是树的根节点，那棵树包括2、4、3

13
00:01:26,108 --> 00:01:32,419
所以，利用这个数据结构我们可以将每个记录与一个根节点相联系

14
00:01:32,419 --> 00:01:40,202
这就表示了它所在的连通分量

15
00:01:40,202 --> 00:01:47,044
3的根节点是9，一路从父节点向上就能找到根节点。一旦我们能够计算根节点

16
00:01:47,044 --> 00:01:52,956
我们就能这样实现查找操作：通过检查

17
00:01:52,956 --> 00:01:57,592
我们想要知道是否相连的两个对象的根节点是否相同

18
00:01:57,592 --> 00:02:02,373
这和它们是否在相同的连通分量这个问题是等价的。这里需要一些计算

19
00:02:02,373 --> 00:02:09,240
以找到每个对象的根节点，但是合并操作非常简单

20
00:02:09,240 --> 00:02:15,254
要合并包含两个对象的分量，两个对象在不同的分量中

21
00:02:15,254 --> 00:02:21,613
我们只需要将P的根节点id记录值设为Q的根节点ID记录值

22
00:02:21,613 --> 00:02:28,748
我们将P的树指向Q。例如，我们将9对应的项改为6以

23
00:02:28,748 --> 00:02:35,027
合并3和5所在的分量

24
00:02:35,027 --> 00:02:41,317
只需改变数组中一个值我们就将两个大分量合并到了一起

25
00:02:41,317 --> 00:02:46,295
这就是快速合并算法。因为合并操作只

26
00:02:46,295 --> 00:02:52,429
改变数组中的项。查找操作需要多一些操作

27
00:02:52,429 --> 00:02:57,907
我们先来看一下这个实现运行的演示

28
00:02:57,907 --> 00:03:03,569
我们再一次从同样的方式初始化，但是id数组项实际上表示

29
00:03:03,569 --> 00:03:09,415
每个对象是一棵小树其中每个节点指向它自己

30
00:03:09,415 --> 00:03:15,284
即它自己那课树的根节点。现在如果我们要将4和3放进同一个分量

31
00:03:15,284 --> 00:03:21,236
我们要做的就是将包含第一个对象的分量的根节点

32
00:03:21,236 --> 00:03:26,624
变成包含第二个对象的分量的根节点的一个子节点

33
00:03:26,624 --> 00:03:33,029
这个例子中，我们就将4的父节点设为3。现在是3和8

34
00:03:33,259 --> 00:03:39,823
同样地，我们将第一个对象变为包括第二个对象的树的根节点的子节点

35
00:03:39,823 --> 00:03:47,532
所以现在3、4、8在同一个分量中

36
00:03:47,532 --> 00:03:56,434
6和5，6成为5的子节点。9和4，现在

37
00:03:56,434 --> 00:04:06,045
包含4的树的根节点是8，包含9的树的根节点是9

38
00:04:06,045 --> 00:04:13,745
所以9变成8的一个子节点。2和1，这个很简单

39
00:04:14,007 --> 00:04:20,993
现在如果我们得到8和9是否连通的请求，我们只需要检查他们是否

40
00:04:20,993 --> 00:04:28,011
具有相同的根节点，而它们的根节点都是8，所以它们是连通的

41
00:04:28,011 --> 00:04:34,230
5和4，4的根节点是8，5的根节点是5，根节点不同，它们不连通

42
00:04:34,230 --> 00:04:42,339
5和0，5成为0的一个子节点。7和2，7成为2的根结点1的一个子节点

43
00:04:42,339 --> 00:04:52,836
7成为2的根结点1的一个子节点
6和1，6的根节点是0，1是它自己的根节点

44
00:04:52,836 --> 00:05:00,636
所以0成为1的一个子节点。每个合并操作只需要

45
00:05:00,636 --> 00:05:10,069
改变数组中的一项。最后，7和3，7的根节点是1

46
00:05:10,069 --> 00:05:18,755
3的根节点是8，1成为8的一个子节点。好，现在

47
00:05:18,755 --> 00:05:26,012
我们有了一个包含所有对象的连通分量。那么，现在我们来看

48
00:05:26,012 --> 00:05:32,668
实现快速合并的代码。构造器与快速查找相同

49
00:05:32,668 --> 00:05:40,967
我们创建一个数组并将每个对象设为它自己的根节点

50
00:05:40,967 --> 00:05:46,005
这里我们有一个私有方法实现寻找根节点的过程，通过回溯

51
00:05:46,005 --> 00:05:51,352
父节点直到到达节点i，其id记录值也等于i。如果不相等

52
00:05:51,352 --> 00:05:57,369
则继续将i在树中上移一层，把i设为i的id记录值。最后返回i

53
00:05:57,369 --> 00:06:02,005
所以从任何节点开始，只需要一直进行i等于i的id记录值操作直到两者相等

54
00:06:02,005 --> 00:06:07,396
就能到达根节点。我们用这个私有方法来

55
00:06:07,396 --> 00:06:11,959
实现查找操作或者“是否连通”操作。只需要找到

56
00:06:11,959 --> 00:06:17,316
P的根节点和Q的根节点，检查它们是否相等。接下来合并操作

57
00:06:17,316 --> 00:06:23,342
就是找到两个根节点并将第一个根节点的id记录值设为第二个根节点

58
00:06:23,342 --> 00:06:30,310
实际上快速合并算法的代码量比快速查找少，而且没有for循环

59
00:06:30,310 --> 00:06:37,139
这里有一个while循环我们可能需要稍微考虑一下。但是

60
00:06:37,139 --> 00:06:43,326
快速合并算法依然是用来求解动态连通性问题的一个快速而优雅的代码实现

61
00:06:43,326 --> 00:06:50,318
接下来我们看看这个代码对于巨大问题是否是高效的

62
00:06:50,582 --> 00:06:57,657
不幸的是快速合并算法快了一些但是依然太慢了

63
00:06:57,657 --> 00:07:04,042
相对快速查找它是另一种慢

64
00:07:04,042 --> 00:07:10,005
有些情况下它可以很快，而有些情况下它还是太慢了

65
00:07:10,005 --> 00:07:16,256
快速合并的缺点在于树可能太高了。这意味着

66
00:07:16,256 --> 00:07:22,065
查找操作的代价太大了。你可能需要回溯一棵瘦长的树

67
00:07:22,065 --> 00:07:28,432
每个对象只是指向下一个节点，那么对叶子节点执行一次查找操作

68
00:07:28,432 --> 00:07:33,976
需要回溯整棵树

69
00:07:34,183 --> 00:07:40,184
只进行查找操作就需要花费N次数组访问

70
00:07:40,184 --> 00:07:44,013
如果操作次数很多的话这就太慢了