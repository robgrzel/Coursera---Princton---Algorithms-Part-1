1
00:00:01,065 --> 00:00:07,024
最後に安定性について話します。ゲームでの規則の一つですが

2
00:00:07,024 --> 00:00:11,029
今まで見てきた実際のアルゴリズムの中で話せば、ずっと簡単です。

3
00:00:11,029 --> 00:00:15,068
今から話すことは、先に紹介したコンパレータについて知らなければ意味がありません。

4
00:00:15,068 --> 00:00:21,022
よくあるアプリケーションの例として

5
00:00:21,022 --> 00:00:26,098
生徒のデータがあるとします。名前でソートされていて

6
00:00:26,098 --> 00:00:31,884
最終成績を決める前だとします。三列目が

7
00:00:31,884 --> 00:00:38,026
最終成績とします。全て BY_NAME でソートされていますが

8
00:00:38,026 --> 00:00:44,009
section 列に従い全員の成績を決めるためには

9
00:00:44,009 --> 00:00:50,625
二列目を BY_SECTION でソートすることです。問題はそれをしてしまうと

10
00:00:50,625 --> 00:00:57,945
名前順の整列がぐちゃぐちゃになって困ったことになります。

11
00:00:57,945 --> 00:01:04,329
一度名前でソートしたのだから、次に二列目でソートしたら

12
00:01:04,329 --> 00:01:10,742
二列目の同キーの中では名前の整列は維持されるだろうと思いますよね。

13
00:01:10,742 --> 00:01:17,191
実は、すべてのソートはこの安定性と呼ばれる特性を保持しません。

14
00:01:17,191 --> 00:01:22,726
明らかに、あなたのアプリケーションにおいて考える価値があるのは

15
00:01:22,726 --> 00:01:28,039
安定ソートしたいのか、そもそも必要かどうかです。多くの人々、アプリケーションにとって

16
00:01:28,039 --> 00:01:33,659
やっかいなことです。安定ソートは同キー内での要素順を保持します。

17
00:01:33,659 --> 00:01:38,956
一体どれが安定ソートなんでしょう？興味深い質問です。

18
00:01:38,956 --> 00:01:44,879
それを今から見てみましょう。結論から先にいうと挿入ソートと

19
00:01:44,879 --> 00:01:52,238
マージソートが安定ソートです。選択ソートとシェルソートは違います。

20
00:01:52,238 --> 00:01:58,477
下に書いてありますが、実装によって安定ソートにならない場合があります。

21
00:01:58,477 --> 00:02:04,158
そうなっているかコードを注意深く確認すべきです。本コースでは

22
00:02:04,158 --> 00:02:10,834
指定のソートが安定ソートかそうでないかを問う練習問題や試験があります。

23
00:02:10,834 --> 00:02:16,709
ですので、生徒の皆さんはコードが安定ソートかどうか見極められるようになってください。

24
00:02:16,905 --> 00:02:21,879
良くある例ですが、時間でソートされているものがあって

25
00:02:22,050 --> 00:02:27,435
ロックコンサートのチケットを買う人達の大事な履歴だとしましょう。

26
00:02:27,435 --> 00:02:31,702
場所でソートしますよね。時間でのソートが保持されると期待したところで

27
00:02:31,702 --> 00:02:36,640
これは安定ソートではなく、そうはなりません。このようなソートを使うなら

28
00:02:36,640 --> 00:02:41,725
場所で切り出して再度ソートすることが必要です。

29
00:02:41,725 --> 00:02:47,692
安定ソートを使うものなら、時間順はそのままです。大抵、安定性は欲しいですよね。

30
00:02:47,692 --> 00:02:54,015
では今までにやってきたアルゴリズム毎に見てみましょう。

31
00:02:54,207 --> 00:02:59,097
挿入ソートは安定ソートです。なぜでしょうか？

32
00:02:59,097 --> 00:03:05,633
等しい要素を超えて移動することはしません。この例では A1 の時に、ええと

33
00:03:05,866 --> 00:03:12,141
この例では、このインデックスは配列内の出現数ですね、A と B だけです。

34
00:03:12,141 --> 00:03:18,763
二番目の A の時に、小さくなければソートを止めます。

35
00:03:18,763 --> 00:03:24,911
等しいか小さくなければですね。等しい要素を越えて移動することはしません。

36
00:03:24,911 --> 00:03:30,488
この less 関数で等しいか小さいなら、それで終わりです

37
00:03:30,488 --> 00:03:35,818
そうでなかったらそのまま進めます。このコードでは、等しい要素は飛び越えません。

38
00:03:35,818 --> 00:03:41,997
ゆえに挿入ソートは安定ソートです。しかし選択ソートはそうではありません。

39
00:03:42,298 --> 00:03:49,529
大抵の場合、ソートが安定ソートでないのは

40
00:03:49,529 --> 00:03:55,875
離れた間隔で入れ替えて、等しい要素を動かしてしまう場合です。

41
00:03:56,163 --> 00:04:02,245
[cough] 例えばこの選択ソートのケースでは

42
00:04:02,245 --> 00:04:08,471
最初の交換をする時に、 [cough] 最小値 A と位置 0 にある B を

43
00:04:08,471 --> 00:04:14,951
離れた間隔で交換しました。等しいかもしれない他の要素を飛び越して

44
00:04:14,951 --> 00:04:21,249
最初の要素を動かしたので、順序が狂っているかもしれません。

45
00:04:21,249 --> 00:04:26,524
それっきりなので安定ソートではありません。等しい要素を超えて移動しますし

46
00:04:26,524 --> 00:04:32,601
等しい要素の並び順は元ファイルとは違った結果になります。

47
00:04:32,601 --> 00:04:39,016
選択ソートは安定ソートではありません。シェルソートも離れた間隔で交換しますので

48
00:04:39,016 --> 00:04:45,479
安定ソートではありません。等しいキーであっても移動させます。

49
00:04:45,479 --> 00:04:51,024
シェルソートが安定ソートでない示す例を作るのは簡単ですね。

50
00:04:51,024 --> 00:04:57,527
ではマージソートは？マージ処理が安定性を持つならば、マージソートは安定ソートです。

51
00:04:57,527 --> 00:05:02,923
マージ処理の安定性はどのようなコードを書くかに依存します。

52
00:05:03,118 --> 00:05:09,232
我々のコードでは、二つのキーが等しいなら、左の子配列から取り出しますから

53
00:05:09,232 --> 00:05:15,670
意味するところは、等しいキーを持つ二つのセットがある場合でも

54
00:05:15,670 --> 00:05:21,112
それぞれの順序は保持されますので、そのことで十分に

55
00:05:21,112 --> 00:05:26,672
マージ処理は安定性を持つ事が分かります。ゆえにマージソートは安定ソートです。

56
00:05:26,672 --> 00:05:38,905
安定性はソートアルゴリズムにおいて重要な特性です。マージソートは効率があるだけでなく安定ソートです。