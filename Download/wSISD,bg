1
00:00:03,054 --> 00:00:09,019
Добре дошли отново. Днес ще 
разгледаме няколко интересни 

2
00:00:09,019 --> 00:00:15,011
приложения на символни таблици и 
двоично търсене като структури от данни

3
00:00:15,011 --> 00:00:21,413
които адресират проблематиката с обработването на геометрични
данни. Нека сега да ги разгледаме. Идеята

4
00:00:21,413 --> 00:00:27,378
е да обсъждаме 
геометрични обекти, а не обикновени ключове като

5
00:00:27,378 --> 00:00:33,338
низове от знаци или числа. Ето един пример.
Да кажем, че геометричните обекти са точки

6
00:00:33,338 --> 00:00:38,346
в равнината и ние специфицираме правоъгълник
който е ориентиран с

7
00:00:38,346 --> 00:00:43,404
хоризонталната/вертикалната оси. И може би
се питаме, кои точки попадат вътре

8
00:00:43,404 --> 00:00:48,200
в правоъгълника или колко точки са вътрешни
за правоъгълника? Или може би това, което 

9
00:00:48,200 --> 00:00:54,011
обработваме са правоъгълници. Имаме серия
от правоъгълници, и искаме да разберем кои

10
00:00:54,011 --> 00:01:00,291
от тях се пресичат един друг? Или колко
са правоъгълниците образувани от пресичането? Това

11
00:01:00,291 --> 00:01:05,837
са интересни проблеми, които имат много
и много приложения, от

12
00:01:05,837 --> 00:01:11,806
компютърен дизайн, до игри и филми,
а също така търсения в бази данни

13
00:01:11,806 --> 00:01:17,849
и други ситуации в които може
да имаме множество ключове или няколко измерения.

14
00:01:18,065 --> 00:01:24,856
И е много интересно разширение на
идеята която разгледахме за символните 

15
00:01:24,856 --> 00:01:30,175
таблици за всички видове известни
приложения. И, изненадващо двоичните

16
00:01:30,175 --> 00:01:34,300
дървета и свързаните с тях
алгоритми, които разгледахме,

17
00:01:34,300 --> 00:01:39,774
ще осигурят много ефициентни решения на
голям брой важни проблеми в тази област.

18
00:01:39,774 --> 00:01:45,943
И наистина са направили възможни нови развития
и технологии във всички тези видове

19
00:01:45,943 --> 00:01:51,135
приложения. Така, за да започнем, ще
разгледаме една лесна задача наречена

20
00:01:51,135 --> 00:01:56,761
търсене в едноизмерен интервал. И това 
наистина поставя основите за онова, което смятаме

21
00:01:56,761 --> 00:02:02,146
да направим. До някъде е
разширение на интерфейса на подредените символни таблици

22
00:02:02,146 --> 00:02:07,837
което показахме преди и ще 
добавим операциите за търсене на интервал и

23
00:02:07,837 --> 00:02:12,797
броене на интервал. Така, едноизмерно просто
означава, че имаме един ключ, така че да вкарваме

24
00:02:12,797 --> 00:02:19,116
ключ - стойност двойки и това, което целим 
е способността да търсим за ключ и

25
00:02:19,116 --> 00:02:24,770
стойността, с което този ключ е асоцииран, или да 
трием двойката. Но също така искаме и 

26
00:02:24,770 --> 00:02:30,703
операциите за търсене на интервал и броене на интервал.
Намери всички ключове, които са между два

27
00:02:30,703 --> 00:02:36,083
зададени ключа, или преброй колко общо са 
тези между два зададени ключа. За този

28
00:02:36,083 --> 00:02:42,251
пример ние сме вкарали вече няколко 
ключа и ги показваме 

29
00:02:42,251 --> 00:02:47,992
в подреден вид. Но винаги можем да си зададем въпроса,
"ами колко ключове има, които са

30
00:02:47,992 --> 00:02:53,780
между ключовете "g" и "к"? " В този случай, те са
само два. И след това клиентът може да попита,

31
00:02:53,780 --> 00:02:59,598
"ами кои са тези ключове?" и ние искаме
да можем да ги върнем като отговор. И това е много

32
00:02:59,598 --> 00:03:06,010
разпространена операция, например в базите данни. Ние
искаме да върнем като отговор колко данъкоплатци имат

33
00:03:06,010 --> 00:03:11,335
заплати между един милион и десет 
милиона и после кои са те, и 

34
00:03:11,335 --> 00:03:17,431
т.н. Така че, търсене на интервал е много
важна основна операция. Сега, в

35
00:03:17,431 --> 00:03:23,459
геометрическата интерпретация, ние мислим,
че ключовете са като точки на линия. И така,

36
00:03:23,459 --> 00:03:29,627
двойките от ключ и стойност са специфицирани като
точки върху линия. Можем да превърнем

37
00:03:29,627 --> 00:03:34,856
буквите в номера, или може
ключовете да са номера. И тогава, това което 

38
00:03:34,856 --> 00:03:41,119
търсим е да намерим броя на точките
в даден интервал в едно измерение. 

39
00:03:41,575 --> 00:03:47,272
Как ще осъществим всичко това? Ами,
това е фундаменталният въпрос, които е много

40
00:03:47,272 --> 00:03:52,356
близък до този на символните таблици. Ние
може би ще помислим да задържим нещата в 

41
00:03:52,356 --> 00:03:57,529
неподреден масив. Просто ги слагаме в
масив и след това вкарването на двойка в масива става 

42
00:03:57,529 --> 00:04:03,254
бързо. Ние просто ще ги вкарваме на края  на
масива. Може би ще се наложи да изполваме операции за разширяване

43
00:04:03,254 --> 00:04:08,371
за да направим масива по-голям. Но това е
непривлекателно, заради големия брой

44
00:04:08,371 --> 00:04:13,899
ключове, за да можем да броим ключовете попадащи
в даден интервал, ние трябва да минем

45
00:04:13,899 --> 00:04:19,711
през всички ключове и да тестваме дали
те попадат в интервала или не, и да ги върнем

46
00:04:19,711 --> 00:04:26,043
по същия начин. Това ще струва линейно време за
голям брой от ключове. Ако пазим 

47
00:04:26,267 --> 00:04:32,638
нещата подредени както при двоично търсене,
тогава  за да вкараме ключовете подредени

48
00:04:32,638 --> 00:04:38,591
в масива, ще е необходимо
да преместим по-големите от тях с една позиция

49
00:04:38,596 --> 00:04:44,209
и т.н. или елементарно приложение на
двоично търсене, когато работехме върху
символните таблици

50
00:04:44,406 --> 00:04:49,662
направихме това. И така, времето на
въвеждане може да бъде линейно, но тогава
можете да използвате двоично

51
00:04:49,662 --> 00:04:55,329
търсене, за да търсите двете крайни точки,
но това ще отнеме време, 

52
00:04:55,329 --> 00:05:00,631
пропорционално на логаритъм от броя на елементите. И тогава от
там нататък, можете да разберете колко ключа

53
00:05:00,631 --> 00:05:06,243
има или да ги получите всички между 
най-малкия в обхвата индекс

54
00:05:06,243 --> 00:05:12,027
и най-големия в обхвата индекс. Така тези
елементарни имплементации не са

55
00:05:12,027 --> 00:05:18,179
приемливи за голям брой от ключове,
защото имат операция изискваща линейно време. Следователно, 

56
00:05:18,179 --> 00:05:24,035
това, което всъщност искаме е да имат време
с логаритмичен растеж. За вкарване на ключове и

57
00:05:24,035 --> 00:05:29,186
за броене на елемнти. За търсенето в интервал, 
разбира се, трябва да разгледаме всеки от ключовете

58
00:05:29,186 --> 00:05:35,413
които връщаме, така че времето за изпълнение 
ще бъде пропорционално на броя

59
00:05:35,413 --> 00:05:43,042
ключове, които пасват. Но така или иначе, това са
приемливи цели. И те са лесни за

60
00:05:43,042 --> 00:05:51,545
постигане. Така [кашлица] така, например какво
се случва при броене на едноизмерен масив?

61
00:05:51,545 --> 00:05:58,014
Ами, това което ще направим е просто да съхраняваме
ключовете в двоично дърво за търсене и ние

62
00:05:58,014 --> 00:06:03,484
разгледахме имплементацията на "ранк"
функцията при двоичните дървета  за търсене, където  за

63
00:06:03,484 --> 00:06:09,342
всеки ключ, можем да изчислим колко ключове
има, които са по-малки от даден

64
00:06:09,342 --> 00:06:15,508
ключ. Така в този случай, ранкът на "е" е две
и на "h" е три, и т.н. По този начин в

65
00:06:15,508 --> 00:06:21,413
двоичното дърво за търсене, номерата на ранковете
растат в

66
00:06:21,413 --> 00:06:27,662
сортиран ред и е лесно да
се изчисли. Трябва да запазиш този ранкова структура

67
00:06:27,662 --> 00:06:33,813
като глобално поле, или да запазиш полето което съдържа
големината на дървото и е лесно да се изчисли

68
00:06:33,813 --> 00:06:40,760
ранкът от там. Така, колко ключа има
между, да кажем "е" и "s"? Ами един, два,

69
00:06:40,760 --> 00:06:51,297
три, четири, пет. Всъщност броят им е равен на
разликата между ранковете плюс едно, ако

70
00:06:51,623 --> 00:07:00,361
горната [кашлица] граница на търсеният интервал
е в таблицата, а не с единица по-голяма. Така,

71
00:07:00,361 --> 00:07:08,274
броят на ключовете между "е"
и "s" е еднакъв с този между "е" и "t" - пет.

72
00:07:08,274 --> 00:07:15,192
Между "f" и "t" има само четири. 
Истината е, че броенето на интервал в 1 измерение е

73
00:07:15,192 --> 00:07:22,412
много лесно изчисление, което се изпълнява в 
логаритмично време чрез двоични дървета за търсене.

74
00:07:22,412 --> 00:07:28,297
[кашлица] Номерът на изследваните възели когато 
търсим е дължината на  

75
00:07:28,297 --> 00:07:33,789
пътя до най-малкият елемент плюс дължината на 
пътя до най-големия [кашлица] Намери техните ранкове

76
00:07:33,976 --> 00:07:39,595
и това ще се случи за време пропорционално
на логаритъм при основа две от N [кашлица]. Така е и при търсенето на интервал.

77
00:07:39,595 --> 00:07:46,018
Ами, ние просто ще търсим рекурсивно и 
за да намерим всички ключове между долната и горната граница,

78
00:07:46,214 --> 00:07:51,472
ще трябва да разгледаме лявата част на под-дървото дали някой от възлите
попада в интервала. Разглеждаме 

79
00:07:51,472 --> 00:07:57,106
актуалния възел и преминаваме към дясното
под-дърво, за да проверим дали някой там не попада в 

80
00:07:57,106 --> 00:08:02,555
интервала. Лесно да се каже дали някой
от тях попада в интервала само с

81
00:08:02,555 --> 00:08:08,476
проверка дали техните интервали се препокриват
с корена или не. Така че ако търсим 

82
00:08:08,476 --> 00:08:14,469
всички ключове между "f" и "t" трябва
да разгледаме двете под-дървета на корена

83
00:08:14,469 --> 00:08:19,643
"s". Но няма да разгледаме лявото 
под-дърво на "е" защото всички елементи там са по-малки

84
00:08:19,643 --> 00:08:26,018
от "е", следователно по-малки и от "f".  Така че
ние не трябва да търсим там. Но

85
00:08:26,018 --> 00:08:31,419
от друга страна,  би било лесно да променим
рекурсивното дърво за търсене ако искаме да намерим всички ключове

86
00:08:31,635 --> 00:08:37,702
и е лесно да пресметнем времето за работа на алгоритъма
което ще е пропорционално на

87
00:08:37,702 --> 00:08:47,518
броя върнати ключове  плюс логаритъм при основа две от N.  Така,
това е едноизмерно търсене в интервал чрез

88
00:08:47,518 --> 00:08:51,040
двоични дървета за търсене.