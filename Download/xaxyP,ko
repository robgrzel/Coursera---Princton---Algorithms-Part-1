1
00:00:02,000 --> 00:00:07,036
다시 오신 것을 환영합니다. 여기서는 
수학과 과학을 좀 할 겁니다. 많이는 아니지만,

2
00:00:07,036 --> 00:00:11,055
실제로 알고리즘을 써먹으려면 
알고리즘에 대한 성능을 이해할

3
00:00:11,055 --> 00:00:15,075
과학 지식 기반이 필요합니다.
 그래서 오늘은 앞으로

4
00:00:15,275 --> 00:00:20,040
알고리즘의 성능 특성을 살피는 법을 논의할 겁니다.

5
00:00:20,040 --> 00:00:25,022
먼저 이를 위한 수학적 모델을 만드는 방법을 살펴보고,
 실행 시간의 증가도(the order of growth)에 따라

6
00:00:25,022 --> 00:00:30,010
알고리즘을 분류하는 방법을 다룰 겁니다.
 알고리즘의 이론에 대해서도 조금 다루고,

7
00:00:30,010 --> 00:00:35,790
메모리 사용량을 분석하는 방법도 
다루겠습니다. 이런 모든 측면을 고려해

8
00:00:35,790 --> 00:00:42,206
여러 부류의 사람들(characters) 관점에서
 앞에 언급한 주제들을 논의할 예정입니다.

9
00:00:42,206 --> 00:00:48,139
첫 번째 부류는 프로그래머로,
 이들은 문제를 해결할 필요가 있어서

10
00:00:48,139 --> 00:00:54,270
알고리즘이 동작하고 활용되도록 만들어야 합니다.
 두 번째 부류는 클라이언트(client)로,

11
00:00:54,270 --> 00:01:00,167
이들은 사용하려는 프로그램이 무엇이든
 잘 돌아가서 쓸 수 있길 희망합니다.

12
00:01:00,167 --> 00:01:06,424
세 번째 부류는 이론가로, 알고리즘의
 동작 과정을 제대로 이해하려고 합니다. 그리고

13
00:01:06,424 --> 00:01:10,724
마지막은 부류라기 보단 집합(team)인데,
 때때로 이런 기본기(basic blocking and tackling)가

14
00:01:10,724 --> 00:01:15,790
여러분도 잘 알겠지만 일이 잘 되도록 하는데 필요합니다.
 즉 오늘 강의 각 요소가

15
00:01:15,790 --> 00:01:21,110
기본기라 할 수 있습니다.
 그리고 사실 여러분이 학생일 때

16
00:01:21,110 --> 00:01:26,753
언젠가는 이 중 하나 또는 모든 역할을
 스스로가 맡을 거라 생각해야 합니다. 그런 측면에서

17
00:01:26,753 --> 00:01:31,522
이런 다양한 관점을 이해하고 있는 것이 중요합니다.
 이제 우리가 중점적으로 살펴보려는

18
00:01:31,522 --> 00:01:38,205
것은 실행 시간(running time)입니다.
 계산(computation)의 실행 시간을 이해하려는 생각은

19
00:01:38,205 --> 00:01:44,017
찰스 배비지(Babbage) 또는 아마도
 그 이전으로까지 가야 기원을 찾을 수 있습니다.

20
00:01:44,017 --> 00:01:48,083
여기에 배비지의 말을 인용했는데요,
 "해석기관(analytical engine)이 실현되면,

21
00:01:48,083 --> 00:01:54,076
분명 과학을 하는 미래의 과정에 도움이 될 것이다.
 그 도움으로 결과를 도출할 때마다,

22
00:01:54,076 --> 00:02:00,062
이런 질문을 떠올릴 것이다:
 해석기관을 활용한 계산 과정이 어떠해야 그 결과를

23
00:02:00,062 --> 00:02:06,072
최단 시간 내에 그 기계로부터 도출할 수 있을까?"
 해석 기관이라는 배비지의 기계를 살펴보면 알겠지만,

24
00:02:06,072 --> 00:02:12,009
(동작을 위해 회전시켜야 하는) 크랭크가 있죠.
 때문에 문구대로만 보면 계산 한 번 하기 위해

25
00:02:12,009 --> 00:02:17,060
걸리는 시간을 알고자 한 배비지의 걱정은,
 사실은 우리가 크랭크를 몇 회나

26
00:02:17,060 --> 00:02:23,048
돌려야 하는가입니다.
 이 문제는 현대에도 그다지 다르지 않죠.

27
00:02:23,048 --> 00:02:29,018
저 크랭크는 초당 수십억번 명령어를
 처리할 수 있는 어떤 전자기기에 대응합니다.

28
00:02:29,018 --> 00:02:34,041
그럼에도, 우리는 아직도 (특정 알고리즘이)
 어떤 이산 연산을 (초당) 몇 번이나

29
00:02:34,041 --> 00:02:39,093
수행해야 계산 결과를 얻을 수 있는지
 알려고 하고 있습니다. 그러니 알고리즘을 분석할

30
00:02:39,093 --> 00:02:45,032
이유가 충분한 것이죠.
 이런 측면에서 이 수업에서는 앞으로 주로

31
00:02:45,032 --> 00:02:50,051
성능 예측에 관심을 가질 겁니다. 또한 같은 작업을 하는

32
00:02:50,051 --> 00:02:54,768
다른 알고리즘의 성능을 비교할 겁니다.
 이를 통해 그 알고리즘들이 얼마나 잘 수행될지에 대한

33
00:02:54,768 --> 00:03:00,058
어떤 형태의 보장을 할 수 있길 바라는 거죠.
 이와 함께, 알고리즘의 수행 방법에 대한

34
00:03:00,077 --> 00:03:05,780
이론적 기반을 이해하는 것도 합니다.
 그럼에도, 일단, 우리가 알고리즘을 분석하고

35
00:03:06,024 --> 00:03:11,098
알고리즘을 이해하려는 실질적 이유는
 성능에서의 버그(performance bug)를 피하기 위함입니다.

36
00:03:11,098 --> 00:03:16,050
우리가 쓰는 알고리즘이 일을 처리하는데
 일정 시간 내에 할 수 있다는

37
00:03:16,050 --> 00:03:21,084
어떤 확신을 갖길 바라는 거죠.
 현대의 계산용 인프라에서

38
00:03:21,084 --> 00:03:26,080
자주 볼 수 있는 상황은 클라이언트가
 나쁜 성능을 경험하는 것인데,

39
00:03:26,080 --> 00:03:31,026
그 이유를 살펴보면 프로그래머가
 알고리즘의 성능에 관한 특성을

40
00:03:31,026 --> 00:03:36,086
이해하지 못했기 때문입니다. 
따라서 오늘 강의는 그런 상황을 피하기 위한 강의입니다.

41
00:03:36,086 --> 00:03:42,087
이 강좌에서는 이제부터 (알고리즘의) 성능에 관심을 가지고,
 다루는 알고리즘을 비교할 겁니다.

42
00:03:42,087 --> 00:03:48,064
일반적인 컴퓨터 과학 교육과정의 후반부를 살펴보면

43
00:03:48,064 --> 00:03:53,093
알고리즘의 이론적 기반에 대한 정보를
 제공하는 강좌들이 있습니다.

44
00:03:53,093 --> 00:03:59,090
이에 관해서도 후에 이야기할까 해요.
 하지만 중점 사항은 성능을 예측할 수 있는 것이고

45
00:03:59,090 --> 00:04:07,007
이를 바탕으로 알고리즘을 비교하는 겁니다.
 지금껏, 더 좋은 성능을 내는 알고리즘을

46
00:04:07,030 --> 00:04:12,081
성공적으로 설계한 이야기들이 많이 있었습니다.
 그 알고리즘이 아니면

47
00:04:12,081 --> 00:04:19,025
문제를 풀 수 없었던 것이죠. 그 중 몇 개의 예시만 제시할 겁니다.

48
00:04:19,025 --> 00:04:25,346
그 중 처음이자 가장 유명한 알고리즘은
 소위 Fourier Fast Transform (FFT) 알고리즘입니다.

49
00:04:25,346 --> 00:04:32,057
이 알고리즘은 어떤 신호를 N 번 샘플링한 것을
 주기성을 갖는 성분(periodic component)들로 쪼갭니다.

50
00:04:32,057 --> 00:04:38,431
이는 DVD나 JPEG, 이외의 여러 응용의 기반을 이룹니다.

51
00:04:38,431 --> 00:04:44,296
사실 N 제곱번(의 연산량)에 비례하는 시간을
 들여 해낼 수 있는 쉬운 방법도 있습니다.

52
00:04:44,296 --> 00:04:49,080
하지만 FFT 알고리즘은 이를 겨우 N log N 번만에 해냅니다.
 그리고 N log N번과 N제곱번의 차이는

53
00:04:49,080 --> 00:04:55,002
풀 수 있지만 어려운(large) 문제와
 풀 수 없는 문제의 차이에 비견할 수 있습니다.

54
00:04:55,002 --> 00:04:59,078
우리가 활용하는 많은
 디지털 기술 및 디지털 미디어 기술이

55
00:04:59,078 --> 00:05:04,822
이 빠른 알고리즘으로 인해 실현됩니다.

56
00:05:05,051 --> 00:05:11,232
다른 예제는 사실 Andrew Appel 학생,
 지금은 프린스턴 대학교에서

57
00:05:11,232 --> 00:05:16,582
(09년부터 15년까지) 학장을 했던
 Appel 교수가 개발한 것입니다. 학부 졸업 논문으로요.

58
00:05:16,582 --> 00:05:22,725
(고전 역학의 N개 입자간의 상호작용을 다루는)
 N체 시뮬레이션 문제를 위한 빠른 알고리즘입니다.

59
00:05:22,725 --> 00:05:28,548
쉬운 버전의 알고리즘은 N제곱번에 비례하는 시간을 소모합니다.
 하지만 Appel의 알고리즘은 N log N이었어요.

60
00:05:28,548 --> 00:05:33,452
강조하지만, 이를 통해 과학자들이
 매우 큰 N에 대해서도 N체 시뮬레이션을 할 수 있게 되었죠.

61
00:05:33,452 --> 00:05:41,478
이런 개발은 새로운 연구를 가능하게 합니다.
그래서, 음, 우리가 보통 직면하는 과제는

62
00:05:41,478 --> 00:05:47,677
내 프로그램이 실용적으로 요구되는
 큰 입력 (데이터)에 대해서도 문제를 풀 수 있는가죠.

63
00:05:47,677 --> 00:05:52,024
사실, 실무 프로그래머라면 줄곧 이런 문제에 직면합니다.

64
00:05:52,024 --> 00:05:58,001
왜, 왜 내 프로그램은 이렇게 느린가?
 왜 메모리가 부족하지?
 그리고

65
00:05:58,001 --> 00:06:05,000
그 문제에 정말 오랫동안 프로그래머를 괴롭힙니다.
 이 문제를 다루는 인사이트를

66
00:06:05,000 --> 00:06:10,030
1970년대에 (스탠포드 교수인) Donald Knuth가
 제시하길, 알고리즘의 성능을 이해하기 위해

67
00:06:10,030 --> 00:06:16,062
과학적 방법(scientific method)을 사용할 수 있다는 것입니다.
 이를 통해 우주의 새로운 신비를 풀어내진 못하겠지만,

68
00:06:16,062 --> 00:06:23,010
과학적인 방법의 사용을 통해서 컴퓨터를

69
00:06:23,010 --> 00:06:29,042
과학적 방법으로 연구되는 것들처럼 다룰 수 있고,
 이것이 프로그램의 동작 과정을

70
00:06:29,042 --> 00:06:34,008
이해하는 한 방법이 된 겁니다.
 그 상세에 대해 같이 살펴봅시다.

71
00:06:34,209 --> 00:06:39,063
이게 앞에서 과학적 방법이라 말한 것의
 간략한 요약입니다. 이 방법은

72
00:06:39,268 --> 00:06:44,086
두 세기에 걸쳐서 지금까지 성공적으로 활용되왔죠.
 그래서, 우리가 하려는 것은

73
00:06:44,086 --> 00:06:50,008
자연계의 어떤 (본질적) 특징을 관찰하려는 겁니다.
 우리의 경우는 그게

74
00:06:50,008 --> 00:06:54,857
컴퓨터에서 돌아가는 프로그램의 실행 시간인 거죠.
 그러니 이제 어떤 모델 가설을 수립해야죠.

75
00:06:55,049 --> 00:06:59,079
우리의 관찰에 들어맞는(consistent) 모델을요.
 그 모델에 따라 우리는 바라건대

76
00:06:59,079 --> 00:07:04,040
우리의 가설이 충분히 좋아서
 자연계의 어떤 특징을 예측할 수 있게 됩니다.

77
00:07:04,040 --> 00:07:09,031
보통은 문제 (입력)의 크기가 커지거나
 다른 컴퓨터가 주어져도 실행 시간을 예측할 수 있게 되죠.

78
00:07:09,197 --> 00:07:13,097
또한 그 뒤에 더 많은 관찰을 통해
 우리의 예측을 검증해야 하며

79
00:07:13,097 --> 00:07:18,058
그 모델 가설과 관찰 모두에 들어맞아서
 편하게 느낄 때까지 입증해야 합니다.

80
00:07:18,058 --> 00:07:22,077
이것이 우리의 프로그램의 성능을
 이해해서 편해지는 과정입니다.

81
00:07:22,077 --> 00:07:28,056
이제, 과학적 방법의 범위 내에서,
 몇 가지 기본적인 원리를 다룹시다.

82
00:07:28,056 --> 00:07:33,082
첫 번째는 당신이 실험을 할 예정이라면,
 그 실험은 다른 누군가가 그 실험을 해서

83
00:07:33,082 --> 00:07:39,021
같은 결과를 도출할 것이라고
 기대할 수 있는 것이어야 합니다.

84
00:07:39,021 --> 00:07:44,067
또한 가설은 실험을 통해
 그 가설이 틀리는 상황(조차)도 확인할 '수 '있는

85
00:07:44,067 --> 00:07:49,736
구체적인 특성을 가지고 있어야 합니다.
 따라서 가설은 조심스럽게 설립되어야 하며

86
00:07:49,736 --> 00:07:55,433
당연히 그렇게 하려고 노력해야 합니다.
 다시 말하지만, 우리가 연구하려는 자연계의 미래는

87
00:07:55,433 --> 00:08:00,822
자연계에 존재하는 어떤 컴퓨터입니다.
 이는 우리가 다루는 알고리즘을

88
00:08:00,822 --> 00:08:07,049
추상 수준에서 벗어나, 컴퓨터 내에서 전자를 흘러가게 만드는

89
00:08:07,049 --> 00:08:11,083
어떤, 구체적인 물리적인 대상으로 바꾸어주는 역할을 합니다.