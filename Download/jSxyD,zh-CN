1
00:00:01,096 --> 00:00:06,043
欢迎回来。今天我们要讲的是用来实现包、队列和栈等

2
00:00:06,043 --> 00:00:10,096
一些基本数据类型的算法和数据结构。你也许

3
00:00:10,096 --> 00:00:15,038
或多或少知道一些，但今天我们要仔细地讲一讲

4
00:00:15,038 --> 00:00:19,064
在很多应用中，我们需要

5
00:00:19,064 --> 00:00:24,044
维护多个对象的集合，这种操作非常简单。我们可能想要向集合中

6
00:00:24,044 --> 00:00:28,622
加入某个元素，去掉某个元素，以及遍历

7
00:00:28,622 --> 00:00:33,799
集合中的元素并对他们执行某种操作，当然还有

8
00:00:33,799 --> 00:00:39,204
检查集合是否为空。对于大多数操作来说，目的都很明确

9
00:00:39,204 --> 00:00:45,570
关键是当需要去掉一个元素时，去掉哪一个元素呢？处理这类问题

10
00:00:45,570 --> 00:00:51,007
有两个经典基础数据结构，栈和队列。它们的区别就在于

11
00:00:51,007 --> 00:00:57,001
去除元素的选择方式。在栈中，我们取出

12
00:00:57,001 --> 00:01:03,026
最近加入的元素。插入元素对应的术语是入栈（push）

13
00:01:03,026 --> 00:01:09,302
去掉最近加入的元素叫做出栈（pop）。这也叫做

14
00:01:09,302 --> 00:01:15,024
后进先出原则。在队列中，我们关注最先加入队列的元素

15
00:01:15,024 --> 00:01:21,045
为了和栈的操作区分，队列加入元素的操作叫做入队（enqueue）

16
00:01:21,045 --> 00:01:27,015
去除元素的操作叫做出队（dequeue）。这也叫做先入先出原则

17
00:01:27,015 --> 00:01:32,070
今天我们来看如何实现这些操作

18
00:01:32,070 --> 00:01:38,166
我们今天隐含的主题是模块式编程。这也将是

19
00:01:38,166 --> 00:01:42,573
在这门课程我们需要特别遵守的原则

20
00:01:42,573 --> 00:01:46,477
这一原则主要思想是将接口与实现完全分离

21
00:01:46,477 --> 00:01:53,539
比如我们精确定义了一些如栈、队列等数据结构的时候

22
00:01:53,539 --> 00:01:58,530
和数据类型，我们想要的是实现的细节与客户端的

23
00:01:58,530 --> 00:02:03,365
完全分离。客户端可以选择不同的实现

24
00:02:03,365 --> 00:02:08,824
但是客户端代码只能执行基本操作

25
00:02:08,824 --> 00:02:13,600
另一方面，实现部分无法知道客户端需求的细节

26
00:02:13,600 --> 00:02:19,320
它所要做的只是实现这些操作

27
00:02:19,320 --> 00:02:24,617
这样，很多客户端能够共用同一个实现

28
00:02:24,617 --> 00:02:29,466
这使得我们能够用模块式可复用的算法与数据结构库

29
00:02:29,466 --> 00:02:34,684
来构建更复杂的算法和数据结构

30
00:02:34,684 --> 00:02:40,713
也能使我们在必要的时候更关注效率

31
00:02:40,713 --> 00:02:45,973
Java这样的面向对象编程语言使得我们能够使用

32
00:02:45,973 --> 00:02:52,246
这种模块化编程风格，这门课中我们会严格遵守这样的风格

33
00:02:52,246 --> 00:02:59,129
好的，下面我们开始讲栈。栈大家都很熟悉

34
00:02:59,129 --> 00:03:05,321
你们当中很多人可能在编程入门课中已经实现过栈

35
00:03:05,321 --> 00:03:09,948
但我们现在要对栈的实现做一个全面的介绍。先热个身

36
00:03:10,151 --> 00:03:15,729
假设我们有一个字符串的集合。可能很短

37
00:03:15,729 --> 00:03:21,912
也可能很长。我们想要实现对字符串集合的存储

38
00:03:21,912 --> 00:03:26,589
定期取出并返回最后加入的字符串

39
00:03:26,801 --> 00:03:33,094
并检查集合是否为空。那么这就是我们的API。我们有一个创建

40
00:03:33,094 --> 00:03:40,027
空栈的构造函数；一个实现插入操作的，以一个字符串为参数的入栈函数；

41
00:03:40,027 --> 00:03:46,861
一个实现移除操作的出栈函数来返回

42
00:03:46,861 --> 00:03:53,196
最近加入的字符串；以及一个检查为空与否，返回布尔值的函数；

43
00:03:53,196 --> 00:03:59,620
在有些应用中，我们可能还会包括栈大小函数

44
00:03:59,847 --> 00:04:06,241
像往常一样，我们先写一个客户端程序，然后再看实现

45
00:04:06,241 --> 00:04:13,376
这个客户端很简单，从标准输入中获取一些字符串

46
00:04:13,376 --> 00:04:20,917
连字符表示出栈操作。这个客户端读取标准输入

47
00:04:20,917 --> 00:04:27,742
字符串，如果字符串是连字符，客户端将栈顶的

48
00:04:27,742 --> 00:04:34,026
字符串出栈并打印。否则，输入为

49
00:04:34,026 --> 00:04:39,209
不是连字符的字符串时，则将它入栈到栈顶

50
00:04:39,209 --> 00:04:45,436
所以下面这个例子中，输入文件为tobe.txt

51
00:04:45,436 --> 00:04:51,488
客户端将to be or not to几个字符串全部入栈，遇到

52
00:04:51,488 --> 00:04:57,754
这个连字符时将最近入栈的元素to出栈

53
00:04:57,754 --> 00:05:03,757
然后将be置于栈顶。接下来将栈顶元素出栈

54
00:05:03,757 --> 00:05:09,653
现在栈顶元素是be。最近入栈的元素出栈，be和to都已经去掉了

55
00:05:09,653 --> 00:05:15,642
那么被去掉的栈顶元素是not，等等。我们可以用这个很简单的客户端

56
00:05:15,642 --> 00:05:22,444
测试我们的实现。现在，我们来看实现栈的代码

57
00:05:22,444 --> 00:05:28,094
我们要看的第一个实现使用链表。如果你对

58
00:05:28,094 --> 00:05:35,294
链表不熟悉，你需要看第1.3节来复习一下

59
00:05:35,294 --> 00:05:41,710
我们的Java编程入门书里也有讲链表。即使你熟悉

60
00:05:41,710 --> 00:05:46,954
链表，看看这个代码也是很值得的，因为这是我们整个课程中

61
00:05:46,954 --> 00:05:52,420
会用来实现复杂得多的数据结构的代码风格

62
00:05:52,615 --> 00:05:58,449
好，我们想保存一个由节点组成用来存储字符串的链表

63
00:05:58,449 --> 00:06:05,867
节点包含指向链表中下一个元素的引用。实现栈的时候

64
00:06:05,867 --> 00:06:12,320
执行入栈操作时，我们在链表头插入一个新的节点

65
00:06:12,320 --> 00:06:18,802
执行出栈操作时，我们去掉链表头处第一个节点

66
00:06:18,802 --> 00:06:24,943
这就是最近加入的元素。好，我们来看代码

67
00:06:24,943 --> 00:06:31,440
这门课中所有的链式数据结构中

68
00:06:31,440 --> 00:06:37,066
我们使用Java中内部类来实现，这只是

69
00:06:37,066 --> 00:06:41,669
描述我们要操作的节点对象的一种方法

70
00:06:41,669 --> 00:06:48,052
节点对象由一个字符串和指向另一个节点的引用组成。所以，链表的

71
00:06:48,267 --> 00:06:54,594
出栈操作非常容易实现。首先，我们需要

72
00:06:54,594 --> 00:07:00,874
返回链表中第一个元素，所以先将它存在变量item中

73
00:07:00,874 --> 00:07:07,458
然后，要去掉第一个节点，我们只需要将

74
00:07:07,706 --> 00:07:14,904
链表指向第一个元素的指针指向下一个元素

75
00:07:14,904 --> 00:07:20,181
然后第一个节点就等着被垃圾回收处理

76
00:07:20,181 --> 00:07:26,310
最后，返回保存的元素

77
00:07:26,310 --> 00:07:32,065
好，这是出栈操作。入栈操作呢？

78
00:07:32,065 --> 00:07:37,231
我们要在链表头加入新的节点

79
00:07:37,231 --> 00:07:42,778
首先，将指向链表头的指针存起来，oldfirst = first

80
00:07:42,778 --> 00:07:48,021
然后创建新节点，这是我们要插入链表头

81
00:07:48,021 --> 00:07:53,037
的新节点。first = new Node()

82
00:07:53,037 --> 00:07:58,060
这是个实例变量，它的元素就是我们想要插入链表头

83
00:07:58,060 --> 00:08:02,934
的字符串，这个例子中是“not”，它的next指针指向链表oldfirst元素

84
00:08:02,934 --> 00:08:07,640
现在成了链表第二个元素。在这个操作之后

85
00:08:07,640 --> 00:08:12,511
first指向链表头处的元素，链表中的元素依照

86
00:08:12,511 --> 00:08:18,699
入栈时间降序排列。实现入栈操作

87
00:08:18,930 --> 00:08:24,784
只需要四行代码。好，这就是Java写的

88
00:08:24,784 --> 00:08:31,083
用链表实现字符串栈的全部代码

89
00:08:31,083 --> 00:08:38,308
这个类中构造函数不做任何操作

90
00:08:38,308 --> 00:08:44,526
也就不用写构造函数。内部类用来构成链表中的元素

91
00:08:44,526 --> 00:08:50,826
将它写成了内部类，这样我们能够直接访问这些实例变量

92
00:08:51,050 --> 00:08:56,085
栈唯一的实例变量是

93
00:08:56,085 --> 00:09:02,344
链表中第一个节点的引用，初始化为空指针null

94
00:09:02,544 --> 00:09:08,525
isEmpty就是检查链表第一个节点是否为null

95
00:09:08,744 --> 00:09:15,667
入栈函数是我之前ppt中给出的那四行代码

96
00:09:15,667 --> 00:09:20,903
出栈函数是再之前给出的那三行代码

97
00:09:20,903 --> 00:09:26,582
这就是能够为任一个客户端服务的作为栈完美工作的

98
00:09:26,582 --> 00:09:31,848
链表的完整实现。现在，我们分析实现的性能

99
00:09:31,848 --> 00:09:36,880
这样我们就能提供给客户算法数据结构的

100
00:09:36,880 --> 00:09:42,082
性能信息。这个例子中，很容易就能看出每个操作

101
00:09:42,082 --> 00:09:48,050
最坏情况下只需要常数时间。每个操作都只有几个命令

102
00:09:48,050 --> 00:09:53,097
没有循环，这显然是我们很想要的特性

103
00:09:53,097 --> 00:10:00,024
那么空间需求呢？这和机器具体

104
00:10:00,024 --> 00:10:06,578
实现有关。这是个典型Java实现，我们能够对它进行分析

105
00:10:06,578 --> 00:10:13,798
并且很容易能在不同环境中测试这个例子

106
00:10:14,022 --> 00:10:20,727
Java中，每个对象会有16字节的

107
00:10:20,727 --> 00:10:26,490
额外空间，因为有内部类，所以还有8字节的额外空间

108
00:10:26,490 --> 00:10:31,541
在类Node中有两个引用

109
00:10:31,541 --> 00:10:36,892
一个指向字符串，另一个指向Node类

110
00:10:36,892 --> 00:10:41,531
各需要8字节，每个栈节点需要40字节，如果栈大小为N

111
00:10:41,531 --> 00:10:47,584
需要大约40N字节。引用first还会占一些额外空间，对于整个栈

112
00:10:47,584 --> 00:10:53,095
只是很少的额外空间，当N很大时，40N是对空间需求非常接近的估计

113
00:10:53,095 --> 00:10:59,386
这不包括字符串本身的空间，这些空间在客户端上

114
00:10:59,386 --> 00:11:05,378
加上那些信息，就能正确评估这个实现对于不同客户端程序的

115
00:11:05,378 --> 00:11:11,766
资源使用量。链表实现的时间复杂度是常数的

116
00:11:11,766 --> 00:11:18,557
但是栈还有更快的实现，因为有些算法中内循环

117
00:11:18,739 --> 00:11:24,063
中用到了栈，想出更快的实现是很重要的

118
00:11:24,063 --> 00:11:29,904
另一种实现栈的自然的方式是使用数组来储存栈上的元素

119
00:11:29,904 --> 00:11:35,299
我们来看这个。这种在链式结构和数组之间的选择

120
00:11:35,299 --> 00:11:40,616
是很基本的。我们在考虑算法中更复杂的

121
00:11:40,616 --> 00:11:46,189
数据结构时会反复遇到。所以，我们想要

122
00:11:46,189 --> 00:11:51,594
现在栈这种简单情况中确认这一点

123
00:11:51,594 --> 00:11:57,676
为后续更复杂的应用做铺垫。使用数组

124
00:11:57,676 --> 00:12:05,320
我们将栈中N个元素保存在数组中，索引为N的

125
00:12:05,320 --> 00:12:13,564
数组位置对应栈顶的位置，即下一个元素加入的地方。好，要入栈

126
00:12:13,564 --> 00:12:20,006
我们只需要将心元素加入s[N]，要出栈则移除s[N-1]处的元素

127
00:12:20,006 --> 00:12:27,050
并将N减1。那么能看到使用数组一个根本性的缺点

128
00:12:27,300 --> 00:12:32,552
必须事先声明数组的大小，所以栈会有

129
00:12:32,552 --> 00:12:38,174
确定的容量。如果栈上的元素个数比栈的容量多，就

130
00:12:38,174 --> 00:12:44,116
必须处理这个问题。这是数组实现的

131
00:12:44,116 --> 00:12:49,479
所有算法和数据结构必须处理的基本问题

132
00:12:49,664 --> 00:12:55,733
再一次地，我们先考虑简单情形，之后再来处理这个问题

133
00:12:55,733 --> 00:13:03,082
那么，这就是用数组表示栈的完整实现

134
00:13:03,082 --> 00:13:10,266
我们有一个字符串数组的实例变量，以及变量N

135
00:13:10,266 --> 00:13:16,278
它既是栈的大小，又是下一个元素位置的索引

136
00:13:16,278 --> 00:13:22,151
栈中下一个开放的位置。这个类有构造函数，创建那个数组

137
00:13:22,151 --> 00:13:27,539
为了简单表示，我们这个实现中做了个弊

138
00:13:27,539 --> 00:13:32,419
我们先让客户端提供栈的容量，一会再来处理这个问题

139
00:13:32,419 --> 00:13:37,066
个别应用中这也许没有问题，但是在非常多的应用中

140
00:13:37,066 --> 00:13:41,571
这个要求就很不合适，客户端确实不知道

141
00:13:41,571 --> 00:13:47,011
需要多大的栈。有可能客户端需要同时维护很多栈

142
00:13:47,011 --> 00:13:52,124
那些栈在不同时间达到最大容量

143
00:13:52,124 --> 00:13:56,883
还有很多其他因素。所以我们不能作弊

144
00:13:56,883 --> 00:14:03,217
但如果我们已知所需的容量，代码基本上不值一提。检查是否为空即

145
00:14:03,217 --> 00:14:08,573
检查N是否等于0。将元素入栈，我们将元素放在N索引的位置

146
00:14:08,573 --> 00:14:15,003
并将N增加1。这是现在很多编程语言表示使用索引N

147
00:14:15,003 --> 00:14:20,305
并增加1的简洁表示。将元素出栈，我们将索引N减1并用它

148
00:14:20,305 --> 00:14:26,067
返回数组中的元素。每个操作都只需要一行代码

149
00:14:26,067 --> 00:14:31,406
对于有些客户端这是个不错的实现。这是个栈的

150
00:14:31,406 --> 00:14:37,131
数组实现，但是它破坏了API，需要客户端提供容量

151
00:14:37,131 --> 00:14:41,749
怎么来处理这个问题呢？有几点我们没有考虑

152
00:14:41,749 --> 00:14:46,792
如果客户端从空栈中出栈我们没有抛出异常

153
00:14:46,792 --> 00:14:51,433
也许我们应该这么做。对于当客户端入栈过多发生溢出时

154
00:14:51,433 --> 00:14:56,962
我们来讲一个调整大小的方法

155
00:14:57,216 --> 00:15:05,254
这种方法能够让我们为客户端避免溢出。还有一个问题

156
00:15:05,535 --> 00:15:12,539
客户端是否能向数据结构中插入空元素。这种情况中，我们

157
00:15:12,539 --> 00:15:19,026
确实允许客户端插入空元素，但在Java中我们需要操心一个问题

158
00:15:19,026 --> 00:15:25,517
叫做对象游离（loitering）,即在栈的数组

159
00:15:25,517 --> 00:15:31,630
实现中有对象的引用，而我们并没有真正使用它

160
00:15:31,832 --> 00:15:37,300
所以当减小N时，在数组中仍然有我们已经出栈

161
00:15:37,300 --> 00:15:42,990
的对象的指针。尽管我们知道我们不再使用它了，但是Java系统

162
00:15:42,990 --> 00:15:50,054
不知道。所以为了避免这个问题，最有效地使用内存

163
00:15:50,311 --> 00:15:57,028
最好将去除的元素对应的项设为null，这样就不会剩下

164
00:15:57,028 --> 00:16:02,742
旧元素的引用。因为不存在引用了接下来垃圾回收器

165
00:16:02,945 --> 00:16:09,467
会收回那些内存。这个问题比较细节，但是很重要

166
00:16:09,467 --> 00:16:15,049
我们必须在实现中要确保充分利用内存。

167
00:16:15,049 --> 00:16:25,082
处理这个问题