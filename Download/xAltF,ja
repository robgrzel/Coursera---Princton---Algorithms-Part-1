1
00:00:02,215 --> 00:00:06,226
マージソートはソートアルゴリズムの本質的な複雑さを見るのによい機会です。

2
00:00:06,226 --> 00:00:10,091
複雑性と呼ばれるものです。では見ていきましょう。

3
00:00:10,091 --> 00:00:16,011
複雑性とは、特定の問題を解くための、全てのアルゴリズムにおける効率性を

4
00:00:16,011 --> 00:00:21,024
調査する枠組みとなるものです。それは計算複雑性と呼ばれます。

5
00:00:21,024 --> 00:00:26,012
このことを扱う際に、計算モデルというものが必要になります。

6
00:00:26,012 --> 00:00:30,080
アルゴリズムが実行に要する計算です。

7
00:00:30,080 --> 00:00:35,371
ソートはある意味簡単で、やることは

8
00:00:35,371 --> 00:00:40,749
比較回数を数えるコストモデルを使います。複雑性問題で考えると

9
00:00:40,969 --> 00:00:46,463
二つのことだけです。一つは、上限で

10
00:00:46,463 --> 00:00:51,077
問題を解くために「とある」アルゴリズムが要するコストを保証するものです。

11
00:00:51,077 --> 00:00:56,694
すなわち上限であり、問題を解くのにどれだけ困難かを示します。

12
00:00:56,694 --> 00:01:02,564
問題を解くアルゴリズム自体を持っている訳ですから簡単ですね。そしてさらに

13
00:01:02,564 --> 00:01:07,621
下限で、「すべての」アルゴリズムで保証するコストの限界値です。

14
00:01:07,621 --> 00:01:13,566
どのアルゴリズムも、それ以上はできないということです。理想的なのは

15
00:01:13,566 --> 00:01:19,031
上限と下限が同じであることを証明するアルゴリズムを探すことです。

16
00:01:19,031 --> 00:01:24,092
そういうアルゴリズムは、最も良くコストを抑えられるであろうと分かります。

17
00:01:24,092 --> 00:01:30,013
以上のように問題解決することを捉えます。ソートの場合でこれらを見てみましょう。

18
00:01:30,013 --> 00:01:34,348
その計算モデルは決定木と呼ばれるものです。意味することは

19
00:01:34,348 --> 00:01:39,048
やれる事は比較ということです。データにアクセスできる唯一の方法です。

20
00:01:39,048 --> 00:01:43,714
コストモデルは比較回数です。マージソートが

21
00:01:43,714 --> 00:01:48,089
与える上限は、アルゴリズムがソート完了を保証する

22
00:01:48,089 --> 00:01:53,058
 N log N の比較時間です。では下限を見てみましょう。

23
00:01:53,058 --> 00:01:57,522
すべてのデータを見なければならないという言うまでもない下限があります。それは N です。

24
00:01:57,522 --> 00:02:03,807
より正確な下限を捉えて、マージソートが最適かを見てみましょう。

25
00:02:03,807 --> 00:02:10,031
これがソートの下限を証明する基本のアイデアです。３つの

26
00:02:10,031 --> 00:02:17,027
異なる要素 a, b, c があるとしましょう。どのようなアルゴリズムであれ

27
00:02:17,027 --> 00:02:23,262
二つの要素を比較します。a と b とします。そこから

28
00:02:23,262 --> 00:02:28,681
二つのケースがあります。YES かそうでないか。値は全て固有値だとします。

29
00:02:28,681 --> 00:02:33,971
比較するコードがあって、いずれかの片方に行くと

30
00:02:33,971 --> 00:02:39,529
違う比較になります。b より小さければ、次の比較は

31
00:02:39,529 --> 00:02:45,344
b と c です。b が c  より小さいと分かれば、a は b より小さいですから

32
00:02:45,344 --> 00:02:50,910
どんなアルゴリズムであれ、要素は a, b, c の順であると分かります。

33
00:02:50,910 --> 00:02:57,014
もし b <  c で、もう一方に行くとしたら

34
00:02:57,014 --> 00:03:03,069
また別の比較を行ないます。この場合、c が b より小さく

35
00:03:03,069 --> 00:03:09,501
a が c より小さいなら、a, c, b です。

36
00:03:09,501 --> 00:03:15,637
c が a より小さいなら c, a, b です。それら三度の比較は

37
00:03:15,637 --> 00:03:22,172
c は a より小さい、c は b より小さい、a は b より小さいので、c, a, b しかあり得ません。

38
00:03:22,172 --> 00:03:30,604
右側において次の比較は、a < c です。

39
00:03:30,604 --> 00:03:36,527
そして c が a より小さい場合は、さらなる比較は b < c です。この場合

40
00:03:36,527 --> 00:03:42,801
上から下に木を辿り、最大 3 回の比較を行なうことで

41
00:03:42,801 --> 00:03:49,163
異なる 3 つの要素の順番を決定できます。下限の考え方は

42
00:03:49,163 --> 00:03:55,420
N の並び順を決定する最小の比較回数を明確にするというお題を

43
00:03:55,420 --> 00:04:00,524
一般化するということです。木の高さは、今見せましたが

44
00:04:00,524 --> 00:04:05,908
全ての順番を網羅する最悪時の比較回数です。

45
00:04:05,908 --> 00:04:10,882
木のより離れた場所が最悪のケースになるというアルゴリズムです。

46
00:04:10,882 --> 00:04:15,886
入力がなんであれ、木が示すものは、アルゴリズムが要する比較回数の下限です。

47
00:04:15,886 --> 00:04:20,577
あり得る順番のそれぞれの一つだけが葉として最小限に存在しています。

48
00:04:20,737 --> 00:04:25,562
何らかのアルゴリズムに対応する木に、いくつかの順番が見当たらないなら

49
00:04:25,562 --> 00:04:30,662
そのアルゴリズムはソートできません。

50
00:04:30,662 --> 00:04:34,821
すなわち順番の違いを見分けられません。

51
00:04:34,821 --> 00:04:40,342
というわけで、下限の命題を、そのような決定木を使い

52
00:04:40,342 --> 00:04:45,943
比較ベースのソートアルゴリズムは、最悪時に lg(N!) の比較が少なくとも

53
00:04:45,943 --> 00:04:51,033
必要になる事を証明します。スターリングの近似により

54
00:04:51,033 --> 00:04:56,740
log_2(N!) は N log_2 N  に比例することが分かっています。そして証明です。

55
00:04:56,977 --> 00:05:03,236
先のスライドの決定木でやってきたことを一般化します。

56
00:05:03,236 --> 00:05:08,940
配列が N 個の固有値で構成されるとします。

57
00:05:08,940 --> 00:05:14,614
決定木は、あらゆるアルゴリズムが比較シーケンスを完了する性能を示します。

58
00:05:14,614 --> 00:05:21,009
それはアルゴリズムが N の階乗分の並び順から、どれかを決めることです。

59
00:05:21,009 --> 00:05:27,800
決定木は少なくとも N の階乗の端点が必要です。高さ h なら、最大 2^h の

60
00:05:27,802 --> 00:05:34,339
端点数になります。高さ h の最大端点数を持つ木だけが

61
00:05:34,339 --> 00:05:42,385
完全であり、そのような木が持つ端点数は 2^h です。このことが我々に

62
00:05:42,385 --> 00:05:48,228
下限を示します。2^h は端点数より大きいか等しくなければなりません。

63
00:05:48,228 --> 00:05:53,368
端点数は N の階乗より大きいか等しくなければなりません。

64
00:05:53,368 --> 00:05:57,456
このことは決定木の高さは lg(N!)  より大きいか等しいことを暗示し

65
00:05:57,616 --> 00:06:03,233
スターリングの近似 N log N に比例します。それが

66
00:06:03,233 --> 00:06:08,024
ソートにおける複雑性の下限です。上限は N log N に比例すると知っています。

67
00:06:08,024 --> 00:06:13,183
下限は N log N に比例しますので

68
00:06:13,183 --> 00:06:18,877
すなわちマージソートが最適なアルゴリズムであると証明できました。

69
00:06:18,877 --> 00:06:24,093
以上が、アルゴリズムデザインでの最初の目標であり、問題解決に最適なアルゴリズムを見つける事です。

70
00:06:24,093 --> 00:06:30,081
というわけで、これらの結果を踏まえて文脈に落とし込む必要があります。

71
00:06:30,081 --> 00:06:36,097
確かにマージソートは比較回数において最適であることは証明しましたが

72
00:06:36,097 --> 00:06:42,756
容量については最適でないことはすでに分かっています。

73
00:06:43,013 --> 00:06:49,022
マージソートはソート対象の配列サイズの倍の追加容量を使います。

74
00:06:49,022 --> 00:06:54,745
挿入ソートやダンプのような簡単なアルゴリズムは、追加容量はまったく必要としません。

75
00:06:54,745 --> 00:07:00,025
これらの理論的な結果から得たいのは

76
00:07:00,025 --> 00:07:05,047
実装時や実際に問題を解こうとする場合の目安になるものです。

77
00:07:05,047 --> 00:07:10,638
ここにある例、すなわち理論が示すのは

78
00:07:10,638 --> 00:07:16,023
「マージソートより際立って少ない比較回数で済むソートアルゴリズムをデザインしようとしてはならない」

79
00:07:16,023 --> 00:07:20,843
です。半分の N log N 比較回数となっていますが、そのような方法はあるでしょうか？

80
00:07:20,843 --> 00:07:25,713
下限が NO であると示しています。これはとても便利な事です。

81
00:07:25,713 --> 00:07:31,081
それがなければ、あなたはそのようなアルゴリズムを定義しようとするかもしれません。

82
00:07:31,081 --> 00:07:37,148
一方で、N log N の比較、かつ最適容量に抑えるアルゴリズムはあり得ます。

83
00:07:37,148 --> 00:07:43,075
容量と時間のどちらにも最適化されたものです。それは後で見ていきます。

84
00:07:43,299 --> 00:07:48,677
そしてもう一つ、下限は調査対象である特定の計算モデルに対してのものです。

85
00:07:48,677 --> 00:07:54,032
この場合では比較です。含まないかもしれないのは、アルゴリズムが

86
00:07:54,032 --> 00:07:59,038
キーに関してより多くの情報を持っているかどうかです。

87
00:07:59,038 --> 00:08:04,495
入力がほとんど整列済みであることがわかれば、挿入ソートが線形時間で済むことは見ました。

88
00:08:04,495 --> 00:08:09,936
ほとんど整列済みのファイルなどです。あるいは与えられるキーにおいてです。

89
00:08:09,936 --> 00:08:15,735
同値のキーがたくさんあれば、N log N よりも速くソートできます。

90
00:08:15,735 --> 00:08:20,837
そしてキーをどう持つかです。そのような特性をうまく使う方法を見てみましょう。

91
00:08:20,837 --> 00:08:25,965
部分的に整列済みの配列、それは N log N の比較を必要としないかもしれません。

92
00:08:25,965 --> 00:08:31,821
重複するキー、それは N log N の比較は不要かもしれません。

93
00:08:31,821 --> 00:08:37,916
線形時間に落とせると思える多くの状況に遭遇するでしょう。

94
00:08:37,916 --> 00:08:43,652
そして後でやりますが、キーの数値化です。全体のキーを比較するかわりに

95
00:08:43,652 --> 00:08:49,201
数値を用いることで、通常のアプリケーションならより速くソートできます。

96
00:08:49,201 --> 00:08:56,852
計算複雑性はとても便利な方法です。アルゴリズムの特性を理解し

97
00:08:56,852 --> 00:09:05,047
設計を決める際の手助けとなるでしょう。