1
00:00:02,048 --> 00:00:07,034
다시 돌아오신 것을 환영합니다. 오늘은, 모든 종류의 어플리케이션에서

2
00:00:07,034 --> 00:00:12,051
우리가 사용할 수 있는 보다 유연한 데이터구조를 제공하기 위한

3
00:00:12,051 --> 00:00:17,069
아이디어를 일반화하는 분류의 변형인 우선순위 큐에 대하여 알아보겠습니다.
시작에 앞서 API와

4
00:00:17,069 --> 00:00:24,820
몇몇 기본적인 임플리멘테이션에 대하여 살펴 보겠습니다. 일주일 정도 전에, 우리는

5
00:00:24,820 --> 00:00:29,813
자바의 collection과 데이터항목을 삽입하고 삭제하는 기본적인 데이터구조의 개념에 대하여 알아보았습니다.

6
00:00:29,813 --> 00:00:34,900
그리고 데이터구조는 어떠한 데이터항목을 삭제할지에 따라 달라진다는 것을 알아보았습니다.

7
00:00:34,900 --> 00:00:39,863
또 가장 최근에 추가된 데이터항목이 제거되는 후입선출 스택과

8
00:00:39,863 --> 00:00:44,776
가장 추가된지 오래된 데이터항목을 제거하는 큐에 대해서도 생각해 보았습니다.

9
00:00:44,776 --> 00:00:48,643
그 다음, 우리는 무작위나 임의의 데이터항목을 제거하는

10
00:00:48,643 --> 00:00:53,580
무작위 큐 또는 백에 대하여 얘기해 보았습니다. 오늘 우리가 얘기해볼 것은

11
00:00:53,580 --> 00:00:58,247
우선순위 큐라고 불리는 것인데요. 데이터항목들을 집어넣고

12
00:00:58,247 --> 00:01:03,059
제거를 할 때는, 데이터항목들의 전체적인 순서를 고려하여

13
00:01:03,059 --> 00:01:09,044
가장 크거나 작은 데이터항목을 제거하는 방식입니다.

14
00:01:09,044 --> 00:01:15,190
예를 들어 P, Q 그리고 E를 집어넣고 제거를 할 때에는 값이 가장 큰 Q를 제거하고 조금 후

15
00:01:15,190 --> 00:01:21,144
X, A 그리고 M을 삽입하고 제거를 할 때에는 값이 가장 큰 X를 제거합니다. 그리고 P,

16
00:01:21,144 --> 00:01:26,069
L 그리고 E를 삽입하고 조금 이따가, 가장 큰 값의 P를 제거합니다. 이것이 기본적인 구조입니다.

17
00:01:26,069 --> 00:01:32,064
이것이 우선순위 큐에 대한 우리의 정의입니다. 따라서 API는

18
00:01:32,064 --> 00:01:39,719
비교가능한 일반적인 데이터항목들을 원한다는 차이 이외에는 우리의 스택이나 큐 API와 매우 유사합니다.

19
00:01:39,719 --> 00:01:46,919
따라서 class header에 그것을 위한 자바언어가 있습니다.

20
00:01:47,127 --> 00:01:52,785
우리는 일반적인 유형의 키는 키의 비교를 포함한다고 말합니다. 그리고 그것은

21
00:01:52,785 --> 00:01:58,805
키는 반드시 비교가능해야하고 다른 키와 비교할 수 있는 compareTo() 메소드를 가지고 있어야 합니다.

22
00:01:58,805 --> 00:02:06,052
그렇지않으면 생성자가 있는데 사실 상 몇몇 어플리케이션에서는

23
00:02:06,052 --> 00:02:11,872
키의 배열을 인수로 갖는 생성자를 가지고 있는 것이 편리합니다.

24
00:02:11,872 --> 00:02:17,807
그다음 스택에 넣거나 큐에 더하는 것처럼 뭔가를 집어넣는 insert()를 실행하고

25
00:02:17,807 --> 00:02:24,142
그다음 최대값을 삭제합니다. 최소값을 삭제하는 분리된 임플리멘테이션 보통 MinPQ가 있기때문에

26
00:02:24,383 --> 00:02:30,043
혼란을 피하기위해 최소값 삭제를 언급하였습니다.

27
00:02:30,043 --> 00:02:36,284
그다음 isEmpty()를 검사하고 우리는 또한 때때로

28
00:02:36,284 --> 00:02:42,908
콜렉션에서 유용한 가장 큰 키의 값과 크기를 알려주는 추가적인 메소드가 있습니다.

29
00:02:42,908 --> 00:02:49,602
여러분들도 반복적으로 필요로할 수 있지만 지금은 생략하도록 하겠습니다.

30
00:02:49,602 --> 00:02:55,675
정말로 많은 우선순위 큐 어플리케이션들이 있습니다.

31
00:02:55,675 --> 00:03:01,039
데이터 구조로서는 최근에 출현했지만

32
00:03:01,039 --> 00:03:06,508
우선순위 키 개념을 고려하면 보다 쉽게 실행할 수 있는

33
00:03:06,508 --> 00:03:12,314
알고리즘이 많이 있습니다. 우리는 처리하고자하는 데이터들이 있지만

34
00:03:12,314 --> 00:03:16,841
우리는 즉시 그것을 처리할 수 없습니다. 우리는 그것을 어떠한 방법으로 저장해야합니다. 그리고나서

35
00:03:16,841 --> 00:03:22,342
우선순위 큐가 우리에게 말하는 것은 그것을 처리하기 좋은 어떠한 방식으로 조직하자입니다.

36
00:03:22,342 --> 00:03:27,657
그리고 그것은 수많은 다른 어플리케이션들에서 우리가 앞으로 보게 될

37
00:03:27,657 --> 00:03:32,965
포괄적인 알고리즘 디자인 기술과 매우 비슷합니다.

38
00:03:32,965 --> 00:03:38,286
오늘은, 우선순위 큐에 기반한 흥미로운 아이디어인

39
00:03:38,286 --> 00:03:44,500
사건 중심 시뮬레이션에 대하여 얘기해볼건데요.

40
00:03:44,500 --> 00:03:50,126
하지만 그것은 또한 수의 계산에도 사용됩니다. 그리고 데이터압축과 그래프 탐색 그리고

41
00:03:50,126 --> 00:03:56,048
컴퓨터과학과 과학적 컴퓨팅에 유용한 알고리즘에 대해서도 살펴보겠습니다.

42
00:03:56,048 --> 00:04:02,277
그것은 스택과 큐를 개괄하고 모든 종류의 알고리즘을

43
00:04:02,277 --> 00:04:09,783
효과적으로 디자인하는데에 쓸 수 있는 데이터 구조를 제공합니다.

44
00:04:10,046 --> 00:04:18,242
여기에 개념 설명을 도와줄 특별한 클라이언트가 있고

45
00:04:18,518 --> 00:04:26,215
여러분도 알다시피 수십억의 트랜잭션이 있는 웹 상에서

46
00:04:26,215 --> 00:04:32,012
그들은 우리의 데이터 웨어하우스나 프로세서를 통해 어떤 방식으로 스트리밍을 하고 있으며

47
00:04:32,012 --> 00:04:37,616
그리고 매우 막대한 양의 트랜잭션이 있다고 해봅시다. 사실상, 우리는 그들 모두를 저장하는 것도

48
00:04:37,616 --> 00:04:43,299
기대하기 어렵습니다. 가능한 빠르게 오는 엄청난 양의 트랜잭션이 있습니다. 하지만

49
00:04:43,299 --> 00:04:48,825
우리는 가장 큰 것에 관심이 있고 어쩌면 가장 큰 액수의 돈이나,

50
00:04:48,825 --> 00:04:54,559
가장 큰 가격, 또는 일어날 수 있는 어떤 것일 수 있습니다. 우리는 따라서

51
00:04:54,559 --> 00:04:59,581
우리가 저장할 숫자들을 고를 수 있습니다. 나는 천개의 가장 큰 것들을

52
00:04:59,581 --> 00:05:04,986
저장하고자 할 수도 있습니다. 따라서 여러분들은 사기행위를 찾는 신용카드 회사를 상상해볼 수 있습니다.

53
00:05:04,986 --> 00:05:11,016
회사는 가장 큰 트랜잭션들의 기록에 대하여 신경을 쓸 것입니다. 따라서 우리는 아마도

54
00:05:11,016 --> 00:05:16,444
수백만이나 수천개의 그것들을 저장할 수도 있습니다. 따라서 그것이 우리의 파라미터 M이고,

55
00:05:16,444 --> 00:05:21,606
그것은 우리가 저장할 수 있는 숫자이지만 데이터항목의 총합은 저장할 수 없습니다.

56
00:05:21,606 --> 00:05:26,814
이것은 우리가 가지고 있는 모든, 모든 이러한 트랙잭션들에 있는 어떤 테스트 데이터에 불과하고

57
00:05:26,814 --> 00:05:32,653
따라서 우리는 이러한 데이터의 취득이 가능할 것이고 그리고 다시

58
00:05:32,844 --> 00:05:38,610
무한한 데이터의 스트림도 가능할 것입니다. 그러나 우리는 3열을 값으로 하여

59
00:05:38,895 --> 00:05:46,723
[기침] 최고의 다섯개의 값을 계속 추적하고 싶다고 해봅시다. 따라서 우리는

60
00:05:46,723 --> 00:05:52,023
얼마나 많이라는 명령줄 인수를 취하는 TopM이라고 불리는 클라이언트 프로그램을 볼 것이고,

61
00:05:52,023 --> 00:05:58,026
이 경우에는 5가 될 것이고 그리고 나서 그것은 일반적인 입력인 트랜잭션으로부터

62
00:05:58,026 --> 00:06:03,914
값을 취할 것이고 5개의 가장 큰 값을 출력할 것입니다. 따라서 이것은 그렇게 할 수 있는 프로그램을 디자인할 때

63
00:06:03,914 --> 00:06:09,485
우리에게 필요한 우선순위 큐 클라이언트의 표준이 되는 예입니다.

64
00:06:09,485 --> 00:06:17,909
너무 어렵지않은 우선순위 큐 개념과 함께할텐데요. 그래서 앞으로

65
00:06:17,909 --> 00:06:25,799
최소값지향 우선순위 큐를 이용해보도록 하겠습니다. 그것은 [기침]

66
00:06:25,799 --> 00:06:31,420
우리가 최소값을 제거할 수 있을 때 쓸 수 있는 큐이고 범용적인 것일 것이어서

67
00:06:31,420 --> 00:06:35,964
우리는 열에서 계속되는 달러에 의하여 정렬되는 정수적 정렬을 포함하는 이러한 정보를 갖고있는 트랜잭션 타입을 갖게될 것입니다.

68
00:06:36,152 --> 00:06:41,475
따라서 우리는 최소값 우선순위 큐라는 새로운 우선순위 큐를 만들게 될 것이고

69
00:06:41,475 --> 00:06:46,625
또는 우리는 최소값을 제거하는 능력을 갖게 될 것입니다. 그리고나서

70
00:06:46,625 --> 00:06:52,449
우리는 일반적인 입력에서부터 읽습니다. 라인을 읽고, 그 라인의 정보로부터

71
00:06:52,449 --> 00:06:58,920
트랜잭션을 만듭니다. 그리고 그것이 필드를 채울 것이고, 그리고나서 우리는 그 트랜잭션을

72
00:06:58,920 --> 00:07:04,950
우선순위 큐에 집어넣습니다. 만약 우리가 집어넣은 것때문에 우선순위 큐가 M개 이상의 데이터항목을 갖게되면

73
00:07:04,950 --> 00:07:11,075
우리는 그중에서 가장 작은 값을 제거하길 원하고

74
00:07:11,075 --> 00:07:17,193
이러한 방식으로, 가장 큰 M개의 값들을 계속해서 파악할 수 있습니다. 새로운 값을 얻을 떄마다,

75
00:07:17,193 --> 00:07:22,732
거기에 있는 가장 작은 것을 버립니다. 따라서, 이러한 방대한 데이터항목의 스트림이 들어오더라도

76
00:07:22,732 --> 00:07:27,980
우리는 단지 M개의 가장 큰 데이터항목을 파악하는 것이고 그것은

77
00:07:27,980 --> 00:07:34,040
우선순위 큐를 위한 훌륭한 표준적인 클라인언트입니다. 지금부터는 N개의 데이터항목 스트림에서 가장 큰 M개의 데이터항목을 찾는 것을

78
00:07:34,040 --> 00:07:39,081
어떻게 실행을 할 것인지 또는 이러한 문제를 해결할 것인지 또는

79
00:07:39,081 --> 00:07:44,088
이러한 문제를 해결하고 진행할 다양한 방법들을 생각해보도록 하겠습니다. 예를 들면, 여러분들은

80
00:07:44,088 --> 00:07:51,832
그들을 분류하고 마지막에 M개의 값을 찾을 수도 있지만 문제점은

81
00:07:51,832 --> 00:07:57,801
모두를 분류하고 저장할 공간이 우리는 없다는 것입니다.

82
00:07:57,801 --> 00:08:03,280
따라서 분류의 방법은 불가능합니다. 우리는 두가지의 간단한

83
00:08:03,280 --> 00:08:09,082
기본적인 우선순위 큐 임플리멘테이션을 살펴보겠습니다. 여러분들도 아시다시피,

84
00:08:09,082 --> 00:08:14,309
스택과 같은 곳에 데이터항목들을 보관하면 우리가 최소값이나 최대값을 찾을 때에

85
00:08:14,309 --> 00:08:20,425
모든 데이터를 찾아보아야 합니다. 너무 느리죠. M 값이 크고

86
00:08:20,425 --> 00:08:26,099
N이 엄청나면 M<i>N은 매우 느릴 것입니다. 우리가 살펴볼 is</i>는<i></i>

87
00:08:26,099 --> 00:08:31,377
M의 공간과 N log M에 비례하는 시간에 작업을 끝내는 이진 힙이라는 데이터 구조를 이용하는

88
00:08:31,377 --> 00:08:36,838
매우 간단하고 실용적인 임플리멘테이션입니다.

89
00:08:36,838 --> 00:08:42,079
그리고 우리가 이론상으로 할 수 있는 최선에 거의 근접한 방법이고

90
00:08:42,079 --> 00:08:47,010
매우 중요하고 쓸모있으며, 실용적인 임플리멘테이션과 데이터 구조입니다.

91
00:08:47,010 --> 00:08:56,344
전에 제가 주었던 예시 작업들을 이용하여 우선순위 큐를 위한

92
00:08:56,344 --> 00:09:03,894
두 개의 기본적인 임플리멘테이션들에 대하여 개략적으로 설명해보겠습니다.

93
00:09:03,894 --> 00:09:09,361
여러분들은 아이템항목을 링크드 리스트나 더블링 어레이에 저장하거나 단지

94
00:09:09,361 --> 00:09:14,568
들어온 순서로 저장되는 스택에 저장하는 것을 상상해볼 수 있습니다.

95
00:09:14,568 --> 00:09:19,593
그리고 새로운 데이터항목을 배열의 마지막에 넣고 배열의 끝에서부터 제거할 것입니다.

96
00:09:19,593 --> 00:09:25,566
또는 이것을 링크드 리스트에서 할 수 있는데 최대값을 찾거나 제거할 때

97
00:09:25,566 --> 00:09:30,435
여러분들은 최대값을 찾기위하여 전수 조사를 해야만 합니다.

98
00:09:30,629 --> 00:09:37,014
그래서, 이것은 링크드 리스트나 리사이징 배열에서 여러분들이 실행할 수 있는 한가지 방법입니다.

99
00:09:37,014 --> 00:09:42,605
또는 자료들을 순서대로 보관하자고 할 수도 있을 것입니다.

100
00:09:42,605 --> 00:09:48,009
그것은 아마도 새로운 데이터항목을 집어넣을 공간을 찾고 올바른 자리에 넣는

101
00:09:48,009 --> 00:09:53,429
삽입정렬과 같은 작업을 수반하게 될 것입니다. 그리고 다시,

102
00:09:53,429 --> 00:09:59,071
여러분들은 이 작업을 링크드 리스트나 리사이징 배열에서 할 수 있지만, 배열에서는

103
00:09:59,071 --> 00:10:04,568
새로운 데이더항목을 집어넣기 위해 모든 더 큰 값들의 자리를 옮겨야합니다.

104
00:10:04,568 --> 00:10:09,588
우리가 E를 삽입해야 하고 순서대로 보관을 해야한다고 한다면, 우리는 L, M,

105
00:10:09,588 --> 00:10:14,906
P를 옮겨야하고 E를 얻기 위하여 P 그리고 등등을 해야 합니다. 하지만 이것의 이점은 아마도

106
00:10:14,906 --> 00:10:20,682
최대값을 제거하는 것이 쉽다는 것입니다. 우리는 단지 맨 끝의 것을 제거하면 되죠.

107
00:10:20,682 --> 00:10:26,650
Q를 제거하려면 - 우리는 최대값을 제거하려면 맨끝을 제거하면 된다는 것을 압니다. 이 점에서, 그것은 X -

108
00:10:26,650 --> 00:10:32,845
맨끝의 오른쪽, 그리고 P는 맨끝의 오른쪽입니다. 따라서 이 두가지 기본적인 전략들을 이용하여

109
00:10:32,845 --> 00:10:38,971
우선순위 큐들의 실행을 상상해볼 수 있습니다. 많은 코드를 필요로 하지 않죠.

110
00:10:38,971 --> 00:10:45,098
이것은 우선순위 큐의 정렬된 배열 임플리멘테이션이고 꽤

111
00:10:45,098 --> 00:10:52,843
간단합니다. 우리가 클라이언트에게 용량의 제공을 요구할 때 이것을 리사이징 배열에

112
00:10:52,843 --> 00:10:59,282
쉽게 바꿀 수 있습니다.

113
00:10:59,482 --> 00:11:06,243
단지 insert()을 마지막에 넣고, 비정렬된 최대값 삭제는

114
00:11:06,243 --> 00:11:12,334
그것을 정제할 때 최대값을 찾기 위하여 전체 배열을 탐색하여야하고

115
00:11:12,334 --> 00:11:18,583
우리가 스택에서 하는 똑같은 방식으로 마지막의 것을 바꾸고 제거합니다.

116
00:11:18,583 --> 00:11:24,536
이것은 더 적게 사용하고 분류 기법처럼 바꾸어 줍니다.

117
00:11:24,536 --> 00:11:30,179
따라서 이것은 우선순위 큐가 항상 아주 작다면 훌륭한 임플리멘테이션입니다.

118
00:11:30,179 --> 00:11:36,440
그것의 실행 없이도 우리가 일정 시간에 삽입을 할 수 있으나

119
00:11:36,440 --> 00:11:42,949
최대값을 삭제하거나 찾기 위하여 전수조사를 해야하는 불규칙한

120
00:11:42,949 --> 00:11:47,940
배열 임플리멘테이션을 이용한다면 당신은 이 테이블을 이해할 수 있습니다.

121
00:11:47,940 --> 00:11:54,343
만약 우리가 그것을 순서대로 보관한다면, 우리는 일정시간에 최대값을 찾거나

122
00:11:54,343 --> 00:12:00,827
그것을 삭제할 수 있지만 그것은 삽입을 할 때 선형의 시간을 필요로 합니다.

123
00:12:00,827 --> 00:12:07,073
스택과 큐에서의 연산들처럼, 이러한 삽입과 삭제는 임의의 방식으로 섞이고

124
00:12:07,073 --> 00:12:13,329
매우 방대하게 있을 수 있기때문입니다. 이 각각의 것은

125
00:12:13,329 --> 00:12:20,425
연산 횟수의 N배를 해야하기 때문에 매우 매력적입니다.

126
00:12:20,651 --> 00:12:28,096
반면 우리가 바랄 수 있고 성취할 수 있는 것은 모든 연산에서

127
00:12:28,096 --> 00:12:34,936
log N 시간를 얻는 것, 모든 연산에서 log N에 비례하는 시간을 얻는 것입니다. 영리한 데이터

128
00:12:34,936 --> 00:12:41,677
구조와 흥미로운 임플리멘테이션으로 우리는 사실상 그 목표를 이룰 수 있습니다.

129
00:12:41,677 --> 00:12:47,032
그것이 우선순위 큐를 위한 기본 API와 몇몇 기초 임플리멘테이션입니다.