1
00:00:01,096 --> 00:00:06,043
おかえりなさい。今回はいくつかの基本的なデータ構造

2
00:00:06,043 --> 00:00:10,096
バッグ、キュー、そしてスタックの実装についてお話します。

3
00:00:10,096 --> 00:00:15,038
どんなものかは知っているかもしれませんが、今回はこれらを注意深く掘り下げてみましょう。

4
00:00:15,038 --> 00:00:19,064
多くのアプリケーションにおいて、コレクションを扱う機会があります。

5
00:00:19,064 --> 00:00:24,044
操作はとてもシンプルです。何かをコレクションに加えたいとか

6
00:00:24,044 --> 00:00:28,622
何かをコレクションから取り除きたいとか

7
00:00:28,622 --> 00:00:33,799
コレクションの要素を一つづつ取り出して何かしたいとか

8
00:00:33,799 --> 00:00:39,204
そう、もちろん空であるかどうかも。というわけで目的はとてもはっきりしています。

9
00:00:39,204 --> 00:00:45,570
要素を取り除く時に、どの要素を取り除くか？

10
00:00:45,570 --> 00:00:51,007
このための二つの基本的なデータ構造、スタックとキューは

11
00:00:51,007 --> 00:00:57,001
取り除く要素の選択方法が異なります。スタックでは

12
00:00:57,001 --> 00:01:03,026
一番最後に加えた要素を取り出します。専門的な用語で言えば、追加を push（プッシュ）、

13
00:01:03,026 --> 00:01:09,302
最後に追加した要素を取り出すことを pop（ポップ）と言います。

14
00:01:09,302 --> 00:01:15,024
Last-In-First-Out 後入れ先出しで LIFO とも言います。一方、キューでは一番最初に追加した要素を走査します。

15
00:01:15,024 --> 00:01:21,045
区別するために要素を追加することを enqueue（エンキュー）

16
00:01:21,045 --> 00:01:27,015
要素を取り出すことを dequeue（デキュー）と言います。またの名を FIFO、

17
00:01:27,015 --> 00:01:32,070
つまり First-In-First-Out（先入れ先出し） ですね。それでは、これらをどうやって実装するか見て行きましょう。

18
00:01:32,070 --> 00:01:38,166
まずモジュラープログラミングについて話しましょう。

19
00:01:38,166 --> 00:01:42,573
本コースを通じて、後々もこの規律に沿っていきます。

20
00:01:42,573 --> 00:01:46,477
考え方は、インターフェイスと実装を完全に分けるということです。

21
00:01:46,477 --> 00:01:53,539
これからも、スタックやキューのように明確に定義されたデータ構造やデータ型が出てきます。

22
00:01:53,539 --> 00:01:58,530
やりたいことは、どうやって実装しているかの詳細を

23
00:01:58,530 --> 00:02:03,365
クライアントからは分けるということ。クライアントはあらゆる実装が選択できて

24
00:02:03,365 --> 00:02:08,824
なおかつクライアント側のコードは基本操作だけで済むように。

25
00:02:08,824 --> 00:02:13,600
対して実装については、クライアントがやりたいことはわからないので、

26
00:02:13,600 --> 00:02:19,320
こちらで出来る事はそれらの処理を実装することです。

27
00:02:19,320 --> 00:02:24,617
そうすることで、多くのクライアントが同じ実装を再利用できます。

28
00:02:24,617 --> 00:02:29,466
このことは、組み替えや再利用が可能なアルゴリズムとデータ構造のライブラリを作り

29
00:02:29,466 --> 00:02:34,684
さらに複雑なアルゴリズムとデータ構造を組むのに利用できることに繋がります。

30
00:02:34,684 --> 00:02:40,713
場合に応じて、性能を調べることもできます。繰り返すと

31
00:02:40,713 --> 00:02:45,973
これがモジュラープログラミングで、Java のようなオブジェクト指向言語で実現できます。

32
00:02:45,973 --> 00:02:52,246
このやり方に従って、私たちはしっかりと規律を守っていきましょう。

33
00:02:52,246 --> 00:02:59,129
いいでしょう。ではスタックからいきましょう。[cough] スタックは身近で、

34
00:02:59,129 --> 00:03:05,321
プログラミング入門段階でおそらく多くの皆さんが実装したでしょうが

35
00:03:05,321 --> 00:03:09,948
今からは、実装について徹底的に見ていきましょう。手始めに

36
00:03:10,151 --> 00:03:15,729
文字列のコレクションを扱うとしましょう。

37
00:03:15,729 --> 00:03:21,912
そのサイズは小さいかもしれないし、大きいかもしれません。出来ればよいことは

38
00:03:21,912 --> 00:03:26,589
文字列のコレクションを保存できて、最後に追加した文字列を取り除いて、それを一つ一つ返す。

39
00:03:26,801 --> 00:03:33,094
また空であるかも調べることです。というわけで API は

40
00:03:33,094 --> 00:03:40,027
空のスタックを作るコンストラクタと、追加のための push と呼ばれる

41
00:03:40,027 --> 00:03:46,861
一つの文字列を引数にとるメゾッドを持ちます。そして削除のためには pop メゾッドを持ち

42
00:03:46,861 --> 00:03:53,196
一番最後に追加した文字列を返します。空かどうかは Boolean を返します。

43
00:03:53,196 --> 00:03:59,620
いくつかのアプリケーションでは、size メゾッドも含めることになるでしょう。

44
00:03:59,847 --> 00:04:06,241
それではいつものように、最初にクライアントプログラムを読んでから、実装を見ていきましょう。

45
00:04:06,241 --> 00:04:13,376
この簡単なプログラムは、標準入力から文字列を受け取って

46
00:04:13,376 --> 00:04:20,917
ハイフンを pop コマンドとみなします。そう、このプログラムは文字列を

47
00:04:20,917 --> 00:04:27,742
標準入力から読み込んで、もし文字列がハイフンなら

48
00:04:27,742 --> 00:04:34,026
スタックから文字列を pop して表示します。そうではなくて

49
00:04:34,026 --> 00:04:39,209
ハイフンではない文字列なら、単にスタックに push するだけです。

50
00:04:39,209 --> 00:04:45,436
下の方の例は、tobe.txt というファイルがあるとして

51
00:04:45,436 --> 00:04:51,488
プログラムがやることは  "to, be, or, not, to" とスタックに push して

52
00:04:51,488 --> 00:04:57,754
そして次のハイフンが一番最後に追加された要素を pop します。この場合は "to" ですね。

53
00:04:57,754 --> 00:05:03,757
それから "be" をスタックに追加して、それからスタックの先頭要素を pop します。

54
00:05:03,757 --> 00:05:09,653
これは今の "be" ですね。それからまた一番最後に追加された要素を取り出します。"be" そして "to" まで取り出されていますから、

55
00:05:09,653 --> 00:05:15,642
次にくるのは "not" ですね、後も同じように続けます。というわけで、このような簡単なテストプログラムで

56
00:05:15,642 --> 00:05:22,444
実装をテストするのに使えます。ではスタックの実装コードを見てみましょう。

57
00:05:22,444 --> 00:05:28,094
最初に見ていく実装では「連結リスト」を使っています。

58
00:05:28,094 --> 00:05:35,294
連結リストに馴染みがないなら、1.3 章、教則本の 1.3 章ですね。または

59
00:05:35,294 --> 00:05:41,710
我々の提供している書籍 "Introduction To Programming Java" を参照する必要があるでしょう。慣れ親しんでいるにしても

60
00:05:41,710 --> 00:05:46,954
このコードは読むに値します。なぜならば、そのコーディングスタイルは

61
00:05:46,954 --> 00:05:52,420
本コースを通じてもっと複雑なデータ構造で使うことになるからです。

62
00:05:52,615 --> 00:05:58,449
考え方は、連結リストを保持することです。複数ノードで構成され、

63
00:05:58,449 --> 00:06:05,867
ノード毎に文字列を持ち、次の要素をもつノードへの参照を持ちます。

64
00:06:05,867 --> 00:06:12,320
スタックを実装するなら、push 操作では、新しいノードを連結リストの先頭に追加して

65
00:06:12,320 --> 00:06:18,802
pop 操作では連結リストの先頭から最初のノードを取り出す。

66
00:06:18,802 --> 00:06:24,943
つまり一番最後に追加した要素ですね。では、コードがどうなっているか見てみましょう。

67
00:06:24,943 --> 00:06:31,440
本コースを通じて、すべてのリンクするデータ構造において、連結リストを実装することになります。

68
00:06:31,440 --> 00:06:37,066
Java の内部クラスと呼ばれるものを用いて

69
00:06:37,066 --> 00:06:41,669
取り扱うノード内オブジェクトの構成を示しています。

70
00:06:41,669 --> 00:06:48,052
それぞれのノードは文字列と他ノードへの参照を持ちます。つまり

71
00:06:48,267 --> 00:06:54,594
連結リストの pop 操作はとても簡単に実装できます。[cough]  必要なことは

72
00:06:54,594 --> 00:07:00,874
リスト内の先頭要素を返すために、それを退避しておくことが必要です。まず先頭要素を取り出して

73
00:07:00,874 --> 00:07:07,458
変数 item にセットしておきます。それから先頭ノードを取り除きます。

74
00:07:07,706 --> 00:07:14,904
先頭要素を指していたポインタを次の要素に進めるだけです。

75
00:07:14,904 --> 00:07:20,181
それで先頭ノードはガベージコレクタにより回収されるようになります。

76
00:07:20,181 --> 00:07:26,310
そして最後にやることは、退避しておいた要素を返すだけです。いいですね、

77
00:07:26,310 --> 00:07:32,065
これが pop 操作です。push 操作はどうなるでしょうか？ [cough]

78
00:07:32,065 --> 00:07:37,231
連結リストの先頭に新しいノードを追加したいので

79
00:07:37,231 --> 00:07:42,778
まず最初に先頭のポインタを退避します。

80
00:07:42,778 --> 00:07:48,021
"oldfirst = first" の箇所です。それから新しいノードを生成して

81
00:07:48,021 --> 00:07:53,037
リストの先頭に追加します。"first = new Node" の箇所です。

82
00:07:53,037 --> 00:07:58,060
それからインスタンス変数をセットします。item は文字列で

83
00:07:58,060 --> 00:08:02,934
リストの先頭に追加するものですね。このケースでは "not" です。そして next は旧先頭ポインタ、

84
00:08:02,934 --> 00:08:07,640
すなわち二番目の要素になります。この操作後に

85
00:08:07,640 --> 00:08:12,511
first ポインタはリストの先頭を指していますので、リスト内の要素は

86
00:08:12,511 --> 00:08:18,699
スタックに push すると降順となるわけです。これらの４行のコードが

87
00:08:18,930 --> 00:08:24,784
スタックの push の実装になります。それでこれが完全な連結リスト実装の

88
00:08:24,784 --> 00:08:31,083
全てのコードです。Java で文字列スタックのための連結リストを実装しています。

89
00:08:31,083 --> 00:08:38,308
コンストラクタは何もすることはないクラスなので

90
00:08:38,308 --> 00:08:44,526
コンストラクタはありません。この内部クラスは連結リストの要素を組み立てるためのもので

91
00:08:44,526 --> 00:08:50,826
直接インスタンス変数を参照できるように内部クラスにしています。

92
00:08:51,050 --> 00:08:56,085
それで、唯一のスタックのインスタンス変数は

93
00:08:56,085 --> 00:09:02,344
リストの先頭ノードへの参照で、初期値は NULL です。

94
00:09:02,544 --> 00:09:08,525
そして isEmpty は先頭ノードが NULL であるかどうかをチェックします。

95
00:09:08,744 --> 00:09:15,667
push は前のスライドで見せた４行のコードで、pop は

96
00:09:15,667 --> 00:09:20,903
さらに前で見せた３行のコードです。以上が完全な

97
00:09:20,903 --> 00:09:26,582
連結リストの実装で、スタックを扱うあらゆるクライアントプログラムで問題なく動作します。

98
00:09:26,582 --> 00:09:31,848
これで性能を計測できるようになりましたので

99
00:09:31,848 --> 00:09:36,880
どれくらいうまくアルゴリズムとデータ構造が動くのかの情報を利用者に伝える事が出来ます。

100
00:09:36,880 --> 00:09:42,082
今回のケースでは、見ればすぐに分かる通り、全ての操作は

101
00:09:42,082 --> 00:09:48,050
最悪のケースでも定数時間で済みます。それぞれの操作は数行程で

102
00:09:48,050 --> 00:09:53,097
ループ処理もありません。明らかに望ましい特性ですね。

103
00:09:53,097 --> 00:10:00,024
メモリの利用量はどうでしょうか？これに関しては、かなりの面で

104
00:10:00,024 --> 00:10:06,578
マシン毎の実装に依存します。今回は典型的な Java 実装ですので

105
00:10:06,578 --> 00:10:13,798
異なる環境で比較する事はせずに、単にここに書いているケースで検証します。

106
00:10:14,022 --> 00:10:20,727
Java での内部クラスは、どのオブジェクトにも

107
00:10:20,727 --> 00:10:26,490
16 バイトのオーバーヘッドがあります。さらに追加の 8 バイトのオーバーヘッドがあり

108
00:10:26,490 --> 00:10:31,541
それは内部クラスであるためです。それから二つの参照がノードのクラス内にあります。

109
00:10:31,541 --> 00:10:36,892
一つは文字列、もう一つはノードへの参照で、それぞれ

110
00:10:36,892 --> 00:10:41,531
8 バイトです。すなわちスタックのノードあたり 40 バイトで、スタックのサイズを N とするなら

111
00:10:41,531 --> 00:10:47,584
約 40N バイトになります。わずかに先頭ノード参照の分もありますが

112
00:10:47,584 --> 00:10:53,095
スタック自体のオーバーヘッドなので、N が大きければ、40N は必要量の見込値に十分近づきます。

113
00:10:53,095 --> 00:10:59,386
文字列そのものの容量が含まれていませんが、これはクライアントプログラム側が持つものです。

114
00:10:59,386 --> 00:11:05,378
なのですが、本実装ではこのメモリ利用量の求め方で、

115
00:11:05,378 --> 00:11:11,766
異なるクライアントプログラムであっても正しく評価できます。さて、これまでの実装は定数時間の計算量でしたが

116
00:11:11,766 --> 00:11:18,557
より速いスタックの実装があります。スタックはさまざまなアルゴリズムの内部ループで使われますので

117
00:11:18,739 --> 00:11:24,063
より速い実装について考えることはとても重要です。

118
00:11:24,063 --> 00:11:29,904
もう一つのスタック実装の自然な方法は、スタック要素の格納に配列を使うことです。

119
00:11:29,904 --> 00:11:35,299
では見てみましょう。リンク構造と配列のどちらを選択するかは

120
00:11:35,299 --> 00:11:40,616
大事なことです。何度も何度も

121
00:11:40,616 --> 00:11:46,189
もっと複雑なアルゴリズムを考える時に出てきます。

122
00:11:46,189 --> 00:11:51,594
それでは、スタックの簡単なケースで計測してみて

123
00:11:51,594 --> 00:11:57,676
後のより複雑なアプリケーションに備えたいと思います。いいでしょう。配列を使う場合は

124
00:11:57,676 --> 00:12:05,320
配列内のスタックに N 個の要素があることを保持しておきます。N の配列位置は

125
00:12:05,320 --> 00:12:13,564
次の要素を格納する場所、すなわちスタックの先頭です。push するためには

126
00:12:13,564 --> 00:12:20,006
s(N) の位置に新しい要素を追加して、pop するためには s(N) を取り除いて 

127
00:12:20,006 --> 00:12:27,050
N を一つ減らします。さて、配列を使う際に根本的な欠点があります。それは

128
00:12:27,300 --> 00:12:32,552
配列のサイズを事前に決めておく必要がある点で、すなわちスタックは

129
00:12:32,552 --> 00:12:38,174
一定容量になります。そうなると、容量を超える要素がある場合に

130
00:12:38,174 --> 00:12:44,116
なんとかする必要があります。この問題は

131
00:12:44,116 --> 00:12:49,479
あらゆる種類のアルゴリズムとデータ構造で配列を使う時に、避けて通れません。

132
00:12:49,664 --> 00:12:55,733
まずは簡単なケースで考えて、後で片付けましょう。いいでしょう、それでは

133
00:12:55,733 --> 00:13:03,082
これが配列を使ったスタックの全ての実装です。

134
00:13:03,082 --> 00:13:10,266
インスタンス変数は、文字列の配列、そして N は

135
00:13:10,266 --> 00:13:16,278
スタックのサイズと次の配列インデックスを兼ねています。次に空いている

136
00:13:16,278 --> 00:13:22,151
スタックの位置ですね。この実装ではコンストラクタがあり、コンストラクタは

137
00:13:22,151 --> 00:13:27,539
配列を生成します。簡単にするために、これはとりあえずの実装です。

138
00:13:27,539 --> 00:13:32,419
クライアントプログラムからスタック容量を指定してもらえると考えておきましょう。

139
00:13:32,419 --> 00:13:37,066
ちょっとしたアプリケーションならこれでもいいでしょうが、

140
00:13:37,066 --> 00:13:41,571
大規模なアプリケーションでは、複数人がかかわることになります。利用者は

141
00:13:41,571 --> 00:13:47,011
厳密にはスタックの大きさを知る事ができません。多くのスタックを

142
00:13:47,011 --> 00:13:52,124
同時に扱うような場合に、違ったタイミングや様々な原因で、最大容量に達してしまうかもしれません。

143
00:13:52,124 --> 00:13:56,883
このとりあえずの実装は削除する必要がありますので後でやります。

144
00:13:56,883 --> 00:14:03,217
容量が決まっているなら、コードはさしたるものではありません。空かどうかは

145
00:14:03,217 --> 00:14:08,573
N がゼロかどうか調べます。要素を push するには、配列インデックスとして N を使って要素を追加し

146
00:14:08,573 --> 00:14:15,003
N を増やします。この記述は最近の多くのプログラミング言語で使われているショートカットです。

147
00:14:15,003 --> 00:14:20,305
まずインデックスとして使い、その後にインクリメントしています。pop するには、インデックスを減らしてから

148
00:14:20,305 --> 00:14:26,067
そのまま戻り値のインデックスとして使います。それぞれの操作は一行で

149
00:14:26,067 --> 00:14:31,406
誰にとってもわかりやすい実装ですね。以上が配列によるスタックの実装ですが

150
00:14:31,406 --> 00:14:37,131
クライアントプログラムから容量を指定してもらう点が API に則していません。

151
00:14:37,131 --> 00:14:41,749
ではどうすればよいでしょうか？まず、今まで考慮してこなかった事が数点あります。

152
00:14:41,749 --> 00:14:46,792
空のスタックを pop しようとした場合に、例外を投げるコードを書いていませんでしたね。

153
00:14:46,792 --> 00:14:51,433
これはやるべきでしょう。そしてオーバーフローについて

154
00:14:51,433 --> 00:14:56,962
クライアントプログラム次第で起こりますが、これからお話する「可変長」と呼ばれる手法で

155
00:14:57,216 --> 00:15:05,254
オーバーフローは回避できます。さらなる問題に

156
00:15:05,535 --> 00:15:12,539
NULL の要素を追加できるかどうかがあります。今回の実装では

157
00:15:12,539 --> 00:15:19,026
NULL の追加を許可しています。しかし Java において気にかけておく必要があるのは

158
00:15:19,026 --> 00:15:25,517
ロイタリングと呼ばれる物で、オブジェクト参照を

159
00:15:25,517 --> 00:15:31,630
配列による実装やスタック配列に保持しているが、それらを実際には利用していないことを指します。

160
00:15:31,832 --> 00:15:37,300
N 値を減らした時も、スタックから取り出した要素へのポインタは、配列内にまだ残っています。

161
00:15:37,300 --> 00:15:42,990
もう使っていないと分かっていても。Java 側では

162
00:15:42,990 --> 00:15:50,054
そのことは分かりません。これを回避してもっとメモリを効率良く使うには

163
00:15:50,311 --> 00:15:57,028
このようにするのが一番です。 [cough] 取り除いた要素があった配列エントリに NULL をセットすれば

164
00:15:57,028 --> 00:16:02,742
使わなくなった要素への参照はなくなるので、ガベージコレクタは

165
00:16:02,945 --> 00:16:09,467
どこからも参照がないとみなして、メモリを回収できます。細かいですが

166
00:16:09,467 --> 00:16:15,049
注視すべき重要な点です。また実装を確認しておくことで

167
00:16:15,049 --> 00:16:25,082
最大限の効率でメモリを活用できます。