1
00:00:00,000 --> 00:00:04,085
알고리즘 수업에도 잘 돌아오셨습니다. 이번 시간엔, union-find 문제에 대해 다루어봅니다.

2
00:00:04,085 --> 00:00:09,098
이 문제에서 소위 동적 연결성(dynamic connectivity) 문제를 푸는 몇 가지 알고리즘이 있습니다.

3
00:00:09,098 --> 00:00:14,091
우리는 Quick Find/Quick Union이라는 두 개의 고전 알고리즘을 살피고,

4
00:00:14,091 --> 00:00:20,078
이 알고리즘들의 응용사례와 성능 향상법을 살핍니다. 오늘 수업의 의미(subtext)는

5
00:00:20,078 --> 00:00:27,039
유용한 알고리즘을 개발하기 위해 반복해서 따라해야 할 단계들을 보여줍니다.

6
00:00:27,039 --> 00:00:32,039
첫 번째 단계는 문제를 모델링하는 것입니다.

7
00:00:32,039 --> 00:00:37,031
이 단계에서는 풀 필요가 있는 문제의 주요 요소들이 무엇인지를 기본적으로 이해해보세요.

8
00:00:37,031 --> 00:00:41,681
그럼 문제를 풀 몇몇 알고리즘을 떠올릴 수 있습니다. 많은 경우에,

9
00:00:41,681 --> 00:00:46,486
우리가 처음 떠올린 알고리즘은 (그럭저럭 사용하기에) 충분히 빠르고 메모리 문제도 없을 것이라서,

10
00:00:46,486 --> 00:00:52,024
그냥 사용하면 원활히 돌아갑니다 (off and running). 하지만 어떤 경우들엔

11
00:00:52,024 --> 00:00:56,074
빠르지 않거나 메모리가 부족합니다. 따라서 우리의 할 일은

12
00:00:56,074 --> 00:01:01,037
왜 그런지 이해하고, 그 문제를 야기하는 모든것을 찾아내고, 새 알고리즘을 발견해 만족할 때까지 이 과정을 반복해야 합니다.

13
00:01:01,037 --> 00:01:06,051
이러한 방법은 알고리즘을 만들고 분석하는 '과학적 접근 (scientific approach)'인데,

14
00:01:06,051 --> 00:01:11,099
여기서 이렇게 돌아가는 상황을 시도하고 이해하는 수학적 모델을 설계하고,

15
00:01:11,099 --> 00:01:17,061
이러한 수학적 모델을 입증하는 실험을 통하여 더 나은 알고리즘을 만드는 데 도움을 받을 겁니다.

16
00:01:17,061 --> 00:01:22,089
자 이제, 동적 연결성 문제를 논할 건데,

17
00:01:22,089 --> 00:01:29,021
이 문제는 union-find 문제에 대한 추상적인 모델입니다. 아이디어는 다음과 같습니다.

18
00:01:29,021 --> 00:01:33,090
N개의 객체가 모여있다고 합시다. 각각이 무엇인 지는 중요하지 않습니다.

19
00:01:33,090 --> 00:01:39,002
이 N개의 객체에 0부터 (N-1까지) 번호를 붙일 겁니다. 그리고

20
00:01:39,002 --> 00:01:43,082
두 객체 간에 연결을 만들어보려 합니다. 이를 위해 이런 명령어가 있다고 상정해보죠.

21
00:01:43,082 --> 00:01:48,057
"두 객체를 연결(connect)해라."는 식의. 이 명령어는 두 객체가 주어지면,

22
00:01:48,057 --> 00:01:53,093
그 둘에 연결을 만듭니다. 이제 이 문제의 본체는 두

23
00:01:53,093 --> 00:01:59,097
두 객체를 연결하는 경로(path)가 있는지를 답하는 Find 'connected(·,·)'라는 질의(query)를 찾는 겁니다.

24
00:01:59,097 --> 00:02:05,021
예로 화면에 나오듯 10개의 객체가 모여있을 때, 몇 개의 'union(·,·)' (연결하라는) 명령을 생각해보죠.

25
00:02:05,021 --> 00:02:10,278
4와 3, 3과 8, 6과 5, 9와 4, 2와 1을 연결합시다.

26
00:02:10,278 --> 00:02:16,526
이제 0과 7이 연결되어 있는지를 답하는 'connected(0,7)' 질의를 생각해보죠.

27
00:02:16,526 --> 00:02:22,713
자, 이 경우엔 연결이 없으니 '아니오'라고 답해야 합니다. 하지만 8과 9가 연결되어있는지를 묻는다면?

28
00:02:22,713 --> 00:02:28,281
이제는 '예'라고 답해야죠, 8과 9 사이에 직접적인 연결은 없습니다만,

29
00:02:28,281 --> 00:02:33,629
8, 3, 4, 9를 따라서 경로가 있으니까요.

30
00:02:33,629 --> 00:02:39,783
자, 따라서 '주어진 객체 집합에 대해 두 명령어를 정식으로 지원하도록 하는 것'이 우리의 문제입니다.

31
00:02:39,783 --> 00:02:45,444
이제 5, 0을 union하라는 명령을 추가하면,

32
00:02:45,444 --> 00:02:51,026
5와 0 사이에 연결이 생기고, 7과 2도 union하면 둘 사이에 연결이 생기죠.

33
00:02:51,026 --> 00:02:56,744
그리고 6과 1도 연결합시다. 그러면 이제 0과 7이 연결되어있는지를 물으면...,

34
00:02:56,744 --> 00:03:02,836
아, 1과 0에도 연결을 만듭시다. 이건 불필요한 연결입니다만.

35
00:03:02,836 --> 00:03:08,528
이제 0과 7이 연결되어 있는지를 물으면 '예'라고 답해야 합니다.

36
00:03:08,528 --> 00:03:13,858
이게 union 명령과 connected 질의를 섞어진 것이 우리가 풀고자 하는 문제입니다.

37
00:03:13,858 --> 00:03:18,991
수많은 객체가 주어졌을 때 이 명령어들을 정식으로 지원할 수 있어야 합니다.

38
00:03:18,991 --> 00:03:23,833
이제 더 큰 문제를 생각해보죠. 보이듯이 이를 풀기 위해선 효율적인 알고리즘이 필요합니다.

39
00:03:23,833 --> 00:03:28,128
먼저 컴퓨터가 있어야겠죠.

40
00:03:28,128 --> 00:03:33,085
사람이 연결이 있는지를 알아내기엔 꽤나 시간이 필요할테죠.

41
00:03:33,085 --> 00:03:38,205
주어진 그림에는 연결이 있네요.

42
00:03:38,205 --> 00:03:43,805
자, 오늘 살피려고 하는 알고리즘은 두 객체를 연결하는 경로를 답하는 게 아닙니다.

43
00:03:43,805 --> 00:03:48,847
그냥 결로가 있는지에 대해 (예 혹은 아니오로) 답하는 거만 하면 됩니다.

44
00:03:48,847 --> 00:03:53,721
이 강좌의 Part 2에서는 경로를 명확히 찾아니는 알고리즘들을 고려할겁니다.

45
00:03:53,721 --> 00:03:59,220
그 알고리즘들을 위해서는 할 게 많아서 union-find 알고리즘만큼 효율적이진 않습니다.

46
00:03:59,220 --> 00:04:05,972
이제 이 알고리즘의 응용 사례입니다만, 어떠한 객체에라도 이 알고리즘을 적용할 수 있죠.

47
00:04:05,972 --> 00:04:11,906
객체가 픽셀들로 이루어진 사진 파일에 사용할 수도 있겠고,

48
00:04:11,906 --> 00:04:17,444
컴퓨터가 객체인 네트워크에도 사용가능하겠고, 사람을 객체로 간주한 소셜 네트워크에나,

49
00:04:17,444 --> 00:04:23,528
회로 요소를 객체로 간주해 컴퓨터 칩에도 사용가능하겠고, 프로그램에서 추상화된 것들을 객체로 간주해볼 수 있겠죠.

50
00:04:23,528 --> 00:04:29,334
이를테면 프로그램 내의 변수 이름이나, 수학에서 말하는 집합에서의 원소를 객체로 볼 수도 있습니다. 또는 컴포지트 시스템에서 금속재 배치 같은 게 있겠죠.

51
00:04:29,334 --> 00:04:34,802
이런 서로 다른 객체에 대한 타입과 상관없이

52
00:04:34,802 --> 00:04:40,574
프로그래밍 할 때에는 각 객체에 이름을 붙이면 될거고 우린 숫자로 붙이겠습니다.

53
00:04:40,574 --> 00:04:46,810
0에서 N-1까지의 정수로요. 이렇게 시작하는 건 프로그램을 생각할 때 매우 편리한데,

54
00:04:46,810 --> 00:04:53,605
각 객체를 나타내는 정수를 배열의 인덱스로 사용할 수 있으니까요.

55
00:04:53,605 --> 00:05:00,160
이 때문에 각 객체와 관계된 정보에 빨리 접근할 수 있습니다.

56
00:05:00,160 --> 00:05:05,777
또한 union-find 알고리즘과 관련없는 수많은 상세를 숨길 수 있죠.

57
00:05:05,777 --> 00:05:10,444
사실 이렇게 객체명을 0에서 N-1 까지의 숫자에 매핑(mapping;사상)함으로써,

58
00:05:10,444 --> 00:05:14,914
심볼 테이블이나 검색 알고리즘에의 적용도 가능합니다. 이것들은

59
00:05:14,914 --> 00:05:20,300
추후 이 강좌에서 다른 문제들을 푸는 알고리즘과 자료구조를 다룰 때 배우게 될 겁니다.

60
00:05:20,501 --> 00:05:26,316
이제, 앞에서 다룬 '연결'이 만족해야 할 추상적인 몇몇 성질들을 모델링할 필요가 있습니다.

61
00:05:26,316 --> 00:05:33,545
우리가 모델링할 이 성질들은 자연스럽고 직관적입니다.

62
00:05:33,775 --> 00:05:40,563
먼저 우리는 (보통 이산수학 시간에 다루는) 'A가 B에 연결되어 있다(A is connected to B)'라는 표현을 '동치 관계(equivalence relation)'로 가정합니다.

63
00:05:40,563 --> 00:05:47,148
먼저, 모든 객체는 자기 자신에 연결되어 있습니다. 다음으로 이 표현은 반사적(symmetric)입니다. P가 Q에 연결되어 있으면

64
00:05:47,148 --> 00:05:53,205
Q도 P에 연결되어 있습니다. 그리고 대칭적입니다. P가 Q에 연결되어 있고 Q도 R에 연결되어 있으면

65
00:05:53,205 --> 00:05:59,128
P는 R에 연결되어 있습니다. 이런 성질들은 매우 직관적입니다.

66
00:05:59,128 --> 00:06:05,292
아지만 알고리즘을 명확하게 유지하기 위해서는 명확하게 말할 필요가 있습니다.

67
00:06:05,292 --> 00:06:12,452
이제 우리가 객체의 집합과, 연결 요소들(connected components)이라고 불리는 부분집합들로 그 집합을 나누는 연결로 이루어진 동치 관계를 갖습니다.

68
00:06:12,452 --> 00:06:19,172
연결 요소는 상호적으로 연결된 객체들의 최대 집합(maximal set)입니다.

69
00:06:19,172 --> 00:06:25,056
이를테면 여기 이 작은 예에선

70
00:06:25,056 --> 00:06:30,936
세 개의 연결 요소가 있습니다. 0으로만 이루어진 게 하나, 1, 4, 5로 이루어진 게 하나,

71
00:06:30,936 --> 00:06:36,239
나머지 4개 객체로 이루어진 게 하나로 세 개입니다.

72
00:06:36,239 --> 00:06:42,244
이 연결 요소들은 그들 중 어느 두 객체가 연결되어 있으면

73
00:06:42,244 --> 00:06:47,096
그 두 객체와 외부에서 연결된 요소는 그 연결요소 밖엔 없다는 성질을 갖습니다.

74
00:06:47,096 --> 00:06:53,126
이를 연결 요소라 부릅니다. 우리 알고리즘은 연결 요소를 유지함으로써  효율성을 갖습니다.

75
00:06:53,126 --> 00:06:59,319
또한 이러한 지식을 통해 효과적으로 여기서 살펴보고 있는 질의에 답할 수 있게 됩니다.

76
00:06:59,319 --> 00:07:04,949
자 이제, 연산(operation)들을 구현해봅시다.

77
00:07:04,949 --> 00:07:09,840
해야될 건 (지금까지의 지식으로) query와 union 명령을 구현하는 겁니다. 여기서 우린 연결 요소들을 명령이 계속 주어져도 유지할 겁니다.

78
00:07:09,840 --> 00:07:14,449
먼저 find 질의는 동일한 연결 요소에 있는지를 체크하는 것으로 바뀌게 되고,

79
00:07:14,449 --> 00:07:20,243
다음으로 union 명령어는 두 객체를 포함하는 연결 요소들의 합집합으로 연결 요소들을 대체해야 하게 됩니다.

80
00:07:20,243 --> 00:07:25,872
이제 예를 들어, 이와 같은 연결 요소들이 있다고 하고,

81
00:07:25,872 --> 00:07:31,906
union(2,5)라는 명령을 주면, 연결이 되면서 2를 포함한 연결 요소와

82
00:07:31,906 --> 00:07:37,965
5를 포함한 연결 요소를 합칠 필요가 있습니다.

83
00:07:37,965 --> 00:07:44,453
이를 통해 더 큰 연결 요소를 만들게 되고 이제 연결 요소는 3개에서 2개로 줄었습니다.

84
00:07:44,453 --> 00:07:52,821
이런 것들을 하기 위해서 프로그래밍 세계에서는 데이터 타입을 명시해야 합니다.

85
00:07:52,821 --> 00:07:59,122
이는 문제를 풀기 위해 구현할 필요가 있는 메소드들을 명시하는 것도 포함합니다.

86
00:07:59,122 --> 00:08:04,980
우린 전형적인 Java 모델에 따라서,

87
00:08:05,224 --> 00:08:12,425
union과 connected라는 두 메소드를 갖는 UF라는 클래스를 만들 겁니다.

88
00:08:12,425 --> 00:08:19,052
여기서 connected는 boolean 타입을 리턴합니다.
생성자(constructor)는

89
00:08:19,052 --> 00:08:26,030
객체의 수를 받아서 객체의 수에 기반한 자료 구조를 만들게 됩니다.

90
00:08:26,030 --> 00:08:31,089
명심해야할 것은 알고리즘을 설계할 때,

91
00:08:31,089 --> 00:08:37,029
객체의 숫자도 많을 수 있지만 연산의 수도 많을 수 있다는 것입니다.

92
00:08:37,029 --> 00:08:42,076
우리는 이제 매우 많은 수의 union과 connected 연산을 하고 우리의 알고리즘이

93
00:08:42,076 --> 00:08:48,315
그러한 상황에서 효율적이 되도록 만들 겁니다.

94
00:08:48,315 --> 00:08:56,011
이 강좌에서 때때로 주어질 숙제(practice)로,

95
00:08:56,011 --> 00:09:04,029
문제를 깊이 다루기 전에 우리의 API 설계를 체크해보세요.

96
00:09:04,029 --> 00:09:11,050
즉, 우리가 개발한 데이터 타입을 사용한 클라이언트 프로그램을 만들어보세요. 이 예에서는,

97
00:09:11,050 --> 00:09:19,074
클라이언트 프로그램이 표준 입력으로 정보를 받습니다.

98
00:09:19,074 --> 00:09:27,381
먼저 우리가 처리할 객체의 수를 정수로 받고,
일련의 객체명 페어를 받습니다.

99
00:09:27,381 --> 00:09:35,070
그러면 클라이언트 프로그램은 먼저 표준 입력에서 정수를 읽어서

100
00:09:35,070 --> 00:09:42,068
UF 객체를 생성합니다. 그 이후의 표준 입력이 비어있지 않다면,

101
00:09:42,068 --> 00:09:47,089
입력에서 두 정수를 받아서, 두 객체가 연결되어 있지 않다면

102
00:09:47,089 --> 00:09:52,663
둘을 연결시켜서 이를 출력합니다. 연결되어있다면 무시하고요.

103
00:09:52,663 --> 00:09:58,266
이게 우리의 테스트 클라이언트 프로그램이며 이 정도면

104
00:09:58,266 --> 00:10:04,702
우리가 하려는 것을 할 수 있는 적절한 테스트 글라이언트죠.

105
00:10:04,702 --> 00:10:10,348
지금까지 구현하는 데 필요한 연산에 대해 설명했고

106
00:10:10,348 --> 00:10:15,091
이를 실행하는데 필요한 클라이언트 코드를 살펴봤습니다.