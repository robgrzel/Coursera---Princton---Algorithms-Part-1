1
00:00:01,087 --> 00:00:07,024
增长阶数分类实际上是非常重要的

2
00:00:07,024 --> 00:00:13,038
近年来围绕它已经有了海量的研究，我们这里简要讲一讲

3
00:00:13,038 --> 00:00:19,692
实际情况要比上个例子中的要稍微复杂一些

4
00:00:19,692 --> 00:00:25,747
一个问题是不同的输入会让算法的性能

5
00:00:25,747 --> 00:00:31,076
发生剧烈的变化。所以我们经常需要针对不同的输入

6
00:00:31,076 --> 00:00:37,001
从不同的角度来考虑分析算法。运行时间会

7
00:00:37,001 --> 00:00:42,014
介于最好情况与最坏情况之间。最好情况是算法代价的

8
00:00:42,014 --> 00:00:48,008
下界。运行时间总是大于等于它的

9
00:00:48,008 --> 00:00:53,368
最坏情况是最困难的输入

10
00:00:53,368 --> 00:00:58,562
最坏情况的分析结果为我们提供底线，算法运行时间

11
00:00:58,562 --> 00:01:04,327
不会长于最坏情况。很多情况下我们

12
00:01:04,327 --> 00:01:11,078
将输入认为是随机的。我们需要以某种方式对我们

13
00:01:11,078 --> 00:01:17,577
正在处理的问题中的随机进行建模，而很多情况下

14
00:01:17,577 --> 00:01:24,680
我们能够对其建模，即使在输入变化非常大的情况下

15
00:01:24,680 --> 00:01:33,369
也有办法预测性能。比如3-SUM问题中，几乎一直都是一样的

16
00:01:33,617 --> 00:01:39,441
使用近似表示时，算法中唯一的会变化的

17
00:01:39,441 --> 00:01:46,514
就是计数器增加的次数，它在低阶项中

18
00:01:46,514 --> 00:01:53,318
我们的分析中不需要考虑它。二叉查找中，可能有些情况下是常数时间

19
00:01:53,318 --> 00:02:00,553
马上就找到了要找的关键字。我们能够证明平均和

20
00:02:00,553 --> 00:02:08,205
最差情况下都是lg(N)。在另一个例子中会有更大的

21
00:02:08,205 --> 00:02:17,256
浮动。对不同的输入我们有不同类型的分析

22
00:02:17,256 --> 00:02:22,398
但问题是客户要解决的实际问题是什么？

23
00:02:22,398 --> 00:02:28,543
为了理解算法的性能，我们也必须理解

24
00:02:28,543 --> 00:02:33,933
这一点。有两种方法成功地解决了这个问题

25
00:02:33,933 --> 00:02:40,346
其中一种是设计时考虑最坏情况。只要保证

26
00:02:40,346 --> 00:02:45,403
你的算法运行总是很快的，这个非常理想化

27
00:02:45,403 --> 00:02:50,794
如果不能保证最坏情况，那么就考虑随机情况，依靠某种概率条件下

28
00:02:50,794 --> 00:02:55,769
成立的保证。我们讲这门课中两种方法的例子都会看到

29
00:02:55,769 --> 00:03:00,546
对增长阶数的考虑引出

30
00:03:00,546 --> 00:03:06,058
我称作算法理论的讨论

31
00:03:06,058 --> 00:03:12,022
这里我们的目标是我们有一个要解决的问题，比如要解决

32
00:03:12,022 --> 00:03:17,500
3-SUM问题，我们想要知道它有多困难。我们想要找到求解它

33
00:03:17,500 --> 00:03:24,302
的最好的算法。对于这个问题计算机科学家使用的方法是

34
00:03:24,302 --> 00:03:30,091
在分析中试着去掉尽可能多的细节，

35
00:03:30,091 --> 00:03:37,015
将分析做到只差一个常数倍数的精度。这是

36
00:03:37,015 --> 00:03:42,831
增长阶数分析所达到的。我们还想完全忽略掉输入模型

37
00:03:42,831 --> 00:03:48,070
所以我们重点放在针对最坏情况的设计方法。然后我们就能

38
00:03:48,090 --> 00:03:54,372
只用增长阶数来讨论算法性能，而实际上也完全可能

39
00:03:54,372 --> 00:03:59,357
以一种非常严密的方式来分析。利用这种分析方法我们获取了很多

40
00:03:59,357 --> 00:04:04,692
关于求解问题难度的结论。我们的目标是对任意输入

41
00:04:04,692 --> 00:04:11,326
找到最优的算法，使得我们能将运行时间的浮动控制在一个常数之内

42
00:04:11,326 --> 00:04:17,735
因为我们找到了最坏情况并且我们也证明了

43
00:04:17,735 --> 00:04:24,022
没有算法能提供更好的性能保证了。关于这点我会给出几个

44
00:04:24,022 --> 00:04:31,549
简单的例子。为了描述性能的界限，有一些常用的记号

45
00:04:31,549 --> 00:04:39,745
Θ、O和Ω。这里给出了这些记号

46
00:04:40,033 --> 00:04:47,396
的定义。Θ记号就是表示增长阶数的方法

47
00:04:47,396 --> 00:04:53,733
Θ(N^2)就是某个常数乘以N^2的简写。它的

48
00:04:53,733 --> 00:05:00,393
上下界都是常数乘以N^2。这就是我们实际用来对算法分类的记号

49
00:05:00,393 --> 00:05:05,730
接下来是O记号，它是算法性能的上界

50
00:05:05,730 --> 00:05:11,360
比如O(N^2)就表示当N增长时，运行时间小于某个常数乘以N^2

51
00:05:11,360 --> 00:05:17,569
Ω用来表示下界，Ω(N^2)表示当N增长时运行时间比

52
00:05:17,569 --> 00:05:23,694
某个常数乘以N^2大。接下来我们来看是如何使用

53
00:05:23,918 --> 00:05:30,113
这三个记号为算法分类的。用我们的

54
00:05:30,113 --> 00:05:36,725
1-SUM、2-SUM、3-SUM可以很清楚地展示。我们的目标是确定

55
00:05:36,725 --> 00:05:42,829
问题的难度并设计最优的算法

56
00:05:42,829 --> 00:05:48,999
1-SUM问题是数组中是否有0？问题难度的上限

57
00:05:48,999 --> 00:05:54,299
取决于某个特定的算法。比如暴力算法

58
00:05:54,299 --> 00:06:00,049
查看数组中的每一项，就是一种特定的算法

59
00:06:00,049 --> 00:06:06,490
需要O(N)时间表示查看每一个记录需要小于某个

60
00:06:06,490 --> 00:06:12,307
常数乘以N的时间。那么最优算法的运行时间必须是

61
00:06:12,307 --> 00:06:17,616
O(N)，因为特定算法为最优算法的运行时间

62
00:06:17,616 --> 00:06:23,431
提供了上界。而这个例子中也很容易推出

63
00:06:23,431 --> 00:06:29,052
下界，这是没有更好算法的证明。对于1-SUM问题

64
00:06:29,052 --> 00:06:34,536
必须检查数组中所有的项。如果漏掉一个，那个记录

65
00:06:34,536 --> 00:06:40,016
可能就是0。所以这说明最优算法的运行时间必须是

66
00:06:40,016 --> 00:06:46,270
某个常数乘以N，即运行时间是Ω(N)

67
00:06:46,270 --> 00:06:52,287
这个例子中，除去常数，上下界是一样的

68
00:06:52,287 --> 00:06:59,133
那么这就证明了1-SUM问题的暴力算法是最优的

69
00:06:59,133 --> 00:07:05,459
它的运行时间是Θ(N)，既是Ω(N)，也是O(N)。对于这个简单问题

70
00:07:05,459 --> 00:07:11,576
找到最优算法很简单。对于更复杂的问题

71
00:07:11,576 --> 00:07:17,027
确定上下界就更困难了，尤其

72
00:07:17,027 --> 00:07:22,617
吻合的上下界非常难。比如我们看3-SUM问题

73
00:07:22,617 --> 00:07:30,211
先看3-SUM问题的上界，比如我们的暴力算法，证明了

74
00:07:30,211 --> 00:07:37,375
最优算法的运行时间是O(N^3)，但我们找到了更好的

75
00:07:37,375 --> 00:07:43,691
改进算法，它的运行时间是O(N^2 lg N)。这是一个更好的上界

76
00:07:43,691 --> 00:07:49,526
那么下界呢，同样地，我们需要检查每一项，我们可能漏掉一个记录

77
00:07:49,526 --> 00:07:56,274
使得三整数组合为0，这是最优算法的

78
00:07:56,274 --> 00:08:02,304
运行时间是Ω(N)的证明，但是对于3-SUM问题没有人知道一个更高的下界

79
00:08:02,304 --> 00:08:08,280
上界和下界之间就存在间隔。这是个开放问题：

80
00:08:08,280 --> 00:08:14,237
3-SUM算法有最优算法么？我们不知道最优算法是什么

81
00:08:14,237 --> 00:08:20,592
我们甚至不知道是否存在一个运行时间小于O(N^2)的算法

82
00:08:20,592 --> 00:08:27,130
我们也不知道比线性阶更高的下界。这就是算法理论中一个

83
00:08:27,130 --> 00:08:33,181
开放问题的例子。我们不知道求解3-SUM问题的难度

84
00:08:33,181 --> 00:08:40,448
在最近的几十年中这种方法一直非常成功

85
00:08:40,448 --> 00:08:45,958
遇到一个新问题，设计出某个算法，证明它的下界

86
00:08:45,958 --> 00:08:51,679
如果存在间隔，寻找新的能够降低上界的算法

87
00:08:51,679 --> 00:08:56,527
或者寻找提高下界的方法。通常证明非平凡下界

88
00:08:56,527 --> 00:09:02,164
是很困难的。平凡的下界，比如查看每个输入对象

89
00:09:02,164 --> 00:09:07,435
并不难。非平凡下界，比如我们讲并查集问题时

90
00:09:07,435 --> 00:09:13,251
提过的证明就难得多了。在最近几十年中

91
00:09:13,251 --> 00:09:20,081
人们通过研究持续下降的上界来了解问题的

92
00:09:20,081 --> 00:09:26,124
计算难度，得到了很多对于最坏情况更快的算法

93
00:09:26,124 --> 00:09:31,979
对于很多重要的问题找到了最优算法

94
00:09:31,979 --> 00:09:37,944
而很多上下界之间仍有间隔。很多人都投入到这一富有

95
00:09:37,944 --> 00:09:43,617
魅力的研究领域中。在这门课当前的背景下这种分析方法

96
00:09:43,617 --> 00:09:48,770
有一些附加说明。第一个是也许关注最坏情况

97
00:09:48,770 --> 00:09:54,409
有些过度悲观了。我们有要解决的问题，有一些数据

98
00:09:54,409 --> 00:09:59,786
也许并不是最坏情况的数据。工程与科学中的很多领域

99
00:09:59,786 --> 00:10:05,194
都不关注最坏情况。对于这门课最坏的情况可能是

100
00:10:05,194 --> 00:10:10,708
一道闪电劈下来，我们的课程就结束了，所以我们也没有对它做预案

101
00:10:10,708 --> 00:10:16,301
对于算法这也是成立的。也许我们应该专注于理解输入的性质

102
00:10:16,301 --> 00:10:21,252
并针对输入的性质寻找高效的算法

103
00:10:21,252 --> 00:10:26,645
另一个要说明的是真的要预测性能和比较算法时

104
00:10:26,645 --> 00:10:33,210
我们需要比常数因子级误差更准确的分析。所以我们讲了

105
00:10:33,210 --> 00:10:39,719
波浪记号，以及算法理论中使用的Θ、O和Ω记号

106
00:10:39,719 --> 00:10:46,161
实际上算法理论已发表的很多研究中

107
00:10:46,161 --> 00:10:51,608
很多人错把O分析的结果当作了

108
00:10:51,608 --> 00:10:56,964
运行时间的近似模型，其实应该是

109
00:10:56,964 --> 00:11:02,179
问题更好的上界，这是个大错误

110
00:11:02,179 --> 00:11:07,619
这门课中，我们使用波浪记号来表示近似模型

111
00:11:07,619 --> 00:11:12,738
对于某些我们感兴趣特定的量

112
00:11:12,738 --> 00:11:17,766
会给出特定的结果，运行时间中非特异的

113
00:11:17,766 --> 00:11:22,271
常数和机器与系统的性质相关

114
00:11:22,271 --> 00:11:27,542
使用这样的结果我们就能预测并比较

115
00:11:27,542 --> 00:11:29,013
算法的性能