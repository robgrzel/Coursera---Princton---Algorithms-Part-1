1
00:00:02,880 --> 00:00:06,853
欢迎回来 今天我们将讨论平衡搜索树（balance search trees）

2
00:00:06,853 --> 00:00:12,150
它是一种符号表的终极实现方法，它能快速

3
00:00:12,340 --> 00:00:17,130
我们所见过的所有模拟选项。以确定的大小。

4
00:00:17,130 --> 00:00:22,038
所以 让我们先来复习一下符号表

5
00:00:22,255 --> 00:00:27,019
我们来看上次学习过的二叉搜索树

6
00:00:27,236 --> 00:00:32,866
如果对随机产生的数据，符号表会有非常好的性能

7
00:00:33,083 --> 00:00:39,002
符号表以log2（N）的时间复杂度进行搜索和插入操作 并且支持

8
00:00:39,002 --> 00:00:44,055
有序操作（ordered operations）不过我们的实际目标是让这些

9
00:00:44,055 --> 00:00:48,386
操作确保以 log N 的时间复杂度进行

10
00:00:48,603 --> 00:00:54,114
因为我们无法控制操作的顺序，并且它们可能根本不是随机的。

11
00:00:54,114 --> 00:00:57,606
事实上 在很多实际的应用里

12
00:00:57,606 --> 00:01:01,733
它们不怎么随机 所以我们要试着做的就是

13
00:01:01,733 --> 00:01:07,320
找到一种实现方案， 能快速进行

14
00:01:07,320 --> 00:01:09,260
所有符号表操作

15
00:01:09,260 --> 00:01:14,172
那就是我们的挑战 那么我们将要讨论的

16
00:01:14,172 --> 00:01:19,744
是一种事实上非常古老的算法 叫做2-3树以及

17
00:01:19,744 --> 00:01:25,457
一种仅需少量代码的实现方法 叫做左倾

18
00:01:25,457 --> 00:01:31,381
红黑树。之后我们将讨论一种普遍的实现方法叫做B-树

19
00:01:31,381 --> 00:01:36,460
这些方法都广泛地应用在我们的计算机基础设施中

20
00:01:38,500 --> 00:01:45,187
首先 我们来讲2-3树 这个结构

21
00:01:45,406 --> 00:01:50,148
的实现简洁而高效。我们接下来将了解这个特性。

22
00:01:50,148 --> 00:01:56,131
2-3树 是一种基本的二元搜索树（BSTs）的实现方法 它能够我们所需的灵活性

23
00:01:56,131 --> 00:02:00,728
确保快速运行所有操作。并且这个想法其实非常简单

24
00:02:00,728 --> 00:02:06,127
对于每一个节点我们允许一或两个键值  也就是我们允许

25
00:02:06,127 --> 00:02:09,994
一种可以储存两个键值3-节点的存在 

26
00:02:09,994 --> 00:02:15,674
但是却必须有三个子节点  对于一般的二元搜索树节点 也就是2-节点

27
00:02:15,674 --> 00:02:20,190
我们把一个链接给那些比节点中的键值要小的键 另一个链接

28
00:02:20,190 --> 00:02:24,279
给那些大的 而在3-节点中 我们需要三个链接 一个

29
00:02:24,279 --> 00:02:29,867
给小的 一个给中等的 另一个给大的 这些2-3树的另一个性质是

30
00:02:29,867 --> 00:02:35,029
我们将会拥有完美的平衡 也就是说在2-3树中 每一条从起点到空节点的路径

31
00:02:35,029 --> 00:02:38,790
都会有其他相同长度路径

32
00:02:38,790 --> 00:02:46,121
所以 就像我之前说的 2-3树的定义之一就是对称的顺序

33
00:02:46,121 --> 00:02:51,648
每个3-节点有两个都有三条链接和两个键值 左链接指向

34
00:02:51,648 --> 00:02:56,850
指向特比3-节点中较小的那个键值更小的2-3树

35
00:02:56,850 --> 00:03:01,077
中链接指向一个含有两键值之间的2-3树

36
00:03:01,077 --> 00:03:04,459
处于3-节点的两键值大小之间的键值的2-3树

37
00:03:04,459 --> 00:03:09,661
右链接则指向所有含有比3-节点

38
00:03:09,661 --> 00:03:12,913
中的两键值都要大的2-3树

39
00:03:12,913 --> 00:03:17,010
好 那我们来看一个在2-3树中进行搜索的演示

40
00:03:17,010 --> 00:03:23,407
比如说我们这里有个2-3树 我们想搜索是否H是

41
00:03:23,407 --> 00:03:26,818
这个树的其中一个键 那我们从根部开始

42
00:03:26,818 --> 00:03:30,815
比较搜索键和节点中的键值

43
00:03:30,815 --> 00:03:36,436
然后依据键值大小进入根据2-3树定义所得含有被搜索键值的区域

44
00:03:36,436 --> 00:03:41,923
 之后我们递归地继续进行搜索

45
00:03:41,923 --> 00:03:47,409
那么 如果我们要找H 它比M小 所以它唯一有可能存在的地方

46
00:03:47,409 --> 00:03:50,051
就是左链接指向的2-3树

47
00:03:50,051 --> 00:03:54,656
那么我们就取左链 现在 比较 H E J

48
00:03:54,656 --> 00:04:00,359
这时H处于它们中间 所以我们就取中链

49
00:04:00,359 --> 00:04:06,212
那是H唯一有可能在的地方 此时 那个节点，那个单节点2-3树

50
00:04:06,212 --> 00:04:11,315
含有H 所以搜索成功 我们再看看

51
00:04:11,315 --> 00:04:15,217
另一个不成功的搜索 找一个不在树里的键值

52
00:04:15,217 --> 00:04:19,270
像原来一样 我们从根部开始 它小于根节点的键值 所以我们向左走

53
00:04:19,270 --> 00:04:23,383
并且它比这两个键都小 所以如果它在树里 它就肯定

54
00:04:23,383 --> 00:04:26,982
在左链的2-3树 并且它在那两个键值大小之间

55
00:04:26,982 --> 00:04:31,540
所以如果它在树里 它就肯定在接下来的中链的2-3树

56
00:04:31,540 --> 00:04:34,922
但那个中链是空的 所以搜索失败

57
00:04:34,922 --> 00:04:40,951
所以搜索一种对二元搜索树的普遍形式

58
00:04:41,172 --> 00:04:46,675
那么插入呢？ 其实 插入的策略

59
00:04:46,675 --> 00:04:53,502
和普通二项搜索树的插入是相似的 不同的是我们要调整2和3-节点

60
00:04:53,502 --> 00:04:58,964
让树保持完美的平衡 简单的例子就是 一个键

61
00:04:58,964 --> 00:05:04,930
最后落在底部的2节点上， 就像这例子，假设我们要插入K，K比

62
00:05:04,930 --> 00:05:09,762
M小所以我们走左边 K比这两个键都大 所以走右边

63
00:05:09,762 --> 00:05:14,030
K比L小 所以搜索结束在

64
00:05:14,030 --> 00:05:19,219
L的左链 现在要进行插入我们只要

65
00:05:19,219 --> 00:05:23,990
把那个2节点替换成一个含有K的3-节点

66
00:05:23,990 --> 00:05:28,676
现在 K被插入到了2-3树中 并且它遵循了所有的规则

67
00:05:28,886 --> 00:05:34,553
现在如果我们要插入进一个底部的3-节点 我们就要费些力了

68
00:05:34,553 --> 00:05:40,149
具体来说 我们要做的是 把键加入到一个3-节点 建立一个

69
00:05:40,149 --> 00:05:45,955
临时的4-节点 之后拆散这个4-节点并把它的中间键移到

70
00:05:45,955 --> 00:05:48,403
母节点上。好 我们看一个例子

71
00:05:48,613 --> 00:05:54,000
如果我们要将Z插入到这个树中 它比N大 所以我们走右边

72
00:05:54,000 --> 00:05:59,770
它比R大 所以走右边 现在它比X大

73
00:05:59,770 --> 00:06:05,779
而X右侧的链是空的 所以搜索在那里终止 我们

74
00:06:05,779 --> 00:06:11,935
想要把Z插入到那个3-节点中 方法是 首先建立

75
00:06:11,935 --> 00:06:15,820
一个临时的4-节点取代3-节点

76
00:06:15,820 --> 00:06:23,339
这样这就不是个2-3树了因为它现在包含了一个带有三个键和

77
00:06:23,339 --> 00:06:27,705
四个链的4-节点 但我们可以把这个4-节点分解

78
00:06:27,705 --> 00:06:34,436
然后把中间键移到母节点上去 就是分解成两个2-节点然后

79
00:06:34,436 --> 00:06:40,502
把中间键转到母节点 这个操作很神奇 并且

80
00:06:40,502 --> 00:06:45,407
相信我 实际做起来比这里图片上实现要容易

81
00:06:45,407 --> 00:06:50,834
现在你可以看到 那个2-3树局部的转换完成

82
00:06:50,834 --> 00:06:54,366
这个插入 现在如果那个母节点是3-节点 它又

83
00:06:54,366 --> 00:06:59,924
会变成一个临时的4-节点并且会持续向上重复这个过程

84
00:07:00,120 --> 00:07:03,913
刚刚就是在2-3树中搜索和插入的演示了

85
00:07:03,913 --> 00:07:06,660
好 现在咱们看一下刚才那样的两次拆解

86
00:07:06,660 --> 00:07:10,039
例如我们要将L插入这个树

87
00:07:10,039 --> 00:07:16,296
那么它从走中间 最后需要被插入到这个中间的3-节点

88
00:07:16,296 --> 00:07:20,035
所以我们就要把它变成一个

89
00:07:20,394 --> 00:07:23,271
4-节点 现在 L是这个节点的中间键了

90
00:07:23,271 --> 00:07:29,240
所以我们就把这个4-节点分裂成两个2-节点并且把L移到母节点上

91
00:07:30,140 --> 00:07:36,603
4-节点有四个链， 两个2-节点有四个 所以

92
00:07:36,603 --> 00:07:41,506
没有什么要改的了 所以这个对母节点的插入

93
00:07:41,506 --> 00:07:47,510
把它从一个3-节点变成了一个4-节点  重要的是多了一个链接 因为

94
00:07:47,510 --> 00:07:52,666
和之前只是一个3-节点的地方出现分裂而成的两个2-节点

95
00:07:52,666 --> 00:07:56,726
但现在 这就不是一个2-3树了 所以我们还要再次分裂

96
00:07:56,726 --> 00:08:02,269
而且这一回已经没有母节点了 所以我们建立一个新的节点，随后 

97
00:08:02,269 --> 00:08:06,717
这个树的高度就增加了一个节点 这是唯一一次2-3树的高度

98
00:08:06,717 --> 00:08:12,418
会改变 根部分裂的时候树的高度就加一

99
00:08:12,420 --> 00:08:18,477
 那么 这就是对底部3-节点插入的演示 从这个2-3树底部一直进行

100
00:08:18,477 --> 00:08:24,336
到顶端 现在咱们看一看如何建立一个新的2-3树 

101
00:08:24,336 --> 00:08:29,569
由一个最开始是空的树开始 所以如果我们一开始就插入一个键

102
00:08:29,569 --> 00:08:35,170
那么 那就建立了一个包含那个键的2-节点 这是一个规范的2-3树

103
00:08:35,170 --> 00:08:39,076
所以没问题。 现在把E插入 

104
00:08:39,076 --> 00:08:46,003
它将到S的左边 但那是个空链 所以我们需要把

105
00:08:46,003 --> 00:08:50,693
那个2-节点转换成3-节点 对么 并且那也是一个规范的2-3树

106
00:08:50,693 --> 00:08:56,239
所以我们先不把A插入 我们把那个3-节点转换成一个临时的

107
00:08:56,586 --> 00:09:01,993
4-节点 但是之后我们需要分裂这个4-节点并把E挪到母节点上

108
00:09:01,993 --> 00:09:07,817
那样就会建立一个新的根部节点并且增加了树的大小 现在这又是一个

109
00:09:07,817 --> 00:09:12,960
规范的2-3树了所以我们停下来 把R插入进去 它到E的右边

110
00:09:12,960 --> 00:09:15,215
把他转换成3-节点

111
00:09:15,215 --> 00:09:21,562
现在插入C 它到E的左边 必须要和A一起合成一个

112
00:09:21,562 --> 00:09:25,571
 新的3-节点 再一次 这又是一个规范的2-3树所以我们

113
00:09:25,571 --> 00:09:28,327
停下来 现在我们插入H 大概到

114
00:09:28,327 --> 00:09:33,254
E的右边 那个3-节点被转换成一个4-节点

115
00:09:33,254 --> 00:09:38,600
这是一个临时的4-节点 我们分裂它把R挪到母节点

116
00:09:39,384 --> 00:09:44,363
现在这个母节点规范了 我们也没有什么需要做了

117
00:09:44,363 --> 00:09:48,514
我们现在有了一个规范的2-3树 插入X

118
00:09:48,788 --> 00:09:52,173
它比R大 到右边

119
00:09:52,447 --> 00:09:58,120
这是一个2-节点 有地方放X 插入P

120
00:09:58,340 --> 00:10:02,381
它在E和R中间 这个2-节点包含H

121
00:10:02,601 --> 00:10:07,377
右链是空链 所以我们把那个2-节点转换成3-节点

122
00:10:07,377 --> 00:10:12,741
那么现在我们就有一个规范的2-3树了 现在 你可以看到下一个插入

123
00:10:12,741 --> 00:10:16,047
会引起一些分裂

124
00:10:16,268 --> 00:10:19,060
所以插入L 在E和R之间

125
00:10:19,060 --> 00:10:25,231
所以它放到 包含H和P的3-节点 然后我们把它转换成

126
00:10:25,599 --> 00:10:29,420
4-节点 分裂那个4-节点 把L挪到母节点上

127
00:10:29,420 --> 00:10:33,348
现在它是4-节点的母节点 这个4-节点需要被分裂

128
00:10:33,567 --> 00:10:38,951
之后我们建立一个新的根节点 树的高度增加一

129
00:10:38,951 --> 00:10:42,079
这就是一个规范的2-3树 所以我们停下来

130
00:10:42,079 --> 00:10:47,536
所以局部的变换 把2-节点变成3-节点或是

131
00:10:47,536 --> 00:10:52,629
3-节点变4-节点 分裂然后把一个节点上移

132
00:10:52,629 --> 00:10:58,813
这些都是我们平衡搜索树时唯一需要考虑的操作

133
00:10:58,813 --> 00:10:59,900
好了

134
00:10:59,900 --> 00:11:06,326
我之前提到过 这个图表现了 4-节点分裂 和一个2-3

135
00:11:06,326 --> 00:11:11,857
树 这是局部的变换 只涉及改变固定的值

136
00:11:11,857 --> 00:11:16,169
链数 所以在这个例子中 它展示了普遍

137
00:11:16,169 --> 00:11:21,212
情况 在这个被分裂的4-节点是中间链接的时候

138
00:11:21,212 --> 00:11:24,872
但是它在左边或右边时也同样成立

139
00:11:24,872 --> 00:11:28,394
并且那六个次级树可以变得很大

140
00:11:28,394 --> 00:11:33,904
他们有可能包含上百万的键 但具体包含了什么并不重要

141
00:11:33,904 --> 00:11:38,833
我们不改变那些 我们也不改变这个节点之上的任何东西

142
00:11:38,833 --> 00:11:44,415
直到分裂发生 所以分裂b

143
00:11:44,415 --> 00:11:50,096
c,d节点然后把C插入根部3-节点。这个变换只涉及

144
00:11:50,096 --> 00:11:56,795
把那个3-节点转化成一个临时的4-节点 然后把那个4-节点 变成两个2-节点

145
00:11:56,795 --> 00:12:02,758
之后再适当调整各个链接 我们仅需固定数量的操作

146
00:12:02,758 --> 00:12:09,813
这也就是为什么这个操作 总的来说 很高效 那么我们来看看

147
00:12:10,164 --> 00:12:17,640
这些操作所有的一些通用性质

148
00:12:17,872 --> 00:12:24,707
有两点非常重要 在一个2-3树里 我们总会有

149
00:12:24,707 --> 00:12:28,839
对称的顺序 这是我们给

150
00:12:29,085 --> 00:12:32,652
2-节点和3-节点下的定义 这样我们让它也有完美的平衡

151
00:12:32,652 --> 00:12:36,341
从根到底部的距离总是一样的

152
00:12:36,341 --> 00:12:40,891
证明这个 我们需要表明每个变换都维持

153
00:12:40,891 --> 00:12:45,994
对称的次序并有完美平衡 这些就是所有我们可能用上的变换

154
00:12:45,994 --> 00:12:49,868
如果我们分裂根部 那么 这就是

155
00:12:49,868 --> 00:12:54,849
在根部发生的事 如果之前这就是绝对平衡的 那么

156
00:12:54,849 --> 00:12:59,611
之后也会是 并且高度会增加一节 如果母节点原来是2-节点那么

157
00:12:59,611 --> 00:13:04,717
这个变换是个局部的变换 如果你看一下链的位置

158
00:13:04,717 --> 00:13:09,886
就不难发现 通过归纳法 如果之前有绝对平衡 

159
00:13:09,886 --> 00:13:13,996
之后也会有绝对平衡 因为我们没有改变任何关于

160
00:13:13,996 --> 00:13:16,923
那些次级树中的绝对平衡的东西

161
00:13:16,923 --> 00:13:21,344
这在每种情况都成立 如果右边的3-节点和这一个

162
00:13:21,344 --> 00:13:25,391
高一节而那四个矮一节 之后他们都会是一样的

163
00:13:25,391 --> 00:13:29,813
如果之前是绝对平衡 那么之后也是绝对平衡 

164
00:13:29,813 --> 00:13:32,907
因为我们没有改变任何节点的高度

165
00:13:32,907 --> 00:13:35,982
我们只是在节点中局部地移动这些东西

166
00:13:36,174 --> 00:13:40,658
这个是母节点是3-节点的情况 那么这就是一个树的情况

167
00:13:40,658 --> 00:13:44,950
如果我们从左边开始分裂 在中间分裂 且在右边分裂

168
00:13:44,950 --> 00:13:49,452
再一次 把4-节点改成一个2-节点并添加链

169
00:13:49,637 --> 00:13:54,387
如果之前是绝对平衡的 那么之后也会是 因为我们

170
00:13:54,387 --> 00:13:57,780
没有改变树里的关于高度的任何东西

171
00:13:58,027 --> 00:14:04,870
所以我们的操作维持了一个对称的次序 还有2-3树中的绝对平衡

172
00:14:05,092 --> 00:14:10,592
那么 这将给我们一个非常简单的描述性能的方法

173
00:14:10,815 --> 00:14:17,280
调用的指令 或者操作的虚耗与顶到底的路径链数成正比

174
00:14:17,503 --> 00:14:23,003
并且每一条从根部到空链的路径都有一样的

175
00:14:23,003 --> 00:14:25,827
链数 那些路径会有多长呢

176
00:14:25,827 --> 00:14:31,846
嗯 不难看出 在最坏的情况下 如果他们都是2-节点

177
00:14:31,846 --> 00:14:35,860
也就是它们（路径）最长的时候 是以2为底数的log N

178
00:14:35,860 --> 00:14:41,748
现在 如果他们都是3-节点 那就是以3为底数的logN 短了许多

179
00:14:41,748 --> 00:14:47,567
大概是以2为底数的logN的0.63倍 所以 所有在2-3树中有N个节点的

180
00:14:47,567 --> 00:14:53,035
路径长度将会有介于这两个数之间。两个数的差值会很小

181
00:14:53,035 --> 00:14:56,813
数字 对于1百万个节点来说 那就是在十二

182
00:14:56,813 --> 00:15:00,396
和二十之间 并且如果是10亿个节点 那么就是

183
00:15:00,396 --> 00:15:04,952
在18和30之间 这些都是极小的数字 所以

184
00:15:04,952 --> 00:15:09,649
我们将会得到确定的表现 即使是极大的数据库

185
00:15:10,029 --> 00:15:14,561
我们将能保证我们可以得到搜索结果并进行插入

186
00:15:14,561 --> 00:15:17,960
仅用18到30个操作 这其实非常了不起

187
00:15:18,220 --> 00:15:24,686
所以 这就是我们的表格 在我们完成2-3树的

188
00:15:24,686 --> 00:15:27,956
实现后 每一个操作都保证是一个

189
00:15:27,956 --> 00:15:31,524
logN的常数倍 现在这个常数取决于

190
00:15:31,895 --> 00:15:37,693
实现方法 具体到我们应该用怎样的操作来转换

191
00:15:38,362 --> 00:15:44,327
3-节点到4-节点一类的事 但是 从演示和图示中不难发现 

192
00:15:44,327 --> 00:15:48,869
所有操作都将会有恒定的 有保证的对数表现

193
00:15:48,869 --> 00:15:54,483
这当然就是我们在实现符号表的时候

194
00:15:54,483 --> 00:15:57,394
希望看到的 那么怎么实现呢？

195
00:15:57,394 --> 00:16:02,076
其实 我们不会讨论2-3树的直接实现

196
00:16:02,076 --> 00:16:07,354
因为那很复杂 维持多个节点类型是很麻烦的

197
00:16:07,354 --> 00:16:10,580
你可能需要 多重比较才能走到

198
00:16:10,580 --> 00:16:14,814
树的底部 如果有一个3-节点 那就比

199
00:16:14,814 --> 00:16:18,578
2-节点需要更多比较 所以分析起来很复杂

200
00:16:18,780 --> 00:16:23,821
在我们在树中来回上下去处理分裂的同时 必须要时刻注意着

201
00:16:23,821 --> 00:16:28,189
链 有很多很多种情况

202
00:16:28,391 --> 00:16:34,070
我画了所有的情况 无论你是在4-节点中间分裂 还是

203
00:16:34,070 --> 00:16:37,881
在2-节点的右侧 都会有很多情况

204
00:16:37,881 --> 00:16:42,690
所以 你可以那么做但我们不会去做 因为有更简单的方法

205
00:16:42,690 --> 00:16:48,370
所以这就是2-3树 一个 在一定对数时间内实现

206
00:16:48,370 --> 00:16:50,960
平衡树的模型