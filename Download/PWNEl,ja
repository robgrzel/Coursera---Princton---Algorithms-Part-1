1
00:00:01,076 --> 00:00:06,044
次に、ボトムアップ方式のマージソートを見ていきましょう。

2
00:00:06,044 --> 00:00:11,006
マージソートは理解しやすい再帰プログラムです。ボトムアップ方式は

3
00:00:11,006 --> 00:00:16,814
再帰を使いません。これについても理解しコード化するのは簡単です。

4
00:00:16,814 --> 00:00:23,057
基本のアイデアはまず初めに整列済みの

5
00:00:23,057 --> 00:00:28,065
大きさ 1 の子配列の集まりで考える事です。全体通して

6
00:00:28,065 --> 00:00:33,048
これらの大きさ 1 の子配列をペアでマージして、大きさ 2 の子配列を得ます。

7
00:00:33,048 --> 00:00:38,038
配列全体が大きさ 2 の整列済みの子配列で成り立っていることになります。

8
00:00:38,038 --> 00:00:43,059
それからさらに全体通して大きさ 4 となるようにして、それから大きさ 8 と

9
00:00:43,059 --> 00:00:49,036
繰り返します。見て分かるように、この例では最初の二つの

10
00:00:49,036 --> 00:00:55,360
大きさ 1 の子配列をマージして、大きさ 2 の配列 E, M にしています。

11
00:00:55,360 --> 00:01:01,001
整列済みですね。同じ事を次の二つの要素に行い、次々と繰り返し行ないます。

12
00:01:01,001 --> 00:01:06,088
最終的に 16 個の個々の要素が、大きさ 2 の 8 個の整列済み子配列となります。

13
00:01:06,090 --> 00:01:12,012
それから次の走査では、E, M と G, R をマージして

14
00:01:12,012 --> 00:01:17,735
EGMR にします。そして E, S と O, R をマージして、EORS と繰り返します。

15
00:01:17,735 --> 00:01:22,744
大きさ 4 の 4 つの子配列になりました。もう一度走査すると

16
00:01:22,745 --> 00:01:29,304
大きさ 8 の 2 つの子配列になります。最後の走査で全体が整列された配列になります。

17
00:01:29,304 --> 00:01:34,943
配列全体に渡って走査を繰り返し、再帰は全く不要と結論づけられます。

18
00:01:34,943 --> 00:01:41,338
このコード見て分かる通り、とても簡単に書けます。

19
00:01:41,338 --> 00:01:47,442
マージするコードは同じで、階層ループを使います。最初のループは

20
00:01:47,442 --> 00:01:53,373
子配列のサイズ用です。このループは log N 時間で実行できます。

21
00:01:53,373 --> 00:02:00,162
N になるまで、子配列の大きさを倍にしていきますので。

22
00:02:00,449 --> 00:02:07,553
low から low+size-1 を取り出して、次は low+size+size-1 もしくは

23
00:02:07,553 --> 00:02:13,307
配列終端までです。子配列のサイズは sz までないかもしれません。

24
00:02:13,307 --> 00:02:19,397
ソートにおける、完全に製品レベルの高い品質を持つコードです。

25
00:02:19,397 --> 00:02:25,756
通常のマージソート同様、唯一劣る点は

26
00:02:25,756 --> 00:02:31,956
配列サイズに比例した追加容量を使うことです。その点を除けば

27
00:02:31,956 --> 00:02:39,857
マージのためのよい方法です。以上がボトムアップ方式のマージソートです。このトレース図で

28
00:02:39,857 --> 00:02:45,477
どのような感じか分かります。この状態は全くソートされていません。

29
00:02:45,477 --> 00:02:49,712
子配列が 4, 8, 16, 32 とソートされていきます。このケースでは

30
00:02:49,712 --> 00:02:55,320
二つ目の整列済み子配列が小さいですが、このマージ処理では

31
00:02:55,320 --> 00:03:01,225
全く気にすることはありません。大きさが違ってもマージできます。

32
00:03:01,225 --> 00:03:07,106
そして最後に整列済み配列となります。大きさに関わらず、ボトムアップ方式のマージソートは

33
00:03:07,106 --> 00:03:13,833
log N の走査で済みます。それぞれの走査で N 回比較しますので、全体コストは N log N です。