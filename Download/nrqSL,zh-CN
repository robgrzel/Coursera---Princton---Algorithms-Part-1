1
00:00:02,079 --> 00:00:07,071
像上一节中观察发生了什么让我们能够

2
00:00:07,071 --> 00:00:12,075
对性能做出预测，但是并不能帮助我们理解算法做了什么

3
00:00:12,075 --> 00:00:17,056
接下来，我们来看看数学模型，更利于我们把握

4
00:00:17,056 --> 00:00:24,080
到底发生了什么。再提一次，这个概念是

5
00:00:24,080 --> 00:00:33,047
Don Knuth在二十世纪60年代末提出并推广的。那时，计算机系统

6
00:00:33,047 --> 00:00:40,068
才第一次真正变得复杂。而计算机科学家

7
00:00:40,068 --> 00:00:46,015
关心的是我们是否真的能够理解到底发生了什么

8
00:00:46,015 --> 00:00:52,043
Knuth很直接地回答了我们当然能

9
00:00:52,043 --> 00:00:56,884
我们可以通过识别所有的基本操作计算出

10
00:00:57,087 --> 00:01:02,059
程序总的运行时间，计算出操作的开销，计算出

11
00:01:02,059 --> 00:01:07,043
操作执行的频率，并将所有的操作的开销乘以频率求和

12
00:01:07,043 --> 00:01:11,083
你必须分析程序才能决定执行了哪些操作

13
00:01:11,083 --> 00:01:17,004
以及我们之前说过的依赖于计算机和系统的开销

14
00:01:17,004 --> 00:01:22,038
频率分析将我们引向数学因为它依赖于

15
00:01:22,038 --> 00:01:27,369
算法和输入。Knuth写了一系列书，对很多算法

16
00:01:27,369 --> 00:01:34,678
在特定的计算机模型下进行了非常细致和准确的分析

17
00:01:34,678 --> 00:01:39,997
所以从Knuth的工作中可以得知，原则上我们能够获得

18
00:01:39,997 --> 00:01:46,700
算法、程序或者操作的性能的精确数学模型

19
00:01:46,700 --> 00:01:53,156
好，那这个过程是什么样的？额，如果你想运行实验，也是可以的

20
00:01:53,156 --> 00:01:59,044
在很早的时候，我们可能真的会去查计算机手册

21
00:01:59,044 --> 00:02:04,621
每个计算机都配有手册，上面准确地写着每个指令需要多长时间

22
00:02:04,621 --> 00:02:09,589
现在，这个问题变得更复杂了。所以我们运行实验

23
00:02:09,589 --> 00:02:15,079
你可以做十亿次加法然后可能能算出你的计算机上

24
00:02:15,079 --> 00:02:20,432
一次加法需要2.1纳秒。或者你可以执行更复杂的函数

25
00:02:20,432 --> 00:02:25,126
比如计算正弦或者反正切，虽然这已经和算法分析

26
00:02:25,126 --> 00:02:30,644
很接近了。所以，我们办法有确定基本操作

27
00:02:30,644 --> 00:02:38,182
的开销。所以绝大多是情况下我们只要

28
00:02:38,182 --> 00:02:44,137
假定它是某个常数，而且你也能得知那个常数是多少

29
00:02:44,137 --> 00:02:49,477
虽然当我们处理一组对象时，N个对象

30
00:02:49,477 --> 00:02:54,845
有一些操作需要的时间是和N成正比的，比如你要

31
00:02:54,845 --> 00:03:00,591
分配一个大小为N的数组，需要正比于N的时间，因为在Java中

32
00:03:00,591 --> 00:03:06,061
默认把数组中的每个元素初始化为0。其他操作

33
00:03:06,061 --> 00:03:11,951
取决于系统的实现。比如连接字符串是一个重要的操作

34
00:03:11,951 --> 00:03:17,503
如果连接两个字符串，运行时间

35
00:03:17,503 --> 00:03:23,832
与字符串的长度成正比。很多新手使用Java编程时

36
00:03:23,832 --> 00:03:30,713
错把连接字符串当作是常数时间的操作，而实际上并不是

37
00:03:30,713 --> 00:03:39,428
好，这就是每个操作的开销。更有意思的是操作的频率

38
00:03:39,428 --> 00:03:46,229
操作执行的频率。这是3-SUM问题的一个简单

39
00:03:46,229 --> 00:03:50,237
变体，是一个1-SUM问题。有几个数

40
00:03:50,237 --> 00:03:54,333
等于0？多少单个数之和为0？所以这个问题里只有

41
00:03:54,333 --> 00:03:59,111
1个for循环。for循环中我们检查数字是否为0，是的话就把count值

42
00:03:59,111 --> 00:04:05,417
增加1。通过分析代码你会看到i和count必须先声明

43
00:04:05,417 --> 00:04:11,511
然后赋值为0。比较i和N的操作有

44
00:04:11,511 --> 00:04:17,484
N+1个。比较a[i]和0的操作有N个

45
00:04:17,484 --> 00:04:23,985
有N次数组访问。count值增加的次数是可变的

46
00:04:23,985 --> 00:04:30,251
i增加了N次，但是count可能增加了从0到N次之间

47
00:04:30,251 --> 00:04:37,432
任意次数。所以这个次数取决于输入。或者我们需要

48
00:04:37,432 --> 00:04:43,369
模型来描述这个，或者也许有其他的操作开销更大

49
00:04:43,369 --> 00:04:48,289
所以我们不需要操心这个。接下来我们来看一个

50
00:04:48,289 --> 00:04:53,678
更复杂的问题这个程序中执行指令的次数

51
00:04:53,678 --> 00:04:59,039
现在是2-SUM问题。多少个整数对和为0？

52
00:04:59,324 --> 00:05:06,207
这个情况中，你需要做一些计算

53
00:05:06,465 --> 00:05:14,510
i 从 1 变到 N，j 从 i+1 变到 N 我们做的比较的次数

54
00:05:14,510 --> 00:05:21,812
每次if语句对 a[i] 和 a[j] 执行的时候 访问了两次数组

55
00:05:21,812 --> 00:05:28,044
这个if语句执行了第一次循环执行了N-1次

56
00:05:28,044 --> 00:05:34,394
第二次循环执行了N-2次等等。这个次数是

57
00:05:34,637 --> 00:05:40,395
从0到 N-1 的整数之和，这是个简单的离散求和，N(N-1)/2

58
00:05:40,395 --> 00:05:47,383
因为每个if语句访问两次数组所以需要访问 N(N-1) 次

59
00:05:47,383 --> 00:05:54,516
所以我们可以算出这些精确的次数。但这么做已经有点

60
00:05:54,516 --> 00:06:01,465
繁琐了。图灵早就知道了这一点

61
00:06:01,465 --> 00:06:06,921
巴贝奇也知道，我们想要测量计算过程中的工作量

62
00:06:06,921 --> 00:06:12,909
他发现我们并不想列出所有细节

63
00:06:12,909 --> 00:06:18,975
粗略的估计依然很有用。可以对

64
00:06:18,975 --> 00:06:24,920
每个才做的执行次数计数，赋以权重，并

65
00:06:24,920 --> 00:06:32,113
算出精确的值，但也许只需要对开销最大的操作计数就可以了

66
00:06:32,113 --> 00:06:39,614
这就是图灵在1947年提出的。实际上我们现在就是这么做的

67
00:06:39,614 --> 00:06:46,852
所以与其钻到程序里，然后统计每个小细节，我们选出

68
00:06:46,852 --> 00:06:52,856
开销最大的基本操作或者执行次数最多的

69
00:06:53,071 --> 00:06:59,480
用开销最大频率最高的操作来代表

70
00:06:59,480 --> 00:07:05,075
执行时间。一般，我们假设实际的运行时间

71
00:07:05,075 --> 00:07:10,237
就是常数乘以这个操作的执行时间。所以这个例子中，我们

72
00:07:10,237 --> 00:07:15,278
选择访问数组作为代表。这是第一个简化。第二个

73
00:07:15,278 --> 00:07:20,383
简化是忽略推导出的式子中的低阶项

74
00:07:20,383 --> 00:07:26,239
用这种波浪号可以很容易实现

75
00:07:26,481 --> 00:07:33,552
这种简化的思想就是当式子中的N很大时，N^3

76
00:07:33,552 --> 00:07:40,492
N这一项或者 16 要大得多。实际上，大到几乎

77
00:07:40,773 --> 00:07:47,845
注意不到低阶项。所以这些式子近似为

78
00:07:47,853 --> 00:07:54,344
1/6 N^3，这是对这些量很好的近似

79
00:07:54,344 --> 00:08:00,766
所以丢掉这些低阶项极大地简化了计算

80
00:08:00,766 --> 00:08:05,963
所以专注于一种操作，丢掉低阶项

81
00:08:05,963 --> 00:08:11,653
这是波浪号的具体严格定义

82
00:08:11,885 --> 00:08:16,868
F(N)近似为G(N)意味着F(N)/G(N)的极限等于1

83
00:08:16,868 --> 00:08:23,395
你可以检查一下上面这些情况是满足这个定义的

84
00:08:23,395 --> 00:08:30,482
这极大地简化了统计频率。刚才我们将~N^2时选了

85
00:08:30,482 --> 00:08:36,049
一种操作，对2-SUM问题选择增加操作可能会得到另一个N^2近似

86
00:08:36,049 --> 00:08:41,323
好，所以当N很大时，低阶项是可以忽略的

87
00:08:41,323 --> 00:08:46,493
N很小时，低阶项是不能忽略的。不过我们不是很关心

88
00:08:46,493 --> 00:08:51,522
因为我们想要对于大N估计运行时间，小N的运行时间本来就不长

89
00:08:51,522 --> 00:08:57,491
好，我们用了开销模型和

90
00:08:57,491 --> 00:09:04,228
波浪记号，使得我们能简单说这个程序需要近似N^2

91
00:09:04,228 --> 00:09:11,630
次数组访问，并暗示了我们认为运行时间

92
00:09:11,630 --> 00:09:18,362
将近似于常数乘以N^2的假设。好，3-SUM呢？

93
00:09:18,362 --> 00:09:25,618
我们来处理一下这个问题。我们有三重循环

94
00:09:25,618 --> 00:09:32,888
我们需要解决一个更复杂的组合数学问题，但这不难

95
00:09:33,151 --> 00:09:40,710
我们要求的是从N个对象中选出三个的方法

96
00:09:40,963 --> 00:09:48,188
这是个二项式系数。就这样又做了计算，然后应用近似

97
00:09:48,188 --> 00:09:54,284
它近似为1/6 N^3 每个三整数组访问数组三次

98
00:09:54,284 --> 00:10:01,006
那么就是1/2 N^3。我们不会计算所有操作的开销

99
00:10:01,006 --> 00:10:07,581
这太麻烦了。我们选出开销最大的操作乘上频率

100
00:10:07,795 --> 00:10:15,170
并作出近似来试图为运行时间建立一个好模型

101
00:10:15,462 --> 00:10:22,422
这门课中我们不会教完整的离散数学

102
00:10:22,422 --> 00:10:29,101
但有一些我们想要用的离散数学基础知识，它们并不难理解

103
00:10:29,101 --> 00:10:35,245
很多时候我们需要估计一个离散求和

104
00:10:35,245 --> 00:10:40,872
像我们做过的从1到N的求和，或者平方的求和

105
00:10:41,118 --> 00:10:48,044
或者其他比如三重循环这样的。实际上，如果你学过

106
00:10:48,044 --> 00:10:53,351
微积分基础，可以将求和替换为积分

107
00:10:53,351 --> 00:10:58,158
这通常是管用的，我们做一些计算然后应用

108
00:10:58,158 --> 00:11:03,920
欧拉-麦克劳林求和公式来得到真正的近似。如果

109
00:11:03,920 --> 00:11:10,409
你这么考虑就会相信这个式子近似于1/2 N^2

110
00:11:10,409 --> 00:11:16,378
1 、1/2、1/3 一直到 1/N 的和类似于 x 从 1 到 N

111
00:11:16,378 --> 00:11:22,262
对 1/x 积分，等于 N 的自然对数。即使3-SUM问题中的三重循环

112
00:11:22,262 --> 00:11:27,214
如果你熟悉多重积分的话，我直接给出答案，就等于1/6 N^3

113
00:11:27,438 --> 00:11:33,368
求解这些式子还有很多其他的技巧，但是

114
00:11:33,368 --> 00:11:38,774
我们这门课不讲这些，我们有时直接使用这样的结论

115
00:11:38,774 --> 00:11:45,637
好，总的来说，Knuth告诉我们实际上是能获得

116
00:11:45,637 --> 00:11:52,928
精确的数学模型的，我们也确实能得到复杂的式子，我们可能需要

117
00:11:52,928 --> 00:11:59,568
更高级的数学知识，这是理论家擅长的

118
00:11:59,799 --> 00:12:06,565
但对于刚接触算法的人可能并不懂得这些

119
00:12:06,565 --> 00:12:12,338
所以精确的模型最好还是留给那些专家

120
00:12:12,338 --> 00:12:19,079
确实有很多东西值得研究。另一方面近似模型

121
00:12:19,079 --> 00:12:25,087
绝对是有价值的。对于我们涉及的所有算法

122
00:12:25,087 --> 00:12:31,656
我们都会试着用合适的近似模型来描述运行时间

123
00:12:31,656 --> 00:12:38,035
有时我们会给出数学证明，其他时候

124
00:12:38,035 --> 00:12:48,060
我们只是引用专家的工作