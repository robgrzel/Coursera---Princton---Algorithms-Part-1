1
00:00:01,024 --> 00:00:06,048
Перший елементарний метод сортування який ми
будемо розглядати – це простий

2
00:00:06,048 --> 00:00:11,083
метод, відомий як сортування вибором. 
Основна ідея цього алгоритму така, візьмемо

3
00:00:11,083 --> 00:00:17,101
несортований масив і будемо використовувати
ігрові карти як приклад. Під час і-тої ітерації

4
00:00:17,101 --> 00:00:22,867
ми проходимо через масив для того, щоб знайти
найменший елемент, в цьому випадку

5
00:00:22,867 --> 00:00:28,693
2-ка є найменшим. Потім ми обміняємо
її з першим елементом

6
00:00:28,693 --> 00:00:34,199
в масиві, це і буде нашим кроком. Сортування
вибором базується на ідеї

7
00:00:34,199 --> 00:00:39,376
повторення цього кроку. Отже, основою методу
сортування вибором є те, щоб під час

8
00:00:39,376 --> 00:00:44,626
і-тої ітерації знайти найменший елемент з тих, що
залишилися справа від 'і', тобто з індексом,

9
00:00:44,626 --> 00:00:50,252
більшим за індекс 'і', та обміняти його з 'і'. Починаємо
з 'і' з лівого краю масиву

10
00:00:50,252 --> 00:00:55,711
та елементами, що залишилися
справа. При скануванні

11
00:00:55,711 --> 00:01:02,516
знаходимо найменший елемент, 2-ку, третю карту
з кінця, та обмінюємо її з першим елементом.

12
00:01:02,516 --> 00:01:08,889
Це і був наш перший крок. Тепер частина масиву зліва від 'і', вже

13
00:01:08,889 --> 00:01:15,193
відсортована, і ми продовжуємо. Далі найменший
елемент – 3-ка. Обмінюємо її з 'i',

14
00:01:15,193 --> 00:01:21,511
збільшуємо 'i' на 1. Зараз 2-ка та 3-ка стоять
по порядку, і ми продовжуємо. Знаходимо

15
00:01:21,511 --> 00:01:27,958
найменший елемент, 4-ку. Обмінюємо її з 'i',
збільшуємо 'i' на 1. Знаходимо найменший

16
00:01:27,958 --> 00:01:34,712
елемент, 5-ку, обмінюємо її з 'i', збільшуємо 'i' на 1.
Заходимо найменший елемент, обмінюємо

17
00:01:34,712 --> 00:01:40,689
його з 'i', збільшуємо 'i' на 1. Кожний раз коли ми проходимо через елементи,

18
00:01:40,689 --> 00:01:45,788
що залишилися, ми знаходимо найменший елемент.
Коли він знайдений, все, що нам залишається

19
00:01:45,979 --> 00:01:52,898
обміняти дві карти. Це дві основні властивості сортування
вибором. 8-ка найменший елемент,

20
00:01:52,898 --> 00:01:59,486
міняємо її. Тепер ми знаємо, подальші елементи
вже відсортовано, але програма не знає цього, тому

21
00:01:59,486 --> 00:02:06,816
вона має дійти до того, що 'i' = 'n' і
поміняти карту саму на себе, і далі

22
00:02:06,816 --> 00:02:13,226
робить те ж саме для останнього елементу.
Після цього процесу ми знаємо, що весь

23
00:02:13,226 --> 00:02:19,445
масив відсортовано. Тож, один з
способів зрозуміти, як працює

24
00:02:19,445 --> 00:02:24,768
алгоритм – розглянути інваріанти.
У сортуванні вибором маємо

25
00:02:24,768 --> 00:02:30,924
укажчик, нашу змінну 'i', що проходить
по масиву зліва направо.

26
00:02:30,924 --> 00:02:36,345
У цій презентації він зображений
червоною стрілкою.

27
00:02:36,345 --> 00:02:42,235
Наші інваріанти – всі елементи
зліва від стрілки незмінні

28
00:02:42,235 --> 00:02:48,743
і знаходяться у порядку зростання. Справа від стрілки
немає елементу меншого за будь-який

29
00:02:48,743 --> 00:02:54,859
елемент зліва від неї. Це наші початкові
налаштування. Алгоритм

30
00:02:54,859 --> 00:03:00,837
додержується цих інваріантів знаходячи
найменший елемент справа

31
00:03:00,837 --> 00:03:06,827
обмінюючи його з наступним. Отже, код
імплементує інваріанти.

32
00:03:06,827 --> 00:03:12,739
Щоб посунути укажчик, ми збільшуємо 'i' на 1.
Тепер інваріант може бути порушено, тому

33
00:03:12,739 --> 00:03:18,425
ми маємо це виправити. Він може бути
порушений тому, що елемент справа

34
00:03:18,425 --> 00:03:23,812
від укажчика менший за елемент,
на який показує

35
00:03:23,812 --> 00:03:29,143
укажчик. Все, що нам потрібно зробити –
ввести індекс на мінімальному елементі і

36
00:03:29,143 --> 00:03:34,170
обміняти його з 'i'. Коли ж ми його обміняємо,
наш інваріант буде збережено.

37
00:03:34,170 --> 00:03:38,846
Після цього жодний елемент зліва від
укажчика не буде змінюватися.

38
00:03:38,846 --> 00:03:44,536
і жоден елемент справа не буде
меншим за укажчик. З цього

39
00:03:44,768 --> 00:03:52,713
випливає наш код для сортування
вибором. Ми визначаємо

40
00:03:52,713 --> 00:03:59,009
довжину масиву, 'n'. Далі маємо
цикл for, що перебирає кожний

41
00:03:59,009 --> 00:04:05,112
елемент у масиві, маємо змінну 'min' – індекс

42
00:04:05,112 --> 00:04:10,045
найменшого елементу справа від укажчика 'i'. Також маємо

43
00:04:10,045 --> 00:04:15,626
внутрішній цикл for з індексом 'j',якщо він знаходить
менший елемент, то перепризначує 'min',

44
00:04:15,626 --> 00:04:21,509
і коли ми перевірили усі елементи справа
від 'i' ми обмінюємо найменший елемент

45
00:04:21,509 --> 00:04:27,083
з 'i'. Це повна реалізація алгоритму
сортування вибором. Тепер легко

46
00:04:27,083 --> 00:04:34,073
вивести математичну модель "ціни" алгоритму
сортування вибором і твердження,

47
00:04:34,073 --> 00:04:42,054
що його описує. Можна стверджувати, що сортування
вибором робить приблизно N квадрат

48
00:04:42,056 --> 00:04:48,011
поділене на 2 порівнянь та рівно N обмінів. Просто
подивившись на цю схему алгоритму

49
00:04:48,011 --> 00:04:55,525
сортування вибором, можна довести
це твердження. У цій

50
00:04:55,525 --> 00:05:00,493
діаграмі чорні елементи – це ті, які ми
перевіряємо для того, щоб знайти

51
00:05:00,493 --> 00:05:06,621
мінімальний елемент, з мінімальним червоним
елементом. Сірі елементи не перевіряються,

52
00:05:06,621 --> 00:05:12,492
вони на своїх фінальних позиціях.
Можна побачити, що в цілому

53
00:05:12,492 --> 00:05:19,709
це буде квадрат зі стороною N, половина
елементів квадрата буде чорною

54
00:05:19,709 --> 00:05:27,029
або N квадрат навпіл. Точною формулою 
для знаходження кількості порівнянь буде (N - 1) +

55
00:05:27,245 --> 00:05:33,329
(N-2), і так далі. Для кожного
N-ого значення змінної

56
00:05:33,329 --> 00:05:40,218
'і' робиться один обмін і це "ціна"
виражена в кількості

57
00:05:40,218 --> 00:05:48,070
обмінів. Що цікаве можна сказати
про сортування вибором –

58
00:05:48,070 --> 00:05:54,257
те, що не має значення у якому порядку стоять елементи
у початковому масиві. Сортування вибором

59
00:05:54,257 --> 00:06:00,458
буде працювати квадратичний час, тому що воно буде
пробігати через увесь масив для того, щоб

60
00:06:00,458 --> 00:06:06,752
знайти мінімум. Ще одна властивість в тому, що ви не 
можете провести обмін меншою кількістю даних,

61
00:06:06,752 --> 00:06:12,842
тому що сортування вибором робить лінійну
кількість обмінів. Кожний елемент ставиться

62
00:06:12,842 --> 00:06:19,459
на фінальну позицію за допомогою лише
одного обміну. Подивимось на анімацію

63
00:06:19,459 --> 00:06:25,693
сортування вибором. Можна бачити укажчик,
що рухається справа наліво,

64
00:06:25,693 --> 00:06:31,919
кожний раз, коли він знаходить найменший елемент
справа, він ставить його на потрібну

65
00:06:31,919 --> 00:06:39,637
позицію. Для сортування вибором не
має значення чи масив частково

66
00:06:39,637 --> 00:06:45,854
відсортований. Навіть якщо масив повністю відсортований,
алгоритм все ще має проходити до кінця,

67
00:06:45,854 --> 00:06:51,359
через весь масив для знаходження мінімального
елементу. Це було сортування вибором,

68
00:06:51,359 --> 00:06:59,072
наш перший елементарний
метод сортування.