1
00:00:02,004 --> 00:00:04,096
おかえりなさい。今日はクイックソートを見ていきます。

2
00:00:05,016 --> 00:00:09,734
２０世紀の最も重要なアルゴリズムの一つと数えられ

3
00:00:09,734 --> 00:00:14,040
システム実装のソートや、多くのアプリケーションで広く使われています。

4
00:00:14,040 --> 00:00:19,079
前回講義ではマージソートを見ました。これも古典的なソートアルゴリズムで

5
00:00:19,079 --> 00:00:24,492
多くのシステムで使われています。今日は見ていくのはクイックソートで

6
00:00:24,492 --> 00:00:28,030
同様に多く用いられています。今ではクイックソートのＴシャツもあります。

7
00:00:28,030 --> 00:00:31,061
それではクイックソートはどんな方法でしょうか？

8
00:00:31,061 --> 00:00:36,375
同様に再帰によるものですが、クイックソートの基本アイデアは

9
00:00:36,375 --> 00:00:42,029
処理してから再帰を行ないます。一方で、マージソートは処理前に再帰を行ないます。

10
00:00:42,029 --> 00:00:45,044
まずランダムに配列をシャッフルします。

11
00:00:45,044 --> 00:00:48,073
あとで話しますが、重要なステップです。

12
00:00:48,073 --> 00:00:54,010
それから配列を分割します。たとえば j で分割するならば

13
00:00:54,010 --> 00:00:57,046
a の j は配列内にあります。

14
00:00:57,046 --> 00:01:02,084
j より左には大きい要素はありません。右には小さい要素はありません。

15
00:01:02,084 --> 00:01:06,682
その方法で区切ると真ん中に示してあるようになります。

16
00:01:06,682 --> 00:01:11,184
ここでは、K を区切り位置としています。左側にある全ては

17
00:01:11,184 --> 00:01:15,732
K より大きいものはなく、右側にある全ては小さいものはありません。

18
00:01:15,732 --> 00:01:18,818
その方法で振り分けが整ったら

19
00:01:18,818 --> 00:01:23,488
再帰的に二つの区域をソートします。左側をソート、右側をソートします。

20
00:01:23,488 --> 00:01:27,624
これらの二つとも完了すれば、全部がソートされたことになります。

21
00:01:27,624 --> 00:01:32,793
この方法は 1961 年に、トニー・ホーアにより考案され、1980 年には

22
00:01:32,793 --> 00:01:37,783
これを含めた功績によりチューリング賞を受賞しました。

23
00:01:37,783 --> 00:01:41,570
それではクイックソートの区分けがどうなるのかデモを見てみましょう。

24
00:01:41,570 --> 00:01:44,372
区切り要素として、任意に先頭要素を選択します。

25
00:01:44,372 --> 00:01:48,261
配列をシャッフルしてあるので、その要素は配列内のランダムな要素です。

26
00:01:48,261 --> 00:01:53,502
それから、ポインタ i を左から右へ動かし

27
00:01:53,502 --> 00:01:58,478
ポインタ j を右から左へ動かしていきます。ではデモでどう動くか見ましょう。

28
00:01:58,478 --> 00:02:02,887
では初めからやります。区切り要素として K を選択します。

29
00:02:02,887 --> 00:02:08,022
そして我々の方法では、ポインタ i を左から右に動かします。

30
00:02:08,022 --> 00:02:12,350
区切り要素よりも小さい限り、動かしていきます。

31
00:02:12,350 --> 00:02:17,542
ポインタ j は右から左に動かします。ポインタの指す要素が

32
00:02:17,542 --> 00:02:21,999
区切り要素より大きい限りです。この例だと、ポインタ i は

33
00:02:21,999 --> 00:02:26,569
すぐに停止です。ポインタが指す R は区切り要素よりも大きいですから。

34
00:02:26,569 --> 00:02:30,088
ポインタ j は減らしていきます。指し示す要素が

35
00:02:30,088 --> 00:02:34,680
区切り要素よりも小さい C になるまで。

36
00:02:34,680 --> 00:02:39,140
そして今この状態は、二つの要素とも動かせなくなっています。

37
00:02:39,140 --> 00:02:43,804
これらの間に区切られた要素があり、これらの順序が違っています。

38
00:02:43,804 --> 00:02:47,057
ですのでこれらを入れ替えます。では次に進みます。

39
00:02:47,057 --> 00:02:51,516
区切り要素より小さい限り i を増やします。

40
00:02:51,516 --> 00:02:54,881
T は大きいですからここで止めます。

41
00:02:54,881 --> 00:02:59,530
そして、区切り要素より大きい限り j を減らします。

42
00:02:59,530 --> 00:03:02,934
I は小さいですからここで止めます。

43
00:03:02,934 --> 00:03:07,419
先と同じく T と I が違う場所にあります。これらを入れ替えれば

44
00:03:07,419 --> 00:03:12,514
i よりも左にある物は全て区切り要素より小さく

45
00:03:12,514 --> 00:03:17,232
区切り要素より大きい値は i の左には一つもありません。

46
00:03:17,232 --> 00:03:20,406
そして区切り要素より小さい値は j より右に一つもありません。

47
00:03:20,406 --> 00:03:23,376
では入れ替えます。小さい限り i を増やします。

48
00:03:23,376 --> 00:03:27,504
L で止めます。大きい限り j を減らします。

49
00:03:27,504 --> 00:03:32,779
E で止めます。二つとも動かせなくなりましたので入れ替えます。

50
00:03:32,779 --> 00:03:38,408
では i を増やします。K よりも大きい L で止めます。j を減らします。

51
00:03:38,408 --> 00:03:44,804
K より小さい E で止めます。これで振り分け処理は完了です。

52
00:03:44,804 --> 00:03:50,618
ポインタが交差しましたので、配列内は全て走査し尽くしたことになります。

53
00:03:50,618 --> 00:03:51,828
実際に

54
00:03:51,828 --> 00:03:58,654
j が指している右側の終端要素から左にあるものは全て

55
00:03:58,654 --> 00:04:02,531
K より大きいものはありません。ですので j の指す要素と

56
00:04:02,531 --> 00:04:06,488
区切り要素を入れ替えることができます。これで配列の区分けが果たせました。

57
00:04:06,488 --> 00:04:10,740
要素 a j のその位置は

58
00:04:10,740 --> 00:04:16,254
左には大きいものはなく、右には小さい物がないことを満たします。

59
00:04:16,254 --> 00:04:22,380
分割処理のコードを実装するのは簡単です。

60
00:04:22,380 --> 00:04:26,965
下に分割前の配列の状態を示してあります。

61
00:04:26,965 --> 00:04:29,758
そして分割途中と分割後です。

62
00:04:29,758 --> 00:04:34,777
最後はポインタ j は区切り要素の v を指しています。

63
00:04:34,777 --> 00:04:39,002
v は先頭にありました。分割中はずっと

64
00:04:39,002 --> 00:04:41,836
コードはこの条件を保ち続けるようにします。

65
00:04:41,836 --> 00:04:45,982
i より左にある全ては v より等しいか小さいです。

66
00:04:45,982 --> 00:04:49,096
j より右にある全ては v よりも大きいです。

67
00:04:49,096 --> 00:04:51,576
間にあるものは未走査です。

68
00:04:51,576 --> 00:04:55,896
i が小さい限り増やしていく方法は、単に while ループです。

69
00:04:55,896 --> 00:05:00,781
加えて配列の右端を超えていないことをチェックする必要があります。

70
00:05:00,781 --> 00:05:03,927
j が大きいかぎり減らしていく方法は

71
00:05:03,927 --> 00:05:08,743
同じように単に while ループです。配列の左端を超えていないことをチェックします。

72
00:05:08,743 --> 00:05:12,831
ここはポインタが交差しているかどうかのチェックです。

73
00:05:12,831 --> 00:05:15,644
i と j の要素を交換します。

74
00:05:15,644 --> 00:05:20,014
ポインタが交差したら、ループを抜けて

75
00:05:20,014 --> 00:05:26,038
区切り要素を入れ替えます。以上が

76
00:05:26,038 --> 00:05:31,751
クイックソートの分割処理の簡易実装です。クイックソート自体は

77
00:05:31,751 --> 00:05:35,478
分割処理を使った再帰プログラムになります。

78
00:05:35,478 --> 00:05:41,324
最初は public メゾッドの sort で

79
00:05:41,324 --> 00:05:44,661
Comparable 型の配列を引数に取ります。そしてシャッフルしています。

80
00:05:44,661 --> 00:05:49,933
シャッフルは、良いパフォーマンスが出ることを保証する上で必要になります。

81
00:05:49,933 --> 00:05:53,486
そして再帰メゾッドを呼びます。

82
00:05:53,486 --> 00:05:58,481
ソートする子配列の範囲を引数にとります。

83
00:05:58,481 --> 00:06:01,879
そして分割です。単に分割します。

84
00:06:01,879 --> 00:06:06,937
どの要素が区切り位置になるか受け取って、再帰的に

85
00:06:06,937 --> 00:06:11,762
左側の lo から j-1 までと、そして右側の j+1 から hi をソートします。

86
00:06:11,762 --> 00:06:15,178
以上がクイックソートの全実装です。

87
00:06:15,178 --> 00:06:19,231
マージソートでもやりましたが

88
00:06:19,231 --> 00:06:25,241
再帰をトレースしてみるのは理解に役立ちます。マージソートと比べてみると

89
00:06:25,241 --> 00:06:29,879
上下逆のようになります。最初の行は区切り要素を

90
00:06:29,879 --> 00:06:34,992
K として置いています。それから sort メゾッドを

91
00:06:34,992 --> 00:06:41,132
まず左の区分に対して呼ぶと、区切り文字は E になります。その繰り返しです。

92
00:06:41,132 --> 00:06:46,874
最終的に小さい区分に下っていって

93
00:06:46,874 --> 00:06:53,085
大きさ１の子配列では何もしません。そうなったら灰色にしておきます。

94
00:06:53,085 --> 00:06:58,842
それから右の区分と繰り返します。このようにトレースしてみると

95
00:06:58,842 --> 00:07:05,961
再帰プログラム内で起こっていることが明確に把握できますね。

96
00:07:05,961 --> 00:07:11,003
クイックソートのアニメーションを見てみましょう。

97
00:07:11,003 --> 00:07:14,922
区切り処理がわかります。今は左側を処理しています。

98
00:07:14,922 --> 00:07:19,654
今は右側を振り分けています。今は右側の左区分を処理しています。

99
00:07:19,654 --> 00:07:22,251
今は左側のものを振り分けています。

100
00:07:22,251 --> 00:07:26,435
左区分にあるものです。このように左から右へと処理しながら

101
00:07:26,435 --> 00:07:29,582
半分の子配列に分割されていきます。

102
00:07:29,582 --> 00:07:32,764
それでは

103
00:07:32,764 --> 00:07:35,384
クイックソートの分割処理の実装詳細を考えてみましょう。

104
00:07:35,384 --> 00:07:38,086
一つ目は分割処理は in-place であることです。

105
00:07:38,086 --> 00:07:44,021
分割処理のコードをちょっと簡単にするために補助配列を使えますが

106
00:07:44,021 --> 00:07:47,029
マージソートに対するクイックソートの大きな利点の一つは

107
00:07:47,029 --> 00:07:51,031
追加容量を必要としないということです。

108
00:07:51,031 --> 00:07:56,034
in-place でソートできます。そしてループを抜ける処理に気をつけないといけません。

109
00:07:56,034 --> 00:08:00,051
動作するコードを見てしまえば

110
00:08:00,051 --> 00:08:04,087
なんてことはないのですが。皆さんが練習として

111
00:08:04,087 --> 00:08:10,001
コードを見る事なくクイックソートを実装してみようと思うかもしれません。

112
00:08:10,001 --> 00:08:15,001
ポインタ交差のチェックはちょっと面倒なことが分かるでしょう。

113
00:08:15,001 --> 00:08:18,075
特に重複キーがある場合は。そして範囲内での処理について。

114
00:08:18,075 --> 00:08:24,729
そして我々の実装では、ポインタ j が左端を超えたかをチェックするのは

115
00:08:24,729 --> 00:08:27,338
冗長です。なぜ冗長なのでしょうか？

116
00:08:27,338 --> 00:08:31,977
区切り要素がありますので、区切り要素に達したときに止まります。

117
00:08:31,977 --> 00:08:35,153
もう一方のポインタのチェックは冗長ではありません。

118
00:08:35,153 --> 00:08:40,039
そして鍵となる事の一つに

119
00:08:40,039 --> 00:08:45,368
これらの実装がどうなっているかです。もし配列が

120
00:08:45,368 --> 00:08:50,591
ランダムな順序であれば、分割後の二つの子配列もまた

121
00:08:50,591 --> 00:08:54,582
ランダムな順序です。実際のところいくつかの

122
00:08:54,582 --> 00:08:59,391
野良なクイックソートはこの特性を持たず、性能にやや難があります。

123
00:08:59,391 --> 00:09:03,584
事前にランダムにシャッフルしておくことは

124
00:09:03,584 --> 00:09:06,700
重要で性能を保証するために必要です。

125
00:09:06,700 --> 00:09:12,071
触れてはいましたが、まだ詳細をお話していない事は

126
00:09:12,071 --> 00:09:15,531
等しいキーがある場合についてです。よりうまくやるために

127
00:09:15,531 --> 00:09:19,886
特別な方法で等しいキーを扱います。それについては二回目の講義でやります。

128
00:09:19,886 --> 00:09:24,819
この実装がやることは、区切り要素と等しいキーでポインタを止めます。

129
00:09:24,819 --> 00:09:30,098
なぜそれが重要かは、すぐに見ていきます。

130
00:09:30,098 --> 00:09:36,016
それでは実行時間を見てみましょう。なぜ

131
00:09:36,016 --> 00:09:40,073
クイックソートとマージソートを使い分けるのか。これは以前に見た

132
00:09:40,073 --> 00:09:46,033
テーブルを拡張したものです。この右の列にあるように、クイックソートは

133
00:09:46,033 --> 00:09:51,087
マージソートと比べてかなり速いです。繰り返しますが、良いアルゴリズムは

134
00:09:51,087 --> 00:09:58,073
スーパーコンピュータよりも断然良いです。個人用 PC ですら

135
00:09:58,073 --> 00:10:05,026
百万要素の巨大な配列のソートは１秒以内ですし、十億でも数分です。

136
00:10:05,051 --> 00:10:11,071
そう、このソート時間がイックソートが広く使われる理由です。

137
00:10:11,071 --> 00:10:15,030
単にマージソートより速いです。

138
00:10:15,056 --> 00:10:21,098
最良のケースでは、クイックソートはきっちり半分に分割します。

139
00:10:21,098 --> 00:10:27,037
マージソートと同じようになります。およそ N log N です。

140
00:10:27,057 --> 00:10:33,027
最悪のケースは、ランダムなシャッフルが順番通りに並んでしまった場合で

141
00:10:33,027 --> 00:10:38,071
分割処理では一番小さい要素を見つける以外なにもしません。

142
00:10:38,071 --> 00:10:44,002
一番小さい要素だけを剥き取るだけです。まるで右側にあるものが

143
00:10:44,002 --> 00:10:46,057
全て大きいことを見つけていくようなものです。それはまずいです。

144
00:10:46,057 --> 00:10:50,074
ランダムにシャッフルしていたなら、まず起こるようなことではありません。

145
00:10:50,074 --> 00:10:57,007
クイックソートを学ぶ上で最も興味深い事は平均ケースの分析です。

146
00:10:57,007 --> 00:11:03,018
詳細な数学的な導出のようなものですが、やってみる価値はあります。

147
00:11:03,018 --> 00:11:08,762
なぜクイックソートがクイックかの感覚を得るためにも。

148
00:11:08,762 --> 00:11:14,804
ではマージソートでやったように

149
00:11:14,804 --> 00:11:19,819
プログラムでやっていることを漸化式に落とし込みます。

150
00:11:19,819 --> 00:11:26,283
クイックソートでの、要素数 N のソート時の比較回数は、分割処理の N+1 です。

151
00:11:26,283 --> 00:11:31,243
さらに区切り要素次第で次に起こることを加えます。

152
00:11:31,243 --> 00:11:36,024
区切り位置を k とすると

153
00:11:36,024 --> 00:11:41,843
何かの値が 1/N の確率で起こります。区切り位置を k とすると

154
00:11:41,843 --> 00:11:47,694
左区分は k-1 個の要素があり、右区分には N-k 個の要素があります。

155
00:11:47,694 --> 00:11:52,040
すべての k に渡って

156
00:11:52,040 --> 00:11:57,900
区切り位置が k で二つの区分にかかるコストの確率を加えていくとすれば

157
00:11:57,900 --> 00:12:02,997
この等式が得られます。これを見ると怖じ気づいてしまうかもしれませんが

158
00:12:02,997 --> 00:12:07,310
実は解くことはさほど難しくありません。

159
00:12:07,310 --> 00:12:11,941
まず両端に N をかけて項をまとめます。

160
00:12:11,941 --> 00:12:16,694
N C_N は N+1 の N 倍、そしてこの項はそれぞれのサイズで二回でてきます。

161
00:12:16,694 --> 00:12:20,701
C_0 から C_N-1 の総和を倍にしたものですね。

162
00:12:20,701 --> 00:12:23,670
すでに簡単な等式になっています。

163
00:12:23,670 --> 00:12:30,245
そうしたら、その総和から、同じ式で得られる N-1 の分を差し引きます。

164
00:12:30,245 --> 00:12:37,079
N C_N マイナス N-1 C_N-1 そして

165
00:12:37,079 --> 00:12:43,088
 N N+1 マイナス N-1 N は単に 2N です。そしてこの合算している項は

166
00:12:43,088 --> 00:12:48,391
最後の項だけ残ります。この総和から N-1 の総和を引くので

167
00:12:48,391 --> 00:12:54,079
2C_N - 1 が残るだけです。さらに簡単な等式になりますよ。

168
00:12:54,079 --> 00:12:58,509
項を整理します。N+1 C_N-1 がありますから

169
00:12:58,509 --> 00:13:04,069
N N+1 で割ります。まるで魔法みたいですが

170
00:13:04,069 --> 00:13:10,009
その等式は簡単に解けることがわかります。

171
00:13:10,009 --> 00:13:16,042
C_N / N+1 = C_N-1 / N の部分は

172
00:13:16,042 --> 00:13:20,058
畳み込む式です。右の最初の項は

173
00:13:20,076 --> 00:13:25,069
左の項と同じ事ですから、同じ式を適用できます。

174
00:13:25,069 --> 00:13:29,413
2 / N+1 については、N-1 となりますから一つ減らして

175
00:13:29,413 --> 00:13:34,473
2 / N として切り出せます。この方法を続けて

176
00:13:34,473 --> 00:13:39,376
N を減らしながら 2 / N を全て切り出します。N が 2 になるまでです。c1 は

177
00:13:39,376 --> 00:13:43,104
ゼロですから。先の等式を畳み込んで置き換えます。

178
00:13:43,104 --> 00:13:47,537
そうするとその式は簡単な総和になり

179
00:13:47,537 --> 00:13:52,716
その和は積分により近似できます。1 / x で x は 3 から N+1 までです。

180
00:13:52,716 --> 00:13:57,110
このケースではよい感じで近似値に近づきます。

181
00:13:57,110 --> 00:14:03,683
この近似値により、クイックソートは 2 N+1 ln N の比較回数だと言えます。

182
00:14:03,683 --> 00:14:06,297
おおよそ 1.39 N log N です。

183
00:14:06,297 --> 00:14:11,995
クイックソートでの平均の比較回数であり

184
00:14:11,995 --> 00:14:17,169
シャッフルによって要素がランダムな順列であれば

185
00:14:17,169 --> 00:14:22,330
期待される比較回数はこの値に収束します。

186
00:14:22,330 --> 00:14:26,489
N が大きければ、この値に更に近づきます。

187
00:14:26,489 --> 00:14:31,633
最悪のケースのクイックソートは二乗時間です。複雑性が示す通り

188
00:14:31,633 --> 00:14:35,090
最悪のケースなら二乗時間のアルゴリズムです。

189
00:14:35,090 --> 00:14:40,272
ランダムシャッフルでそうなるなら、この講義が

190
00:14:40,272 --> 00:14:44,158
落雷が原因で終わるような確率です。もしくはあなたのコンピュータが

191
00:14:44,158 --> 00:14:46,624
雷で感電するようなものです。というわけでそれは無視できます。

192
00:14:46,624 --> 00:14:51,307
平均のケースでは、実際のアプリケーションではほとんどそうですが

193
00:14:51,307 --> 00:14:55,733
大体 1.39 N log N になります。マージソートより多くの比較数になります。

194
00:14:55,733 --> 00:14:58,643
しかしクイックソートのほうがずっと速いのです。

195
00:14:58,643 --> 00:15:01,724
それぞれの比較ごとにすることが多くありません。

196
00:15:01,724 --> 00:15:05,509
比較して、ポインタを増やすだけです。

197
00:15:05,509 --> 00:15:10,832
一方で、マージソートは要素を補助配列に出し入れしなければなりません。

198
00:15:10,832 --> 00:15:14,520
よりコストがかかります。ランダムシャッフルは

199
00:15:14,520 --> 00:15:18,560
クイックソートでよいパフォーマンスを得る鍵となります。それにより

200
00:15:18,560 --> 00:15:22,584
最悪のケースとはならないだろうと保証できます。さらに

201
00:15:22,584 --> 00:15:26,726
実験して試して使おうと思える数学的なモデルを組む事もできます。

202
00:15:26,726 --> 00:15:32,345
クイックソートを実行して回数を数えます。ランダムシャッフルしておけば

203
00:15:32,345 --> 00:15:36,725
おおよそ 1.39 N log N の比較回数となるでしょう。実行時間は

204
00:15:36,725 --> 00:15:41,311
N log N に比例し速いソートです。以上は皆がやっていることで

205
00:15:41,311 --> 00:15:45,143
皆がそれを使う理由です。さてそれでは

206
00:15:45,143 --> 00:15:51,274
クイックソートにおいていくつかの注意点があります。その実装はやや危なっかしく

207
00:15:51,274 --> 00:15:55,582
間違いも起こしやすいです。書籍にある実装や

208
00:15:55,582 --> 00:16:00,717
ウェブ上にある実装のいくつかは、ある条件で二乗時間を引き起こすことがわかるでしょう。

209
00:16:00,717 --> 00:16:04,964
その点を気をつけなければなりませんし

210
00:16:04,964 --> 00:16:10,856
すべてがランダムに並び替えたつもりでも、たくさん重複があったり

211
00:16:10,856 --> 00:16:17,035
実装が正しくなければ、クイックソートは二乗時間がかかります。

212
00:16:17,035 --> 00:16:21,286
ではクイックソートの特性をまとめましょう。

213
00:16:21,286 --> 00:16:25,915
in-place です。追加容量は不要です。

214
00:16:25,915 --> 00:16:29,498
再帰の深さは

215
00:16:29,498 --> 00:16:36,007
ランダムシャッフルでどうなるかによりますが、対数時間になります。

216
00:16:36,007 --> 00:16:41,700
より小さい子配列を保てば、再帰の深さを抑える事ができます。

217
00:16:41,700 --> 00:16:45,517
しかし今ではさして必要ではありません。

218
00:16:45,517 --> 00:16:51,229
ランダムシャッフルしておけば大丈夫です。ところでクイックソートは

219
00:16:51,229 --> 00:16:58,530
安定ソートではありません。分割処理は離れた範囲で交換を行ないます。

220
00:16:58,530 --> 00:17:04,073
キーを交換する時に、同じ値の他のキーを飛び越えてしまうことがありえます。

221
00:17:04,073 --> 00:17:10,542
追加容量を使う等、ちょっと手を加えればクイックソートは安定ソートになります。

222
00:17:10,542 --> 00:17:16,567
結局のところ、実際にもっとも速いソートアルゴリズムであり

223
00:17:16,567 --> 00:17:21,623
より速くする方法がいくつかあります。同じようなものを

224
00:17:21,623 --> 00:17:26,919
マージソートでも見ました。紛れもなく

225
00:17:26,919 --> 00:17:31,650
クイックソートでも実装する価値があります。まず小さい子配列に関して。

226
00:17:31,650 --> 00:17:37,607
クイックソートとはいえども小さい配列にはよりオーバーヘッドが伴います。

227
00:17:37,607 --> 00:17:41,106
一つ、二つ、三つ、四つくらいですね。小さい配列には

228
00:17:41,106 --> 00:17:46,340
挿入ソートに切り替える方法があります。どの数を使うかは

229
00:17:46,340 --> 00:17:47,460
さして重要ではありません。

230
00:17:47,460 --> 00:17:52,469
10 から 20 の間くらいで、20 % ほどの実行時間の向上となるでしょう。

231
00:17:52,470 --> 00:17:57,827
小さい配列には何もせず、挿入ソートを

232
00:17:57,827 --> 00:18:02,084
最後に流します。以上が一つ目の改善です。

233
00:18:02,084 --> 00:18:07,047
二つ目の改善は、真ん中あたりを区切り要素だろうとみなすことです。

234
00:18:07,047 --> 00:18:11,008
最初の要素を使うのではなく。

235
00:18:11,008 --> 00:18:14,476
平均的にそれは真ん中にあるでしょう。

236
00:18:14,476 --> 00:18:19,578
やることは要素からサンプルを取り出して、その中央値を得ます。

237
00:18:19,578 --> 00:18:23,621
サンプルが増え過ぎるとコスト的に有利ではありませんが

238
00:18:23,621 --> 00:18:28,155
三つであれば効果はあります。

239
00:18:28,155 --> 00:18:33,427
比較回数は僅かながら減ります。

240
00:18:33,427 --> 00:18:39,185
逆に交換回数が増えます。中央値を区切り要素に持ってくる際に必要です。

241
00:18:39,185 --> 00:18:43,934
以上の事で実行時間は 10% ほど改善するでしょう。

242
00:18:43,934 --> 00:18:48,380
クイックソートの最適化をまとめると

243
00:18:48,380 --> 00:18:54,655
３つの中央値を区切り要素とし、小さいブロックには処理を切り替えます。

244
00:18:54,655 --> 00:19:00,977
三つの中央値を取ったなら、たいてい区切り要素はそれなりに真ん中に近くなります。

245
00:19:00,977 --> 00:19:07,812
小さいブロックはソートはせずに

246
00:19:07,812 --> 00:19:13,316
挿入ソートを最後に適用します。

247
00:19:13,316 --> 00:19:17,539
このスライドでクイックソート内で操作される要素数が感覚的にわかります。

248
00:19:17,539 --> 00:19:22,594
どうやって速くソートが完了するのかの説明にもなりますね。

249
00:19:22,594 --> 00:19:28,098
以上がクイックソートの概要です。今日のところ、最良のソートアルゴリズムです。