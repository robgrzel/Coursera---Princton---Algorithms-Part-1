1
00:00:00,000 --> 00:00:04,085
欢迎回到算法课程 今天我们要讨论的是并查集

2
00:00:04,085 --> 00:00:09,098
一种用于解决所谓的动态连通性问题的算法

3
00:00:09,098 --> 00:00:14,091
我们将介绍两个经典算法：快速查找和快速合并

4
00:00:14,091 --> 00:00:20,078
以及这些算法的一些实现和改进 本节课程的另一个目的是

5
00:00:20,078 --> 00:00:27,039
体验一下我们日后将反复经历的

6
00:00:27,039 --> 00:00:32,039
开发有效算法的流程  首先第一步是建立问题模型

7
00:00:32,039 --> 00:00:37,031
找出解决该问题大体上所需要的基本操作

8
00:00:37,031 --> 00:00:41,681
据此找出算法解决该问题 在很多情况下

9
00:00:41,681 --> 00:00:46,486
我们最初提出的算法可能已经足够快 并且符合对存储空间的要求

10
00:00:46,486 --> 00:00:52,024
这种算法我们可以直接拿来用 但是在另一些情况下

11
00:00:52,024 --> 00:00:56,074
算法可能不够快 或者存储空间不足 我们需要搞清楚

12
00:00:56,074 --> 00:01:01,037
为什么会这样 想办法找出造成这些问题的源头

13
00:01:01,037 --> 00:01:06,051
然后提出新的算法 如此循环直到满意为止 这就是

14
00:01:06,051 --> 00:01:11,099
设计和分析算法的科学途径 我们先建立数学模型 

15
00:01:11,099 --> 00:01:17,061
搞清楚问题的实质 然后通过实践来验证模型

16
00:01:17,061 --> 00:01:22,089
进而改进模型和方法 在这里 我们来讨论动态连通性问题

17
00:01:22,089 --> 00:01:29,021
也就是并查集问题的模型 问题是这样的

18
00:01:29,021 --> 00:01:33,090
有一组共N个对象 我们不必在意它们究竟是什么

19
00:01:33,090 --> 00:01:39,002
我们用0到N的数字来标记它们

20
00:01:39,002 --> 00:01:43,082
两个对象间可以连通 我们假设有一个命令

21
00:01:43,082 --> 00:01:48,057
用来连接两个对象 将两个对象传入该命令

22
00:01:48,057 --> 00:01:53,093
将创造两者之间的连接 现在问题的关键是连通性的查询

23
00:01:53,093 --> 00:01:59,097
即查询两个对象之间是否有连通的路径存在

24
00:01:59,097 --> 00:02:05,021
例如 对这10个对象 我们已经执行了一组连接命令

25
00:02:05,021 --> 00:02:10,278
连接4和3 3和8 6和5 9和4

26
00:02:10,278 --> 00:02:16,526
2和1 然后我们进行一次连通性查询 0与7连通吗？

27
00:02:16,526 --> 00:02:22,713
在这个例子中 它们没有连通 所以我们得到“否” 但是

28
00:02:22,713 --> 00:02:28,281
如果我们查询 8与9连通吗？ 我们将得到“是” 即便它们之间其实

29
00:02:28,281 --> 00:02:33,629
并没有直接相连 因为存在一条路径从8到3到4到9

30
00:02:33,629 --> 00:02:39,783
这就是我们的任务 即对于给定的对象集合

31
00:02:39,783 --> 00:02:45,444
高效地实现这两个命令 现在 我们执行union(5, 0)

32
00:02:45,444 --> 00:02:51,026
该命令创建5和0之间的连接 传入7和2的命令

33
00:02:51,026 --> 00:02:56,744
创建7和2之间的连接 然后同样地 连接6和1 

34
00:02:56,744 --> 00:03:02,836
所以，如果现在我们查询0与7是否是连通的，额，将1和0连通也是可以执行的，那是一个冗余的连接

35
00:03:02,836 --> 00:03:08,528
那么现在，如果我们问0和7是否连通，那么我们会回答“是”

36
00:03:08,528 --> 00:03:13,858
所以这就是我们的要处理的问题，合并命令与连通查询的交叉混合，而且

37
00:03:13,858 --> 00:03:18,991
我们需要能对大量对象高效地支持这些命令

38
00:03:18,991 --> 00:03:23,833
那么，这就是一个大得多的例子。你会发现对于这个问题我们需要高效的算法

39
00:03:23,833 --> 00:03:28,128
首先，你会发现我们需要计算机处理这个问题

40
00:03:28,128 --> 00:03:33,085
对于人类需要花掉相当一段时间才能判定（给定两个对象）是否存在连接

41
00:03:33,085 --> 00:03:38,205
在这个例子中，连接是存在的。现在

42
00:03:38,205 --> 00:03:43,805
我们今天要学习的算法实际上并不会给出连接两个对象的路径

43
00:03:43,805 --> 00:03:48,847
它只能回答这样的问题：是否存在一条路径？

44
00:03:48,847 --> 00:03:53,721
在第二部分课程中，我们会讲到能够确切地找出路径的算法

45
00:03:53,721 --> 00:03:59,220
这些算法不如并查集高效，因为它们需要完成更多的工作。现在

46
00:03:59,220 --> 00:04:05,972
这些算法的应用涉及各种各样的对象。这些算法

47
00:04:05,972 --> 00:04:11,906
用在数码照片上，应用对象就是像素。用在网络上

48
00:04:11,906 --> 00:04:17,444
应用对象是计算机。用在社交网络上，应用对象就是人

49
00:04:17,444 --> 00:04:23,528
用在计算机芯片上，应用对象就是电路元件。应用对象可以是抽象的事物，如程序中的变量名

50
00:04:23,528 --> 00:04:29,334
数学集合中的元素，也可以是物理对象如复合体系中的金属位

51
00:04:29,334 --> 00:04:34,802
但是所有这些不同类型的对象

52
00:04:34,802 --> 00:04:40,574
在编程中我们需要对每一个对象命名，我们会简单地

53
00:04:40,574 --> 00:04:46,810
用从0到N-1的整数为这些对象编号。这对于我们的程序是便于着手的出发点

54
00:04:46,810 --> 00:04:53,605
因为我们可以用整数作为数组索引号

55
00:04:53,605 --> 00:05:00,160
之后便能快速地访问每个对象的相关信息。而且

56
00:05:00,160 --> 00:05:05,777
还可以略去与并查集问题不相关的很多细节。实际上

57
00:05:05,777 --> 00:05:10,444
将对象名称映射为从0到N的整数的这种做法

58
00:05:10,444 --> 00:05:14,914
是符号表或搜索算法的一个漂亮的应用

59
00:05:14,914 --> 00:05:20,300
是本课程中之后我们将会学习的用来解决映射问题的算法与数据结构

60
00:05:20,501 --> 00:05:26,316
现在，关于连接

61
00:05:26,316 --> 00:05:33,545
我们需要几个连接必须满足的抽象性质。这些性质都很自然而且直观

62
00:05:33,775 --> 00:05:40,563
那么我们假设“连接到”是一个等价关系。就是说

63
00:05:40,563 --> 00:05:47,148
每个对象都能连接到自己。“连接到”是对称的。如果P连接到Q

64
00:05:47,148 --> 00:05:53,205
那么Q连接到P。而且“连接到”是传递性的。如果P连接到Q，而且Q连接到R

65
00:05:53,205 --> 00:05:59,128
那么P就能连接到R。这些性质都很直观

66
00:05:59,128 --> 00:06:05,292
但是明确列出这些性质并确定我们的算法具备这些性质是有必要的

67
00:06:05,292 --> 00:06:12,452
当我们有了一个等价关系之后，一个对象和连接的集合就分裂为子集

68
00:06:12,452 --> 00:06:19,172
这些子集叫连通分量。连通分量是互相连接的对象的最大集合

69
00:06:19,172 --> 00:06:25,056
比如在这个小例子中

70
00:06:25,056 --> 00:06:30,936
有三个连通分量。其中一个只有一个对象0构成，第二个

71
00:06:30,936 --> 00:06:36,239
由对象1、4、5构成，第三个由其余四个对象构成

72
00:06:36,239 --> 00:06:42,244
连通分量具有如下性质：连通分量中的任意两个对象都是相连接的

73
00:06:42,244 --> 00:06:47,096
连通分量中对象不与连通分量之外的对象相连接

74
00:06:47,096 --> 00:06:53,126
这就是连通分量。我们的算法通过维护连通分量来获得效率

75
00:06:53,126 --> 00:06:59,319
并使用连通分量来高效地应答接收到的请求

76
00:06:59,319 --> 00:07:04,949
好，那么要实现的操作有查找请求和

77
00:07:04,949 --> 00:07:09,840
合并命令。我们要维护连通分量

78
00:07:09,840 --> 00:07:14,449
查找就是检查两个对象是否在相同的分量中

79
00:07:14,449 --> 00:07:20,243
合并命令就是将包含两个对象的分量替换为其并集

80
00:07:20,243 --> 00:07:25,872
例如，如果我们有图中这些分量

81
00:07:25,872 --> 00:07:31,906
收到了连接2和5的命令，根本上，我们需要

82
00:07:31,906 --> 00:07:37,965
合并包含2和包含5的两个连通分量

83
00:07:37,965 --> 00:07:44,453
得到一个大的连通分量，这样我们就只有两个连通分量了

84
00:07:44,453 --> 00:07:52,821
从之前讨论过的那些我们得到了一个数据类型，在编程的概念中它是

85
00:07:52,821 --> 00:07:59,122
为了解决问题我们想要实现的方法的规范

86
00:07:59,122 --> 00:08:04,980
那么一个典型的Java模型中，我们要做的就是

87
00:08:05,224 --> 00:08:12,425
创建一个叫UF的类，它包含两个方法，一个用来实现合并，另一个

88
00:08:12,425 --> 00:08:19,052
用来实现连接查找，返回一个布尔量（逻辑变量，真或者假）。构建器需要对象的数量作为参数

89
00:08:19,052 --> 00:08:26,030
这样它能够根据对象的数量建立数据结构

90
00:08:26,030 --> 00:08:31,089
那么当我们在实现算法的时候，我们要在心里牢记

91
00:08:31,089 --> 00:08:37,029
对象的数量和操作的数量都可能是巨大的

92
00:08:37,029 --> 00:08:42,076
我们可能会有非常大量的合并与连接查询操作，而

93
00:08:42,076 --> 00:08:48,315
我们的算法在这样的情况下也必须是高效的

94
00:08:48,315 --> 00:08:56,011
这门课程中接下来常常要做的事就是要在处理更深层的问题之前

95
00:08:56,011 --> 00:09:04,029
检查我们的应用编程接口（API）设计，我们通过设计一个

96
00:09:04,029 --> 00:09:11,050
使用我们开发的数据类型的客户端来检查API。比如这个例子中

97
00:09:11,050 --> 00:09:19,074
我们已经有了一个客户端从标准输入中读取信息。首先

98
00:09:19,074 --> 00:09:27,381
读取一个整数，表示将要处理的对象的数量。然后是一对一对对象名字

99
00:09:27,381 --> 00:09:35,070
客户端首先从标准输入中读取这个整数

100
00:09:35,070 --> 00:09:42,068
并创建一个UF对象。然后只要标准输入中还有输入

101
00:09:42,068 --> 00:09:47,089
客户端将从输入读取两个整数

102
00:09:47,089 --> 00:09:52,663
如果它们没有相连，它将会连接他们并输出。如果它们已经相连

103
00:09:52,663 --> 00:09:58,266
客户端就忽略这条输入。那么这就是我们的测试客户端，而且是一个很好的测试客户端

104
00:09:58,266 --> 00:10:04,702
它可以确保任何一种实现都执行我们期望它进行的操作。好，这就是整体结构了

105
00:10:04,702 --> 00:10:10,348
我们已经描述了我们想要实现的操作，细致到了代码层面。而且我们

106
00:10:10,348 --> 00:10:15,091
有了我们的实现需要服务的客户端代码