1
00:00:01,006 --> 00:00:06,058
Мы рассмотрели что эффективную реализацию алгорима которая

2
00:00:06,058 --> 00:00:12,025
может решить задачу union-find для очень больших задач, теперь рассмотрим как

3
00:00:12,025 --> 00:00:17,095
это может применяться. Есть огромное количество приложений Union-find. Мы 

4
00:00:17,095 --> 00:00:24,005
говорили о динамической связности, есть и много других примеров

5
00:00:24,005 --> 00:00:30,008
в вычислительных задачах. В самом низу одна важная

6
00:00:30,008 --> 00:00:36,018
задача это обработка изображений для понимания того как помечать области изображения. Мы позже 

7
00:00:36,018 --> 00:00:41,057
увидим алгоритм минимального остовного дерева Крускала -  алгоритма

8
00:00:41,057 --> 00:00:48,009
обработки графов который использует Union-find как подзадачу. Есть алгоритмы в физике

9
00:00:48,009 --> 00:00:54,077
для понимания физических явлений, которые мы рассмотрим в примере и много других

10
00:00:55,000 --> 00:01:00,064
 в списке. А сейчас мы поговорим о одной задаче называемой "просачиванием".

11
00:01:00,086 --> 00:01:07,046
Это модель многих физических систем. Рассмотрим абстрактную модель и потом

12
00:01:07,046 --> 00:01:13,063
коротко обсудим как это применяется в физических системах. Итак рассмотрим

13
00:01:13,063 --> 00:01:20,076
сетку квадратов n x n которые назовем участками. Будем говорить что участок открыт -

14
00:01:21,001 --> 00:01:27,076
белый цвет на диаграмме -  с вероятностю p или заблокирвон - черный на диаграмме -

15
00:01:27,076 --> 00:01:34,029
с вероятность 1-p и мы определим систему, будем называть систему 

16
00:01:34,029 --> 00:01:40,059
просачивающейся если верх и низ соединены открытыми участками. Так в системе

17
00:01:40,059 --> 00:01:46,089
слева, вы можете найти путь сверху вниз по белым 

18
00:01:46,089 --> 00:01:53,019
квадратам, но системы с права не просачивающаяся, нет пути 

19
00:01:53,019 --> 00:02:00,017
сверху вниз по белым квадратам. Это модель для многих 

20
00:02:00,017 --> 00:02:05,098
систем. Например в электронике. Можно представить что открытые учаски 

21
00:02:05,098 --> 00:02:11,091
проводники, а заблокированные изолированы. И тогда если есть проводник 

22
00:02:11,091 --> 00:02:17,091
сверху вниз тогда устройство проводит электричество. Или вы можете считать что это 

23
00:02:17,091 --> 00:02:23,039
вода текущая сквозь поры некоторого вещества, где свободные участки

24
00:02:23,039 --> 00:02:28,055
просто пустые а заблокированные участки заполнены материалом, и вода может 

25
00:02:28,055 --> 00:02:34,030
течь протечь сверху вниз или нет. Или это может быть социальная сеть

26
00:02:34,030 --> 00:02:39,869
где люди могут быть связаны и есть ли связь между двумя людьми

27
00:02:39,869 --> 00:02:46,063
или нет, и есть ли путь от одной группы людей к другой 

28
00:02:46,063 --> 00:02:52,076
связанных через социальную сеть. Это всего лишь несколько примеров

29
00:02:52,076 --> 00:02:58,089
модели просачивания. Мы будет говорить о случайной модели, где

30
00:02:58,089 --> 00:03:05,075
участки свободны с заданной вероятностью. И ясно что

31
00:03:06,005 --> 00:03:11,087
эта вероятность, что участок свободен, низкая слева, и на этих двух примерах

32
00:03:11,087 --> 00:03:17,002
слева просачивания не будет. Недостаточно открытых участков

33
00:03:17,002 --> 00:03:22,016
для  соединения верха и низа. Если вероятность высока

34
00:03:22,016 --> 00:03:26,002
 то будет много открытых участков, и будет просачиваться.

35
00:03:26,002 --> 00:03:30,055
Будет много путей сверху вниз. Но по середине, когда

36
00:03:30,055 --> 00:03:35,067
вероятность средняя, неизвестно дует просачиваться или нет. И научный

37
00:03:35,067 --> 00:03:40,065
или математический вопрос из это модели такой, как мы узнаем

38
00:03:41,005 --> 00:03:46,062
будет или просачиваться или нет. В этой задаче и многих подобных задачах

39
00:03:46,062 --> 00:03:52,034
есть то, что называют фазой перехода. Которая говорит, что если она низкая

40
00:03:52,034 --> 00:03:56,072
то не будет просачивания, а сели высокая то будет. И 

41
00:03:56,072 --> 00:04:02,003
на самом деле порог между просачиванием и непросачиванием 

42
00:04:02,003 --> 00:04:07,092
очень крутой. И существует число N такое, что

43
00:04:07,092 --> 00:04:13,089
если вероятность меньше чем это число, то просачивания почти точно не будет, а если

44
00:04:13,089 --> 00:04:19,045
больше то почти точно будет. Вопрос в том что это за значение. Это пример

45
00:04:19,045 --> 00:04:26,051
математической модели где эта задача проявляется. Но что это за

46
00:04:26,051 --> 00:04:32,092
пороговое значение математически нерешено.

47
00:04:32,092 --> 00:04:37,032
единственное решение которое есть пришло из вычислительное модели, когда мы запускаем

48
00:04:37,032 --> 00:04:42,082
моделирования для того чтобы определить эту вероятность. И эти моделирвоания

49
00:04:42,082 --> 00:04:47,093
только доступна благодаря алгоритму union-find. Этот наш пример 

50
00:04:47,093 --> 00:04:53,024
показывает зачем нам нужен быстрый алгоритм union-find, рассмотрим его

51
00:04:53,024 --> 00:04:59,053
То что мы собираемся запустить сейчас называется моделирование Монте-Карло. Когда 

52
00:04:59,053 --> 00:05:06,063
мы задаем всю сетку заблокированной и затем случайно задаем

53
00:05:06,063 --> 00:05:12,096
открытые участки. Каждый раз добавляя открытый участок, мы проверяем

54
00:05:12,096 --> 00:05:18,095
просачивается ли система или нет. И продолжаем до тех пор пока не достигнем точки когда 

55
00:05:18,095 --> 00:05:24,026
система просачивается. И мы можем показать что процент отрытых в момент

56
00:05:24,026 --> 00:05:29,080
когда система просачивается будет оценкой порогового значения. И то что хотим сделать 

57
00:05:29,080 --> 00:05:35,008
это запустить это эксперимент миллионы раз, что мы можем сделать на компьютере, поскольку

58
00:05:35,008 --> 00:05:40,069
мы можем эффективно делать расчет будет ли просачивание или нет. Это моделирование Монте-Карло, 

59
00:05:40,069 --> 00:05:45,064
вычислительная задача которая дает решение этой

60
00:05:45,084 --> 00:05:51,012
научное проблемы, математическую постановку которой еще никто не решил.

61
00:05:51,012 --> 00:05:56,097
Рассмотрим подробнее как мы будем использовать

62
00:05:56,097 --> 00:06:03,092
нашу модель динамической связности. Ясно что мы создадим по

63
00:06:03,092 --> 00:06:09,093
объекту для каждого участка. И пронумеруем их от нуля до N^2-1

64
00:06:09,093 --> 00:06:16,091
как показано здесь. И затем будем соединять по 

65
00:06:16,091 --> 00:06:23,029
открытым участкам. Так модель просачивания слева соответствует модели 

66
00:06:23,029 --> 00:06:28,089
справа, согласно тому как мы это делали. И мы могли бы сказать,

67
00:06:28,089 --> 00:06:33,081
что теперь нам нужно проверить связан ли какой-либо участок снизу

68
00:06:33,081 --> 00:06:39,039
с каким либо участком сверху, используя для этого union-find для этого. Проблема

69
00:06:39,039 --> 00:06:44,091
в том что это будет слишком грубый алгоритм. У него были бы квадратичные затраты.

70
00:06:44,091 --> 00:06:50,030
Потому что ему потребуется N^2 вызовов find для проверки связности

71
00:06:50,030 --> 00:06:55,048
для каждого участка сверху проверяется участок снизу. Это слишком

72
00:06:55,048 --> 00:07:01,024
медленно. Вместо этого то что мы создадим по виртуальному участку сверху и снизу.

73
00:07:01,024 --> 00:07:06,087
И затем если мы хотим узнать просачивается система или нет, мы просто проверяем

74
00:07:06,087 --> 00:07:14,025
связан ли верхний виртуальный участок с нижним виртуальным участком. Так как мы 

75
00:07:14,025 --> 00:07:20,097
моделируем открытие нового участка? Для того чтобы открыть участок мы соединяем его со всеми

76
00:07:20,097 --> 00:07:28,034
соседними открытыми участками. Это будет несколько вызовов Union, что легко реализовать. И

77
00:07:28,034 --> 00:07:34,092
затем с этим простым соотношением мы можем использовать тот же самый код что

78
00:07:34,092 --> 00:07:42,000
мы разработали для задачи связности. И

79
00:07:42,000 --> 00:07:48,082
получаем результат, запуская моделирование достаточно много раз, и в итого 

80
00:07:49,007 --> 00:07:55,409
порог просачивания примерно 0.592746. С наши быстрым алгоритмом мы

81
00:07:55,409 --> 00:08:01,693
получаем достаточно точный ответ на этот научный вопрос. Если мы используем медленный Union-find

82
00:08:01,693 --> 00:08:06,822
алгоритм мы не можем запустить его для очень больших задач и получить очень 

83
00:08:06,822 --> 00:08:11,979
точный ответ. И в итоге мы взяли важную задачу, задачу

84
00:08:11,979 --> 00:08:17,359
 динамической связности. Мы смоделировали задачу чтобы понять какого рода 

85
00:08:17,359 --> 00:08:22,109
структуры данных и алгоритмы нам нужны для ее решения. Мы рассмотрели

86
00:08:22,109 --> 00:08:26,676
несколько простых алгоритмов для решения этой задачи и быстро заметили что они

87
00:08:26,676 --> 00:08:31,953
не походят для решения больших задач. И затем рассмотрели как улучшить их чтобы

88
00:08:31,953 --> 00:08:37,300
получить эффективный алгоритм. И затем взялись за приложения которые не могли

89
00:08:37,300 --> 00:08:42,768
бы быть решены без этих эффективных алгоритмов. Все это включает научный 

90
00:08:42,768 --> 00:08:47,954
метод для разработки алгоритма, где мы пытаемся разработать математическую модель которая помагает

91
00:08:47,954 --> 00:08:52,343
нам понять свойства алгоритма который мы разрабатываем. И затем

92
00:08:52,343 --> 00:08:56,675
мы тестируем эти модели через эксперементирование, позволяющее нам улучшить

93
00:08:56,675 --> 00:09:02,363
алгоритмы, разработать лучшие алгоритмы и более специфические модели то тех пор

94
00:09:02,363 --> 00:09:07,061
пока мы не получим, что нужно для решения практических задач, которые нам интересны. Это 

95
00:09:07,061 --> 00:09:12,165
в общем и целом будет общая структура изучения алгоритмов, которую мы будем 

96
00:09:12,165 --> 00:09:14,036
использовать в этом курсе.