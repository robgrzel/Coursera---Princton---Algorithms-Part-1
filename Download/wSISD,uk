1
00:00:03,054 --> 00:00:09,019
Вітаю! Сьогодні ми переглянемо 
декілька цікавих

2
00:00:09,019 --> 00:00:15,011
прикладів на таблиці символів та 
бінарний пошук деревоподібної структури даних

3
00:00:15,011 --> 00:00:21,413
для того щоб вирішувати задачі з геометрично прогресуючими
 даними. Отже,  подивимось. Ідея

4
00:00:21,413 --> 00:00:27,378
в тому, що ми поговоримо про
 геометричні об'єкти, не такі прості як

5
00:00:27,378 --> 00:00:33,338
строки та числа. Отже, ось приклад.
Скажімо, ваші геометричні об'єкти є точками

6
00:00:33,338 --> 00:00:38,346
на площині, і вказано прямокутник 
розташований на 

7
00:00:38,346 --> 00:00:43,404
вертикальній і горизонтальній осях.  І можливо
захочете запитати, які точки всередині

8
00:00:43,404 --> 00:00:48,200
прямокутника, або скільки точок всередині 
прямокутника? Або можливо те, що

9
00:00:48,200 --> 00:00:54,011
ви обробляєте і є прямокутники. У вас є
набір прямокутників, і ми хочемо дізнатись які

10
00:00:54,011 --> 00:01:00,291
з цих прямокутників перетинаються? Або скільки перетинів прямокутників ми маємо? Всі 

11
00:01:00,291 --> 00:01:05,837
ці цікаві задачі мають багато
і багато практичних застосувань, від

12
00:01:05,837 --> 00:01:11,806
комп'ютеризованого дизайну до ігр та фільмів
а також в абстакціях, як, наприклад, 

13
00:01:11,806 --> 00:01:17,849
бази даних, та інші ситуації, де ви можете
мати декілька ключів, або множинні виміри.

14
00:01:18,065 --> 00:01:24,856
І це також є дуже цікавим розширенням ідеї, 
які ми розглядали в таблицях символів

15
00:01:24,856 --> 00:01:30,175
у всіх видах знайомих нам 
застосувань. І, на диво, дерева 

16
00:01:30,175 --> 00:01:34,300
бінарного пошуку та ці похідні 
алгоритми, які ми розглядали, надають

17
00:01:34,300 --> 00:01:39,774
дуже ефективні рішення
багатьом важливим задачам в цій області.

18
00:01:39,774 --> 00:01:45,943
І дійсно започаткували нові галузі розвитку
та нові технологіх в усіх цих видах

19
00:01:45,943 --> 00:01:51,135
застосувань. Отже, для початку, ми 
поглянемо на просту задачу, яка називається

20
00:01:51,135 --> 00:01:56,761
одно-вимірний пошук. І це
справді ставить базу тому, що

21
00:01:56,761 --> 00:02:02,146
ми збираємось робити. Це таке-собі невелике
розширення символьної таблиці АРІ

22
00:02:02,146 --> 00:02:07,837
яку ми давали раніше, і ми збираємось
зробити операції пошуку діапазону і

23
00:02:07,837 --> 00:02:12,797
підрахунку діапазону. Отже, одно-вимірність означає
тільки те, що ми маємо єдиний ключ, отже ми вклали

24
00:02:12,797 --> 00:02:19,116
пари ключ-значення раніше і хочемо 
мати змгу знайти ключ і

25
00:02:19,116 --> 00:02:24,770
 значення прив'язане до нього, хочемо мати 
змогу видаляти. Але потім

26
00:02:24,770 --> 00:02:30,703
ми хочемо використати операції пошуку і підрахунку діапазону. 
Отже, знайдемо всі ключі, які знаходяться між двома

27
00:02:30,703 --> 00:02:36,083
даними ключами, або кількість ключів, які 
між двома даними ключами. Для цього

28
00:02:36,083 --> 00:02:42,251
прикладу, справа ми маємо вставити кількість
ключів і, ми просто побачимо їх

29
00:02:42,251 --> 00:02:47,992
у відсортованому порядку. Але потім ви, напевно, скажете
ну, і скільки ключів там 

30
00:02:47,992 --> 00:02:53,780
між  g та k? В такому випадку, там
тільки два. І потім клієнт може сказати

31
00:02:53,780 --> 00:02:59,598
Ну, і що ж за ключі ти 
хочеш повернути? І це досить  

32
00:02:59,598 --> 00:03:06,010
розповсюджена операція, принаймні в базах даних. 
Ви хочете повернути кількість платників подактів, що

33
00:03:06,010 --> 00:03:11,335
мають зарплатні між 1 млн і 10 
млн, і потім які з них ще щось і 

34
00:03:11,335 --> 00:03:17,431
так далі. Отже, діапазонний пошук це дуже
важлива, фундаментальна операціія. Зараз,

35
00:03:17,431 --> 00:03:23,459
в геометричній інтерпретації, ми тільки думаємо 
що ключі це точки на лінії. І 

36
00:03:23,459 --> 00:03:29,627
значення ключів - так само, визначені, як
точки на лінії. Ми можемо перетворити

37
00:03:29,627 --> 00:03:34,856
букви на числа, або наприклад, ключі
можуть бути числами. І потім нам лишилось

38
00:03:34,856 --> 00:03:41,119
знайти кількість точок 
на даному інтервалі в одному вимірі. Отже

39
00:03:41,575 --> 00:03:47,272
Як же ми це зробимо? 
Це базова задача, яка дуже схожа на 

40
00:03:47,272 --> 00:03:52,356
Задачу с таблицею символів. Ми
зберігаємо дані в 

41
00:03:52,356 --> 00:03:57,529
невідсортованому масиві. Просто додаєм їх у 
масив, і потім, -хоча додавання і справді

42
00:03:57,529 --> 00:04:03,254
щвидке. Ми просто додаєм в кінець масиву.
Нам можливо знадобиться змінювати розмір масиву

43
00:04:03,254 --> 00:04:08,371
щоб збільшити його. Але це
негарно, бо ключі мають великі числа

44
00:04:08,371 --> 00:04:13,899
і для того щоб знайти ключі, які
співпадають з даним діапазоном, доведеться

45
00:04:13,899 --> 00:04:19,711
перебрати по черзі всі ключі і перевірити
чи вони в діапазоні або ні, і повернути

46
00:04:19,711 --> 00:04:26,043
їх так само. Отже, ми потребуємо лінійного часу для 
великої кількості ключів. Якщо ви зберігаєте 

47
00:04:26,267 --> 00:04:32,638
дані в такому порядку, як у випадку бінарного 
пошуку, тоді вставлєте в порядку

48
00:04:32,638 --> 00:04:38,591
в якому знаходиться весь масив, можливо знадобиться
рухати більші елементи на наступні позиції

49
00:04:38,596 --> 00:04:44,209
і так далі, або елементарні застосування 
бінарного пошуку, які ми робили, коли робили таблиці символів.

50
00:04:44,406 --> 00:04:49,662
Отже, час вставки може бути лінійним, 
але потім ви можете використати бінарний

51
00:04:49,662 --> 00:04:55,329
пошук і подивитись на два крайніх елемента
це займе час 

52
00:04:55,329 --> 00:05:00,631
пропорційний до логіна. І потім
ви можете зрозуміти скільки ключів

53
00:05:00,631 --> 00:05:06,243
там є, або повернути їх всі за
індексами, найменшого в діапазоні, і 

54
00:05:06,243 --> 00:05:12,027
найбільшого в діапазоні. Отже, це
елементарні застосування є 

55
00:05:12,027 --> 00:05:18,179
неприйнятними для великої кількості ключів, бо
час, що витрачається на це - лінійна величина. 

56
00:05:18,179 --> 00:05:24,035
В дійсності ми хочемо витратити час
пропорційний до входу. Для вставки і

57
00:05:24,035 --> 00:05:29,186
для розрахунків. Для діапазонного пошуку, 
звісно, ми маємо взяти всі ключі, 

58
00:05:29,186 --> 00:05:35,413
які повертаємо, отже час роботи програми 
буде пропорційним до кількості

59
00:05:35,413 --> 00:05:43,042
ключів, які співпадають. Але у будь-якому разі, 
це розумні цілі. І їх легко

60
00:05:43,042 --> 00:05:51,545
Досягти. Отже [кашель] , що це 
одно-вимірний діапазонний пошук?

61
00:05:51,545 --> 00:05:58,014
Ми збираємось просто зберігати
ключі в дереві бінарного пошуку і ми

62
00:05:58,014 --> 00:06:03,484
подивились на застосування функції
діапазонування для дерев бінарного пошуку де

63
00:06:03,484 --> 00:06:09,342
для кожного ключа ми можемо порахувати
кількість ключів, які менші за

64
00:06:09,342 --> 00:06:15,508
наш ключ. Тобто, в цьому випадку, діапазон е - 2,
а h - 3 і т.д. Отже,

65
00:06:15,508 --> 00:06:21,413
в дереві бінарного пошуку, номери діапазонів розсташовані
у порядку зростання, що ми робимо

66
00:06:21,413 --> 00:06:27,662
перетинаючи масив, і це легко
обчислити. Необхідно зберігати сортоване дерево

67
00:06:27,662 --> 00:06:33,813
як поле, яке має розмір
 дерева, і легко вирахувати 

68
00:06:33,813 --> 00:06:40,760
рівень від цього. Отже, скільки ключів
між., скажімо e та s? Один, два, три

69
00:06:40,760 --> 00:06:51,297
чотири, п'ять Це власне просто 
різниця між ними плюс 1, якщо 

70
00:06:51,623 --> 00:07:00,361
найвищий  [кашель] елемент діапазону
знаходиться в таблиці і над ним немає ще одного. Отже,  

71
00:07:00,361 --> 00:07:08,274
між  e та s міститься така ж кількість ключів,
як і між e та t - 5. 

72
00:07:08,274 --> 00:07:15,192
Між f та t, є тільки чотири. Отже,
дійсно одно-вимірний рахунок 

73
00:07:15,192 --> 00:07:22,412
дуже легко обчислити,
за допомогою дерева бінарного пошуку. 

74
00:07:22,412 --> 00:07:28,297
Кількість вузлів, що ми розглядаємо коли
здійснюємо пошук рівний довжині шляху

75
00:07:28,297 --> 00:07:33,789
 пошуку до нижньої межі, плюс довжині пошуку
шляху до верхньої межі щоб знайти їх інтервали

76
00:07:33,976 --> 00:07:39,595
і цей час є пропорційним до log N.[кашель]. 
Так і в діапазонному пошуці. 

77
00:07:39,595 --> 00:07:46,018
Ми просто виконуємо рекурсивний пошук і
щоб знайти всі ключі між нижнім та верхнім

78
00:07:46,214 --> 00:07:51,472
ми дивимся на ліве піддерево, чи якийсь із них 
співпадає з діапазоном. Ми дивимось на

79
00:07:51,472 --> 00:07:57,106
поточний вузол і на праве 
піддерево, чи один із них співпадає з

80
00:07:57,106 --> 00:08:02,555
діапазоном. І це легко сказати, чи 
якийсь з них співпадає, просто 

81
00:08:02,555 --> 00:08:08,476
перевіривши чи їх діапазони перетинають
кореневий, чи ні. Отже, якщо ми шукаємо

82
00:08:08,476 --> 00:08:14,469
всі ключі між f і t, тоді ми повинні
подивитись на обидва піддарева кореневого s.

83
00:08:14,469 --> 00:08:19,643
Але ми не будемо дивитись на ліве 
піддерево від е, бо всі ключі там менші

84
00:08:19,643 --> 00:08:26,018
ніж е, і тому менші за f. Отже
нам непотрібно туди дивитись. Але

85
00:08:26,018 --> 00:08:31,419
з іншого боку, це проста модифікація
рекурсивного дерева пошуку щоб знайтти всі ключі

86
00:08:31,635 --> 00:08:37,702
і легко побачити за часом виконання програми,
що ввін буде пропорційний до

87
00:08:37,702 --> 00:08:47,518
кількості повернених ключів плюс  log N. Тобто
це одно-вимірний дистанційний пошук з використанням

88
00:08:47,518 --> 00:08:51,040
дерева бінарного пошуку.