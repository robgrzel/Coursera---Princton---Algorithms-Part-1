1
00:00:01,880 --> 00:00:06,015
지난 섹션에서 했듯이 실행 결과를 관찰하면

2
00:00:06,015 --> 00:00:09,270
성능을 예측하는 방법을 얻을 수 있지만, 이것만으론

3
00:00:09,270 --> 00:00:12,880
알고리즘의 동작을 이해하는 데에는
 사실 도움이 되지 않습니다.

4
00:00:12,880 --> 00:00:15,179
그래서 수학 모델들을 살펴보려고 합니다.

5
00:00:15,179 --> 00:00:21,430
이 모델들은 실제로 무슨 일이 일어나는지에 대한
 더 나은 개념을 제공해줍니다.

6
00:00:21,430 --> 00:00:25,785
다시 말하지만, 이 개념은 사실
 1960년대 후반에 Donald Knuth 교수에 의해

7
00:00:25,785 --> 00:00:31,705
개발되고 보급되었습니다.

8
00:00:31,705 --> 00:00:37,140
그 때에는 컴퓨터 시스템이 처음으로
 정말 복잡해지기 시작하였고

9
00:00:37,140 --> 00:00:40,140
따라서 컴퓨터 과학자들은

10
00:00:40,140 --> 00:00:45,475
컴퓨터에서 일어나는 일을 이해하는 것이
 가능한지에 대해 고민하였습니다.

11
00:00:45,475 --> 00:00:52,860
이 때, Knuth 교수는 수학적 모델이 우리가
 확실하게 할 수 있는 것이라고 강하게 주장했습니다.

12
00:00:52,860 --> 00:00:56,610
우리는 프로그램의 총 실행시간을 계산할 수 있는데,

13
00:00:56,610 --> 00:01:01,110
기본 연산들을 모두 특정(identifying)하고

14
00:01:01,110 --> 00:01:02,430
(컴퓨터나 컴파일러에 의존적인
 연산 별) 비용을 이해하고

15
00:01:02,430 --> 00:01:04,950
(각 연산의) 실행 빈도를 이해한 뒤

16
00:01:04,950 --> 00:01:09,089
모든 연산에 대해,
 비용과 빈도를 곱한 값을 더하면 됩니다.

17
00:01:09,089 --> 00:01:13,530
따라서 분석하려는 프로그램이
 어떤 집합의 연산을 가지고 있는지,

18
00:01:13,530 --> 00:01:15,060
사용하려는 컴퓨터에 따라
 어떤 비용이 발생되는지를 분석하여야 합니다.

19
00:01:15,060 --> 00:01:18,820
그리고 컴퓨터 시스템의 컴퓨터 외에도,
 앞에서 말했듯이

20
00:01:18,820 --> 00:01:21,360
각 연산의 실행 빈도는 수학을 필요로 하는데,

21
00:01:21,360 --> 00:01:25,145
이는 실행 빈도가 알고리즘과
 입력 데이터에 의존적이기 때문입니다.

22
00:01:25,145 --> 00:01:27,750
Knuth 교수는 (TAOCP라 불리는)
 책 시리즈를 저술하였는데, 그 시리즈에서

23
00:01:27,750 --> 00:01:31,680
특정한 컴퓨터 모델을 가정한 뒤,
 매우 자세하고 정확한 분석을

24
00:01:31,680 --> 00:01:36,430
넓은 범위의 알고리즘에 대해 진행하였습니다.

25
00:01:36,430 --> 00:01:39,000
따라서 Knuth를 따라, 원리적으로는

26
00:01:39,000 --> 00:01:43,005
동작하는 알고리즘이나 프로그램에 대한
 정확한 수학적 모델을

27
00:01:43,005 --> 00:01:48,155
얻을 수 있게 됩니다.

28
00:01:48,155 --> 00:01:51,879
이제, 이 과정의 상세를 살펴봅니다.

29
00:01:51,879 --> 00:01:54,490
(기본 연산의 비용을 알기 위해서)
 필요하다면 여러분은

30
00:01:54,490 --> 00:01:57,670
실험을 하면 됩니다.
 옛날에는

31
00:01:57,670 --> 00:02:01,240
실제로 컴퓨터 매뉴얼을 보고,

32
00:02:01,240 --> 00:02:03,835
아, 그 시절엔 모든 컴퓨터의 매뉴얼에는

33
00:02:03,835 --> 00:02:07,330
(연산에 대응하는) 각 명령어의 실행 시간을
 정확히 명시했습니다. (즉, 매뉴얼만으로 비용을 알 수 있죠.)

34
00:02:07,330 --> 00:02:10,840
지금은 꽤 많이 복잡해져서 실험을 해야 합니다.

35
00:02:10,840 --> 00:02:16,090
실제로 10억번 Add 연산을 해본 뒤
 (평균을 내보면), 여러분 컴퓨터에서

36
00:02:16,090 --> 00:02:18,640
Add 연산 하나가 약 2.1 나노초가 걸릴 겁니다.

37
00:02:18,640 --> 00:02:23,035
또는 Sin 함수나 Arctan 함수와 같은 더 복잡한 연산을 해볼수도 있습니다.

38
00:02:23,035 --> 00:02:28,060
그 함수들을 구성하는 알고리즘의
 분석 결과와 거의 같아지겠지만요.

39
00:02:28,060 --> 00:02:33,390
이제 기본 연산에 대한 비용을
 결정하는 한 방법을 얻었습니다.

40
00:02:33,390 --> 00:02:38,485
그리고 앞으로 대부분의 경우에

41
00:02:38,485 --> 00:02:40,780
그 비용은 어떤 상수값이라고 상정할 겁니다.

42
00:02:40,780 --> 00:02:42,874
또한 (앞의 방법에 따라)
 그 상수값을 구해낼 수 있겠죠.

43
00:02:42,874 --> 00:02:48,445
다만, N 개의 객체로 구성된
 집합(collection)을 다루는 연산은

44
00:02:48,445 --> 00:02:52,300
N에 비례할 수도 있습니다. 마찬가지로

45
00:02:52,300 --> 00:02:55,644
크기가 N인 배열을 할당한다면

46
00:02:55,644 --> 00:03:00,314
N에 비례한 시간이 걸릴텐데,
 이는 Java의 경우

47
00:03:00,314 --> 00:03:06,795
기본적으로 배열의 원소를 0으로
 초기화하도록 되어있기 때문입니다.

48
00:03:06,795 --> 00:03:12,190
다른 연산들도, 시스템 구현에 따라 달라집니다.

49
00:03:12,190 --> 00:03:14,920
중요한 것을 하나 꼽으면,
 문자열 접합(concatenation)이 있는데

50
00:03:14,920 --> 00:03:17,110
(문자열 접합 연산으로)
 두 문자열을 연이어 붙이면

51
00:03:17,110 --> 00:03:21,240
그 실행 시간은
 문자열의 길이 N에 비례합니다.

52
00:03:21,240 --> 00:03:24,459
많은 프로그래밍/Java 초보자들이

53
00:03:24,459 --> 00:03:27,755
'모든 연산이 상수 실행 시간을
 갖는다'고 가정하는 실수를 범하는데

54
00:03:27,755 --> 00:03:30,910
아닌 경우도 있습니다. 자, 이제까지

55
00:03:30,910 --> 00:03:35,180
각 연산의 비용에 대해서 이야기했고요.

56
00:03:35,180 --> 00:03:41,990
더 재미있는 주제는 (알고리즘이나
 프로그램을) 실행하는 중에 연산의 실행 빈도입니다.

57
00:03:41,990 --> 00:03:48,445
여기에 3-합 문제의 간단한 변형으로
 1-합 문제의 알고리즘이 있습니다.

58
00:03:48,445 --> 00:03:50,610
이 알고리즘은 배열에 0인 원소의 개수를

59
00:03:50,610 --> 00:03:53,285
세고 있습니다. (역주: 원어 설명은 오류)

60
00:03:53,285 --> 00:03:55,209
이 알고리즘은 단 하나의
 for 루프를 가지고 있고요.

61
00:03:55,209 --> 00:03:59,460
따라가보면 특정 원소의 값이 0인지 검사해서
 count 변수를 1 증가시킴을 알 수 있습니다.

62
00:03:59,460 --> 00:04:02,560
그리고 코드를 분석하면

63
00:04:02,560 --> 00:04:07,645
i와 count라는 변수가 선언(declaration)이 되어있고요. (빈도: 2)

64
00:04:07,645 --> 00:04:10,555
각 변수의 초기값은 0으로 할당(assignment)되어야 합니다. (빈도: 2)

65
00:04:10,555 --> 00:04:14,563
(for 루프를 도는 과정에서) i와 N을 비교하는
 연산 횟수가 N+1 번 있고요. (빈도: N+1)

66
00:04:14,563 --> 00:04:16,748
a[i]가 0과 같은지를 비교하는 연산이

67
00:04:16,748 --> 00:04:19,534
N 번 있고, 이와 병행하는 N 번의
 배열 접근 연산이 발생합니다.

68
00:04:19,534 --> 00:04:21,730
증가(increment) 연산의 경우,

69
00:04:21,730 --> 00:04:25,380
즉, 증가 연산의 실행 빈도는 (입력에 따라) 다릅니다.

70
00:04:25,380 --> 00:04:27,940
변수 i는 정확히 N 번 증가하지만,
 변수 count는

71
00:04:27,940 --> 00:04:31,465
(입력에 따라) 0부터 N 사이의
 어떤 수만큼 증가할 수 있습니다.

72
00:04:31,465 --> 00:04:34,960
따라서 그 실행 빈도는 입력 데이터에 의존적이며

73
00:04:34,960 --> 00:04:39,755
이를 설명하기 위한 수학적 모델을 필요로 합니다.

74
00:04:39,755 --> 00:04:42,055
아니면, 예를 들어

75
00:04:42,055 --> 00:04:47,135
다른 연산이 매우 비싸서, (입력 데이터에
 의존적인 실행 빈도를) 신경쓸 필요가 없을 수도 있습니다.

76
00:04:47,135 --> 00:04:50,830
다음으로 좀 더 복잡한 문제를 살펴봅시다.

77
00:04:50,830 --> 00:04:55,030
이 프로그램에서의 명령어 실행 빈도를 살펴봅시다.

78
00:04:55,030 --> 00:04:56,775
이 문제는 2-합 문제라 불립니다.

79
00:04:56,775 --> 00:05:00,149
즉, 정수 배열 내에서 조합한 쌍의 합이
 0이 되는 경우의 수가 궁금합니다.

80
00:05:00,149 --> 00:05:06,640
이 경우, 동작을 살펴보기 위해
 조금 수학을 해야하고

81
00:05:06,640 --> 00:05:10,794
i가 0에서 N까지 증가하고,
 j가 i+1에서 N까지 증가할 때

82
00:05:10,794 --> 00:05:14,075
비교 연산을 수행하는 횟수,

83
00:05:14,075 --> 00:05:16,825
아, 그게 아니라 배열에의 접근은

84
00:05:16,825 --> 00:05:23,956
a[i]와 a[j]를 읽기 위해 (붉은 색)
 문장이 실행될 때마다 2 번실행되고

85
00:05:23,956 --> 00:05:27,235
그 문장이 실행되는 횟수는

86
00:05:27,235 --> 00:05:30,382
(외곽) for 루프의 첫 번째 실행(i=0일 때)에는 N-1번이고

87
00:05:30,382 --> 00:05:32,740
두 번째 실행에선 N-2이며,
 이 경향을 유지하므로

88
00:05:32,740 --> 00:05:38,500
그 붉은 색 문장의 실행 횟수는
 0부터 N-1까지의 정수의 합인데

89
00:05:38,500 --> 00:05:44,530
이는 합 공식으로 (1/2)*N(N-1)이고,
 따라서 이 공식에 두 배를 하면

90
00:05:44,530 --> 00:05:48,275
배열에 접근한 횟수를 계산할 수
 있어서, 그 값은 N(N-1)입니다.

91
00:05:48,275 --> 00:05:52,615
비슷하게 해보면 (슬라이드에 나온 것과
 같은) 정확한 횟수를 셀 수 있습니다.

92
00:05:52,615 --> 00:05:58,105
하지만, 살펴보았듯, 실제
 해보려면 좀 지루하긴 합니다.

93
00:05:58,105 --> 00:06:01,713
그리고, 튜링으로 돌아가 이야기해보면,

94
00:06:01,713 --> 00:06:05,060
튜링은 배비지가 그러했듯이

95
00:06:05,060 --> 00:06:09,556
계산 과정에서 발생하는 일의 양에 대한
 척도(measure)를 가질 필요가 있음을 알았고,

96
00:06:09,556 --> 00:06:15,810
또한 그렇다고 해도 그 상세를
 완전히 알 필요는 없음 또한 알았습니다.

97
00:06:15,810 --> 00:06:18,925
대략적인 추정만 가져도 꽤 도움이 된다는 거죠.

98
00:06:18,925 --> 00:06:22,330
따라서, 여러분은 모든 연산이
 적용되는 횟수를 셀 수 있고,

99
00:06:22,330 --> 00:06:27,200
(비용에 따른) 비중을 부여해
 대략적으로 셀 수도 있겠지만,

100
00:06:27,200 --> 00:06:32,045
가장 비싼 연산만 세면 될 수도 있습니다.

101
00:06:32,045 --> 00:06:36,000
이것이 Turing이 1947년에 발언한 것입니다.

102
00:06:36,000 --> 00:06:40,330
실질적으로 우리가 지금도 하고 있는 것이죠.

103
00:06:40,330 --> 00:06:46,585
따라서 모든 세세한 디테일을
 고려하고 세는 것 대신에

104
00:06:46,585 --> 00:06:50,415
기본적인 연산을 특정한 뒤에 그 중

105
00:06:50,415 --> 00:06:56,920
가장 비싼 연산, 가장 자주 실행되는 연산

106
00:06:56,920 --> 00:06:59,811
그리고 비용과 실행 빈도의 곱이 가장 높은 연산 등을

107
00:06:59,811 --> 00:07:02,520
정확한 실행 시간에 대한 대체품으로 사용합니다.

108
00:07:02,520 --> 00:07:05,040
근본적으로, 실행시간에 관한 가설을 세우기 위함이죠.

109
00:07:05,040 --> 00:07:09,720
'실행 시간이 그 대체품과 상수의
 곱으로 증가할 것이다'라는.

110
00:07:09,720 --> 00:07:13,425
이 경우에는, 배열 접근(array access)
을 살펴봤던 것이죠.

111
00:07:13,425 --> 00:07:15,675
그게 첫 번째 단순화 작업이었고요.

112
00:07:15,675 --> 00:07:17,640
두 번째로 우리가 하려는 단순화 작업은

113
00:07:17,640 --> 00:07:22,174
우리가 유도한 공식에서
 낮은 차수 항을 무시하는 겁니다.

114
00:07:22,174 --> 00:07:24,355
이를 쉽게 하기 위해서

115
00:07:24,355 --> 00:07:27,610
물결표(tilde)를 사용한 표기법을 쓸 건데요.

116
00:07:27,610 --> 00:07:29,610
그 표기법의 아이디어는

117
00:07:29,610 --> 00:07:33,575
가리키고 있는 식과 같이 어떤 식에서 N이 클 때,

118
00:07:33,575 --> 00:07:39,615
여기 N^3 항은 N 항이나 상수항(16)보다
 훨씬 훨씬 크다는 겁니다.

119
00:07:39,615 --> 00:07:45,990
사실, 낮은 차수 항이 있는지도 모를 정도로 큽니다.

120
00:07:45,990 --> 00:07:50,570
따라서, 여기에 있는 모든 식들은 (1/6)*N^3에
 근사하는데, 이를 물결표로 나타냅니다.

121
00:07:50,570 --> 00:07:56,824
즉, 우변은 좌변이 갖는 양의 괜찮은
 대체값(representative) 또는 근사값이 됩니다.

122
00:07:56,824 --> 00:07:59,790
이런 표기법은 이와 같이 낮은 차항을 버려서

123
00:07:59,790 --> 00:08:03,110
계산을 매우 단순화시킵니다.

124
00:08:03,110 --> 00:08:09,528
지금까지 특정한 연산의 성능에 집중해
 물결표 표기법으로 낮은 차수 항을 버리는 걸 보았고요.

125
00:08:09,528 --> 00:08:12,554
여기에 물결표에 대한 기술적 정의가 있는데

126
00:08:12,554 --> 00:08:17,795
f(N) tilde g(N)은 N이 무한대로 갈 때,
 f(N) 나누기 g(N)에 대한 극한값이 1임을 의미합니다.

127
00:08:17,795 --> 00:08:23,720
쉽게 앞의 상황에서 그 정의가
 들어맞음을 확인할 수 있을 겁니다.

128
00:08:23,720 --> 00:08:28,225
따라서 이 표기법은 실행 빈도를
 세는 것을 매우 단순화시킵니다.

129
00:08:28,225 --> 00:08:29,940
여기서 한 개 뽑아서 살펴보면

130
00:08:29,940 --> 00:08:33,540
예를 들어 여기 tilde N^2를 떠올려보면

131
00:08:33,540 --> 00:08:39,145
2-합 문제에서 increment 연산이 tilde N^2이죠.

132
00:08:39,145 --> 00:08:42,360
따시 말하면, N이 크면 작은 차수 항들은 무시할 수 있고요.

133
00:08:42,360 --> 00:08:45,174
N이 충분히 작으면, 그 항들을 그냥 무시할 수는 없습니다.

134
00:08:45,174 --> 00:08:49,080
하지만, 걱정할 필요는 없는 게, 우리는
 큰 N에 대해 실행 시간을 예측하려고 하고 있지,

135
00:08:49,080 --> 00:08:55,065
작은 N에 대해서 실행 시간이 어떻게 될 지
 예측하려 하진 않고 있습니다. 좋습니다.

136
00:08:55,065 --> 00:08:57,600
이제, 우리는

137
00:08:57,600 --> 00:09:03,299
비용 모델과 물결표 표기법을 써서, 간단히

138
00:09:03,299 --> 00:09:08,010
이 프로그램이 tilde N^2의 배열 접근을
 필요로 한다고 말할 수 있죠.

139
00:09:08,010 --> 00:09:13,225
이는 암묵적으로 우리가 생각하는 실행 시간이
 상수 곱하기 N^2에 근사할 것이라고

140
00:09:13,225 --> 00:09:16,870
가설을 세우고 있는 겁니다.

141
00:09:16,870 --> 00:09:18,815
좋습니다. 그럼 3-합 문제는 어떻습니까?

142
00:09:18,815 --> 00:09:21,240
이 실제적인 문제에 도전해봅시다.

143
00:09:21,240 --> 00:09:24,885
여기 3 개의 for 루프가 있고요.

144
00:09:24,885 --> 00:09:30,234
훨씬 복잡한 조합(combinatorial)
 문제를 풀어야 합니다.

145
00:09:30,234 --> 00:09:33,105
사실 그렇게 어렵지는 않습니다만.

146
00:09:33,105 --> 00:09:40,855
N 개 중에 서로 다른 세 개를 고르는
 경우의 수를 생각해야 하는데

147
00:09:40,855 --> 00:09:44,950
이항 정리(binomial theorem) 공식의 한 계수입니다.

148
00:09:44,950 --> 00:09:48,149
다시 수학 공식을 적용하고
 물결표 표기법을 써보면

149
00:09:48,149 --> 00:09:52,950
세 수에 대한 각각의 경우에 세 번의
 배열 접근을 하고, for 루프의 횟수는 (1/6)*N^3이니

150
00:09:52,950 --> 00:09:55,865
정리해서 tilde (1/2)*N^3 번의 배열 접근을 합니다.

151
00:09:55,865 --> 00:10:02,520
여기서 모든 연산의 비용을 더해
 계산을 하지는 않았습니다.

152
00:10:02,520 --> 00:10:04,060
그 작업은 꽤나 고생이죠.

153
00:10:04,060 --> 00:10:07,860
우리는 비용과 실행 빈도의 곱 중 가장 비싼 것을 골라

154
00:10:07,860 --> 00:10:10,920
근사함으로써 실행 시간에 대한 좋은 모델을

155
00:10:10,920 --> 00:10:15,950
얻으려고 한 겁니다.

156
00:10:15,950 --> 00:10:22,480
이제, 이 수업에선 이산 수학(discrete mathematics)을
 제대로 할 생각은 없습니다만

157
00:10:22,480 --> 00:10:24,600
기본적인 건 아셔야 합니다.

158
00:10:24,600 --> 00:10:31,705
앞으로 사용할 것 정도는요.
 이해하기 어렵지 않습니다.

159
00:10:31,705 --> 00:10:32,895
앞으로 자주

160
00:10:32,895 --> 00:10:35,850
이산 합 공식의 추정값을

161
00:10:35,850 --> 00:10:39,754
활용할 필요가 있는데요.
 앞에서 1+2+...+N에 대해서는 했죠.

162
00:10:39,754 --> 00:10:45,380
또는 (여기엔 없지만) 제곱 수의 합이라든가,
 3-합 문제에서 나온 3 번의 for 루프의 횟수 등이 있습니다.

163
00:10:45,380 --> 00:10:49,395
사실 기본 미적분학 수업을 들었다면

164
00:10:49,395 --> 00:10:53,750
생각해 볼 한 방법으로는, 합 공식을
 대응하는 구간에 대한 정적분으로 바꿔볼 수 있습니다.

165
00:10:53,750 --> 00:10:56,850
보통 잘 먹히고, 수학을 좀 해보면

166
00:10:56,850 --> 00:11:01,860
소위 오일러-매클로린(Euler-Maclaurin) 합 공식을
 진짜 근사값을 구하기 위해 쓸 수 있습니다.

167
00:11:01,860 --> 00:11:03,450
하지만 이런 식으로 생각하더라도

168
00:11:03,450 --> 00:11:08,759
역시 N^2의 절반에 근사함을 앎으로써
 앞의 논의를 믿을 수 있을 겁니다.

169
00:11:08,759 --> 00:11:13,230
또는, 1 + 1/2 + 1/3 + ... + 1/N은

170
00:11:13,230 --> 00:11:18,705
1부터 N까지 1/x를 x에 대해 정적분한 것과
 거의 같은데, 그 결과는 자연 로그 ln N입니다.

171
00:11:18,705 --> 00:11:21,510
이제 3-합에서의 세 수에 관한 루프에서는,

172
00:11:21,510 --> 00:11:24,585
다중 적분(multiple integral)을 사용해보면

173
00:11:24,585 --> 00:11:27,965
빠르게 (1/6) N^3임을 알 수 있습니다.

174
00:11:27,965 --> 00:11:33,035
우리가 쓸 수 있는 많은, 다양한 기법들이 있습니다.

175
00:11:33,035 --> 00:11:34,830
이 모두를 가르칠 수는 없지만요.

176
00:11:34,830 --> 00:11:39,860
하지만 이런 종류의 결과들을
 때때로 참고할 겁니다.

177
00:11:39,860 --> 00:11:42,390
좋습니다, 원리적으로 Knuth 교수는

178
00:11:42,390 --> 00:11:47,335
정확한 수학적 모델이 활용가능함을 알려줬지요.

179
00:11:47,335 --> 00:11:51,600
실제로는, 훨씬 복잡한 공식을 얻게 될 수 있습니다.

180
00:11:51,600 --> 00:11:57,850
이론가들이 다룰만한 고급 수학을
 필요로 할 수도 있고요.

181
00:11:57,850 --> 00:12:00,490
하지만 아마도

182
00:12:00,490 --> 00:12:05,260
처음 알고리즘을 배우는 사람들이라면
 알고 있을 것이라 기대하진 않겠지만요.

183
00:12:05,260 --> 00:12:07,825
정리하면

184
00:12:07,825 --> 00:12:13,270
숙고해 만들어진 정확한 모델은
 전문가에게 남겨두는 게 최선이고요.

185
00:12:13,270 --> 00:12:16,100
해야할 게 정말 많으니까요.

186
00:12:16,100 --> 00:12:21,260
반면, 근사 모델은 따라해 볼 가치가
 정말로 충분합니다.

187
00:12:21,260 --> 00:12:24,434
우리가 생각할 모든 알고리즘에 대해서

188
00:12:24,434 --> 00:12:26,410
앞으로 실행 시간을 설명하는데 사용될 수 있는

189
00:12:26,410 --> 00:12:32,575
합리적인 근사 모델에 대해 토론할 겁니다.

190
00:12:32,575 --> 00:12:36,670
때때로, 수학적 증명을 다룰 수도 있고,

191
00:12:36,670 --> 00:12:41,900
때로는 어떤 전문가의 결과물을
 인용해야 만 하는 경우도 있을 겁니다.