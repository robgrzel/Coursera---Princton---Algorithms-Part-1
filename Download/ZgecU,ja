1
00:00:02,022 --> 00:00:08,015
さて、高速findは巨大な問題には
遅すぎます。では、どうやってより良く実行しましょうか？

2
00:00:08,015 --> 00:00:14,035
最初に、高速unionと呼ばれる
代替案を試します。

3
00:00:14,035 --> 00:00:20,082
これは、いわゆる遅延評価のアプローチで、
する必要があるまで仕事を

4
00:00:20,082 --> 00:00:27,506
しないでおくというものです。このアルゴリズムでは、
サイズMの同じデータ構造、配列IDを使いますが、

5
00:00:27,506 --> 00:00:34,280
今度は異なる解釈をします。
私たちは、この配列を

6
00:00:34,280 --> 00:00:41,298
フォレストと呼ばれる木の集合として解釈します。
スライドの右に示したようなものです。

7
00:00:41,298 --> 00:00:49,468
配列の各要素は、木の親への参照を含んでいます。

8
00:00:49,468 --> 00:00:57,425
たとえば、3の親は4で、4の親は9です。
ですので、配列の3の要素は4であり、

9
00:00:57,425 --> 00:01:06,681
4の要素は9です。ここで、配列の各要素は
ルートに関連付けられています。

10
00:01:06,681 --> 00:01:13,179
各要素の木のルートです。
要素は、すべてそれ自体が

11
00:01:13,179 --> 00:01:19,303
自分につながったコンポーネントなので、
自分自身を指しています。ですので1は1を指しています。

12
00:01:19,303 --> 00:01:26,108
しかし、同様に9も自分自身を指しています。
これは木のルートであり、

13
00:01:26,108 --> 00:01:32,419
2と4と3を含んでいます。つまり、このデータ構造から、
各要素とルートとを関連付けることができます。

14
00:01:32,419 --> 00:01:40,202
接続されたコンポーネントを
代表するのがルートと言うことですね。

15
00:01:40,202 --> 00:01:47,044
ですので、3のルートは9です。たどっていくと
ルートに行き着きます。

16
00:01:47,044 --> 00:01:52,956
さて、いったんルートが計算できれば
find操作は実装できます。接続されているか

17
00:01:52,956 --> 00:01:57,592
確かめようとしている2要素が同じルートを
持っているかを確かめれば良いだけです。

18
00:01:57,592 --> 00:02:02,373
これは、同じ接続コンポーネントを持っているか、
というのと同じことです。

19
00:02:02,373 --> 00:02:09,240
各要素のルートを探すのは少し作業がいりますが、
unionはとても簡単です。

20
00:02:09,240 --> 00:02:15,254
2つの異なる要素を含んだコンポーネントを
結合するには、ここでの2要素は

21
00:02:15,254 --> 00:02:21,613
異なるコンポーネントと考えられますが、
PのルートIDをQのルートIDに設定するだけで良いです。

22
00:02:21,613 --> 00:02:28,748
ではPの木をQを指すようにしましょう。
この場合では、9のエントリを

23
00:02:28,748 --> 00:02:35,027
6にすることで、3と5とを結合します。この木は3と5を含んでいますので。

24
00:02:35,027 --> 00:02:41,317
そして、配列内の1つの値を変更するだけで
2つの大きなコンポーネントを

25
00:02:41,317 --> 00:02:46,295
結合できます。これが高速unionアルゴリズムです。
なぜなら、union操作が

26
00:02:46,295 --> 00:02:52,429
配列内の1要素を変更するだけで良いからです。
find操作は少し作業が必要です。

27
00:02:52,429 --> 00:02:57,907
それでは実装を見てみましょう。
まず1つの操作例をデモで見てみます。

28
00:02:57,907 --> 00:03:03,569
ここでは、繰り返しになりますが、
同じ方法で開始しますが、配列の要素の考え方は

29
00:03:03,569 --> 00:03:09,415
それぞれの要素が小さな木になっており、
ノードは自分自身を指していると考えます。

30
00:03:09,415 --> 00:03:15,284
自分自身の木のルート、ということです。
ここで、4を3を同じコンポーネントに入れる必要があれば

31
00:03:15,284 --> 00:03:21,236
1番目の要素の入ったコンポーネントの
ルートを取り出し、

32
00:03:21,236 --> 00:03:26,624
これを2番目の要素の入ったコンポーネントの
ルートの子とすれば良いだけです。

33
00:03:26,624 --> 00:03:33,029
この場合では、4の親を3とするだけです。

34
00:03:33,259 --> 00:03:39,823
それから3と8。ここでも繰り返しますが、
最初の要素を取り出し、それを2番目の要素を

35
00:03:39,823 --> 00:03:47,532
含んだ木のルートの子とします。ですので、
3,4,8が同じコンポーネント内にあることになります。

36
00:03:47,532 --> 00:03:56,434
6と5ですね。6が5の下に付きます。
9と4ですね。ここで、4は

37
00:03:56,434 --> 00:04:06,045
4を含んだ木のルートは8で、
9を含んだ木のルートは8ですので、

38
00:04:06,045 --> 00:04:13,745
9を8の子とします。
2と1ですね。これは簡単です。

39
00:04:14,007 --> 00:04:20,993
ここで、8と9が接続されているか
チェックを受ければ、それらが同じルートを

40
00:04:20,993 --> 00:04:28,011
持つかどうかだけチェックします。
5と4の場合、4のルートは8です。

41
00:04:28,011 --> 00:04:34,230
5はルートが5ですから違います。
接続されていません。

42
00:04:34,230 --> 00:04:42,339
5と0ですね。5が0の子になります。
7と2ですね。

43
00:04:42,339 --> 00:04:52,836
7が2のルートである1の子になります。
6と1ですね。6のルートは0で

44
00:04:52,836 --> 00:05:00,636
1は自分がルートなので、0がその子になります。
union操作の1つ1つが

45
00:05:00,636 --> 00:05:10,069
単純に配列の1要素を変更するだけです。
最後に7と3ですね。

46
00:05:10,069 --> 00:05:18,755
7のルートは1で3のルートは8ですので、
1が8の子となります。いいでしょう。

47
00:05:18,755 --> 00:05:26,012
これで1つのコンポーネントを得、
すべての要素がつながりました。

48
00:05:26,012 --> 00:05:32,668
では高速unionの実装コードを見てみましょう。
コンストラクタは同じです。

49
00:05:32,668 --> 00:05:40,967
配列を作り、各要素が自分自身をルートに設定します。
ここで、

50
00:05:40,967 --> 00:05:46,005
privateメソッドを作っていて、
ルートを探す処理を実装しています。

51
00:05:46,005 --> 00:05:51,352
iがiのID値と等しくなるまで親への参照を追いかけます。

52
00:05:51,352 --> 00:05:57,369
等しくなければ、iを木の一段上に移動させます。
iをiのID値に設定するのですね。

53
00:05:57,369 --> 00:06:02,005
それを返り値とします。ですので、どのノードから始めても
ID値がiのID値と等しいものに

54
00:06:02,005 --> 00:06:07,396
なるまで追いかけ、つまりルートにたどり着きます。
これはprivateメソッドであり

55
00:06:07,396 --> 00:06:11,959
findおよびconnected操作の実装に使用します。

56
00:06:11,959 --> 00:06:17,316
同じかどうかのチェックには、Pのルートと
Qのルートを見つければよいだけです。

57
00:06:17,316 --> 00:06:23,342
union操作は簡素化しており、2つの要素の
ルートを探し、第1引数のIDを

58
00:06:23,342 --> 00:06:30,310
第2引数のそれに設定するだけです。
高速findよりコード量は少ないです。

59
00:06:30,310 --> 00:06:37,139
forループがありません。少し心配する
必要のあるwhileループが一個ありますが。

60
00:06:37,139 --> 00:06:43,326
しかし、これは高速でエレガントなコード実装で、
動的接続問題を解くものです。

61
00:06:43,326 --> 00:06:50,318
高速unionと呼ばれます。それでは、このコードが
大きな問題に対して効率的かを見ていきましょう。

62
00:06:50,582 --> 00:06:57,657
まぁ、残念ながら高速unionは速いのですが、

63
00:06:57,657 --> 00:07:04,042
同時に遅すぎるのです。高速findとは
少し異なる遅さなのです。

64
00:07:04,042 --> 00:07:10,005
数倍速いこともありますが、
数倍遅すぎることもあるのです。

65
00:07:10,005 --> 00:07:16,256
高速unionの欠点は、木がとても
高くなってしまうことがあることです。

66
00:07:16,256 --> 00:07:22,065
これはつまり、find操作がとても高くついて
しまうということです。長くひょろっとした

67
00:07:22,065 --> 00:07:28,432
木をかき分けていくことになります。各オブジェクトは
次の要素を指しているだけですから

68
00:07:28,432 --> 00:07:33,976
底にあるオブジェクトに対するfind操作は木を
すべて上っていく処理になります。

69
00:07:34,183 --> 00:07:40,184
コストは、単にfind操作を行うだけで
配列のアクセス量が増えてしまいます。

70
00:07:40,184 --> 00:07:44,013
たくさん操作をすれば遅すぎるでしょう。