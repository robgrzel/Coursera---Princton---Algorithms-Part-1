1
00:00:03,054 --> 00:00:09,019
欢迎回来 今天会讲解一些有趣的符号表应用

2
00:00:09,019 --> 00:00:15,011
和用于解决几何数据处理的二元查找树数据结构

3
00:00:15,011 --> 00:00:21,413
那么 让我们来看一下吧

4
00:00:21,413 --> 00:00:27,378
我们将讨论的主体是几何对象 
而非字符串和数字之类的简单键

5
00:00:27,378 --> 00:00:33,338
比方说 你要讨论的几何对象是平面上的点

6
00:00:33,338 --> 00:00:38,346
并且指定了一个边平行于坐标轴的矩形

7
00:00:38,346 --> 00:00:43,404
你可能要问 哪些点在矩形内部

8
00:00:43,404 --> 00:00:48,200
或者有多少点在矩形内部

9
00:00:48,200 --> 00:00:54,011
也有可能你正在处理的是多个矩形
你有一系列的矩形并想知道哪些相交

10
00:00:54,011 --> 00:01:00,291
或者有多少交点

11
00:01:00,291 --> 00:01:05,837
这些都是有广泛应用的有趣的问题

12
00:01:05,837 --> 00:01:11,806
遍布于计算机设计，游戏和电影
以及如数据库一般的抽象物

13
00:01:11,806 --> 00:01:17,849
和其他可能用到多个键或多维数组的情况

14
00:01:18,065 --> 00:01:24,856
在各类相似的符号表应用中

15
00:01:24,856 --> 00:01:30,175
这个想法（讨论几何图形而非字符串和数字）
有着非常有趣的延伸

16
00:01:30,175 --> 00:01:34,300
并且，出乎意料的是
 二元查找树和先前提及过的关联算法

17
00:01:34,300 --> 00:01:39,774
将会为这个领域内一些重要问题
提供非常高效的解决方案

18
00:01:39,774 --> 00:01:45,943
同时也确实在这些类型的应用中
激活了新开发和新技术

19
00:01:45,943 --> 00:01:51,135
所以 一开始
我们先看一个简单的问题

20
00:01:51,135 --> 00:01:56,761
即一维区间搜索
它构成了搜索问题的基础

21
00:01:56,761 --> 00:02:02,146
它是我们之前给过的有序符号表API的一个小扩展

22
00:02:02,146 --> 00:02:07,837
我们会进行两个操作
区间搜索 和 区间计数

23
00:02:07,837 --> 00:02:12,797
一维意味着我们只有一个键
所以我们会插入一个键值对

24
00:02:12,797 --> 00:02:19,116
然后我们将要实现搜索某个键

25
00:02:19,116 --> 00:02:24,770
并获得与这个键关联的值
且能够删除这个键值对

26
00:02:24,770 --> 00:02:30,703
这样的话我们就需要区间查找和区间计数这些操作
找出在给定的两个键之间的所有键

27
00:02:30,703 --> 00:02:36,083
或者给出在指定的两个键之间有多少个键

28
00:02:36,083 --> 00:02:42,251
对于右边这个例子
我们插入了若干键并按序显示它们

29
00:02:42,251 --> 00:02:47,992
那么 你可能会问
在 g和 k之间有多少个键啊？

30
00:02:47,992 --> 00:02:53,780
在这个例子中 只有两个
接着客户可能会问

31
00:02:53,780 --> 00:02:59,598
这两个键都是什么？
你就会想要返还这些键

32
00:02:59,598 --> 00:03:06,010
在数据库中 这是一个很普通的操作
你想要返还

33
00:03:06,010 --> 00:03:11,335
薪资在一百万到一千万之间的纳税人人数
还有这些人都是谁等

34
00:03:11,335 --> 00:03:17,431
所以说 区间查找是非常重要的基础操作

35
00:03:17,431 --> 00:03:23,459
在几何解释中
 我们把键看作一条线上的点

36
00:03:23,459 --> 00:03:29,627
键值对同理也可以抽象成线上的点

37
00:03:29,627 --> 00:03:34,856
我们可以将字母转换为数字
我们也可以将键当做数字

38
00:03:34,856 --> 00:03:41,119
然后我们要做的是在给定的一维区间上
找到这些点或给这些点计数

39
00:03:41,575 --> 00:03:47,272
我们应该如何实现它呢?
这是一个和符号表问题非常相似基础问题

40
00:03:47,272 --> 00:03:52,356
我们可以在一个无序数组中考察这些东西

41
00:03:52,356 --> 00:03:57,529
把它们都放入一个数组中
之后的插入操作会很快

42
00:03:57,529 --> 00:04:03,254
我们只需把它添加到数组的尾端
我们可能不得不给数组扩容

43
00:04:03,254 --> 00:04:08,371
但这样并没有什么益处
对于大数量的键来说

44
00:04:08,371 --> 00:04:13,899
为了给指定区间内的键计数
就不得不检查所有的键

45
00:04:13,899 --> 00:04:19,711
并检测它们是否存在于区间内

46
00:04:19,711 --> 00:04:26,043
然后以相同的方式返还它们
所以花费在大数据量上时间是线性增长的

47
00:04:26,267 --> 00:04:32,638
如果把键按照二元查找的顺序的存储 
为了保证在插值时数组有序

48
00:04:32,638 --> 00:04:38,591
你可能需要把较大的键移动不止一个位置
诸如此类不一而足

49
00:04:38,596 --> 00:04:44,209
或者说符号表完成了我们在二元查找中的基础步骤

50
00:04:44,406 --> 00:04:49,662
所以插入操作的时间是线性的

51
00:04:49,662 --> 00:04:55,329
然而后续则可以用二元查找来找到两个端点
这样只需要花费正比于Log N的时间

52
00:04:55,329 --> 00:05:00,631
然后 你可以计算出有多少个键

53
00:05:00,631 --> 00:05:06,243
或者返还最小索引和最大索引间区间之内的所有键

54
00:05:06,243 --> 00:05:12,027
所以说这些基础步骤对于大数据量的键而言并不适用

55
00:05:12,027 --> 00:05:18,179
因为它们需要线性的操作时间

56
00:05:18,179 --> 00:05:24,035
我们真正想要的是在插入和计数上
正比于Log N的操作时间

57
00:05:24,035 --> 00:05:29,186
对于区间查找而言
我们需要接触每个要返还的键

58
00:05:29,186 --> 00:05:35,413
因此运行时间将会和键的数量成正比

59
00:05:35,413 --> 00:05:43,042
但不管怎么说 那些还是合理的目标 
并且很容易实现

60
00:05:43,042 --> 00:05:51,545
那么[咳嗽]对一维区间内的计数是怎么样实现的呢?

61
00:05:51,545 --> 00:05:58,014
我们要做的只是把这些键保存在二元查找树中

62
00:05:58,014 --> 00:06:03,484
并观察排名函数在二元查找树中的实现过程

63
00:06:03,484 --> 00:06:09,342
对于每个键而言
我们可以计算有多少个绝对小于目标的键

64
00:06:09,342 --> 00:06:15,508
在这个例子中 E的排名是 2 
H 的排名是3，依次类推

65
00:06:15,508 --> 00:06:21,413
在二元查找树中 当我们做有序遍历时
这些排名不断变大

66
00:06:21,413 --> 00:06:27,662
同时这又很容易计算。
你需要保证该rank树有一个空间

67
00:06:27,662 --> 00:06:33,813
或者留一块和树一样的空间（存这些数字），然后就很容易实现

68
00:06:33,813 --> 00:06:40,760
那么在 E和 S之间由多少个键呢?
一 、 二

69
00:06:40,760 --> 00:06:51,297
三 、四 、五
事实上区别仅仅是

70
00:06:51,623 --> 00:07:00,361
查找区间内的高位数在表中则 rank值加一
否则不加一

71
00:07:00,361 --> 00:07:08,274
所以说 E和 S之间的键数和 E和 T之间的键数是相同的 都是5

72
00:07:08,274 --> 00:07:15,192
在 F和 T之间 只有四个键
在二元搜索树中，1维区间计数

73
00:07:15,192 --> 00:07:22,412
是一种很容易以Log时间运行的计算方法

74
00:07:22,412 --> 00:07:28,297
当我们搜索时检查过的节点数是

75
00:07:28,297 --> 00:07:33,789
起点到最低点的路长与起点到最高点的路长之和

76
00:07:33,976 --> 00:07:39,595
这个时间正比于 log N
这就是区间搜索

77
00:07:39,595 --> 00:07:46,018
我们只是做了一个迭代搜索
要找到所有低点与高点间的键

78
00:07:46,214 --> 00:07:51,472
在左半棵树查找是否有在范围内的键

79
00:07:51,472 --> 00:07:57,106
查看当前节点
再查看右半棵树是否有区间内的键

80
00:07:57,106 --> 00:08:02,555
很容易识别它们是否在区间内 通过

81
00:08:02,555 --> 00:08:08,476
检查区间是否与根重叠
所以 如果我们

82
00:08:08,476 --> 00:08:14,469
要找所有 F和 T之间的键
我们要看根 S的两个子树

83
00:08:14,469 --> 00:08:19,643
但我们不用看 E的左子树因为它们都比 E小

84
00:08:19,643 --> 00:08:26,018
肯定也比 F小
所以我们不用管那里

85
00:08:26,018 --> 00:08:31,419
除此以外 它就是一个用来找所有键的迭代搜索树的变形方法

86
00:08:31,635 --> 00:08:37,702
很容易看出运行时间是正比于

87
00:08:37,702 --> 00:08:47,518
返回的键的数量加 log N
所以 这就是通过二分搜索树实现的一维区间查找

88
00:08:47,518 --> 00:08:51,040