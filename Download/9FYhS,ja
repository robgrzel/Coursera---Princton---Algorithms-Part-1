1
00:00:01,072 --> 00:00:07,043
次はコンパレータを見てみましょう。Java の機能でソートで役に立ちます。 

2
00:00:07,043 --> 00:00:12,034
データには異なるソートキーやソート順があります。

3
00:00:12,034 --> 00:00:18,001
これには馴染みがあります。たとえば音楽ライブラリなどで

4
00:00:18,001 --> 00:00:23,177
アーティスト名でソートしますね。この場合では b を見ています。またある時は

5
00:00:23,177 --> 00:00:29,190
曲名で探すために、曲名でソートしたいと思う事もあります。

6
00:00:29,190 --> 00:00:34,799
同じデータで異なるソートキーを使っています。どうやればこんな感じで自然に

7
00:00:34,799 --> 00:00:40,286
Java でのソートを行なえるでしょうか？実装に際して

8
00:00:40,286 --> 00:00:45,839
あらゆるデータ型のソートが可能なように、Comparable インターフェイスを使います。

9
00:00:45,839 --> 00:00:50,578
コンセプトは、データには大抵そうなってほしいと思う自然な並び順があって

10
00:00:50,578 --> 00:00:55,542
それが Comparable インターフェイスの姿です。

11
00:00:55,542 --> 00:01:01,385
それとは別に Comparator と呼ばれる違ったインターフェイスもあります。

12
00:01:01,385 --> 00:01:06,958
同じデータ型であっても、あらゆる違った順番でソートする際に使います。

13
00:01:07,196 --> 00:01:14,036
Comparator インターフェイスで実装するメゾッドは

14
00:01:14,036 --> 00:01:19,882
compare() でジェネリック型の二つのキーを比較します。

15
00:01:19,882 --> 00:01:25,524
それは全順序でなければなりません。馴染みのある例は文字列です。

16
00:01:25,524 --> 00:01:30,594
文字列をソートする時には、とても多くの方法があります。

17
00:01:30,594 --> 00:01:35,974
アルファベット順であったり、大小文字を区別したり

18
00:01:35,974 --> 00:01:41,034
そもそも違う並び順をもった言語であったりします。

19
00:01:41,034 --> 00:01:45,767
文字列をソートするとは言っても、異なる並び順、あらゆる並び順を実装します。

20
00:01:45,767 --> 00:01:51,807
それが Comparator インターフェイスの役目です。

21
00:01:51,807 --> 00:01:59,635
Java のシステム実装のソートは違った [cough] やり方になります。

22
00:01:59,635 --> 00:02:06,183
そのやり方は、Comparator オブジェクトを作って

23
00:02:06,183 --> 00:02:12,679
Java ソートの第二引数に渡します。同じ事が独自のソートでも出来ます。

24
00:02:12,679 --> 00:02:17,494
分離する考え方です。データ型の定義と

25
00:02:17,494 --> 00:02:22,139
その型での要素の比較方法を切り離します。

26
00:02:22,144 --> 00:02:26,412
自然順序の場合は、データ型に比較方法の定義を含めます。

27
00:02:26,412 --> 00:02:31,181
Comparator を使うと、データ型の外から、しかも後でいつでもできます。

28
00:02:31,181 --> 00:02:35,642
String 型は Java のシステム実装ですが、各自の文字列の並び順を

29
00:02:35,642 --> 00:02:42,255
Comparator を使って定義できます。というわけで我々の実装では

30
00:02:42,255 --> 00:02:47,963
この例のように Comparator を受け入れるやり方に変更できます。

31
00:02:47,963 --> 00:02:53,398
Comparator のために、Comparable の代わりに Object 配列を渡します。

32
00:02:53,398 --> 00:02:58,787
そして第二引数として渡すのが Comparator です。

33
00:02:58,787 --> 00:03:04,323
less メゾッドは comparator を引数にとり、これが

34
00:03:04,323 --> 00:03:09,380
実際に compare メゾッドにより二つのキーを比較します。

35
00:03:09,380 --> 00:03:14,134
我々のソートをちょっと変更したものです。そして exch はもちろん Comparable を

36
00:03:14,134 --> 00:03:18,810
Object にしなければなりません。 Comparetor を使う簡易な変更で

37
00:03:18,810 --> 00:03:24,201
sort と less の引数に用いてオブジェクト配列をソートします。

38
00:03:24,201 --> 00:03:29,202
Comparator を受け入れる実装に変換するのは簡単です。

39
00:03:29,202 --> 00:03:35,969
Comparator の実装については、このコードを参考にできます。

40
00:03:35,969 --> 00:03:41,673
通して詳細を説明しませんので、内部クラスの二つのコンパレータの実装を見てください。

41
00:03:41,673 --> 00:03:47,074
この Student クラスには、二つのインスタンス変数があります。

42
00:03:47,074 --> 00:03:53,996
name と section です。最初の一つ ByName は

43
00:03:53,996 --> 00:03:59,671
生徒のコンパレータを実装しています。name で生徒を比較する時は

44
00:03:59,671 --> 00:04:05,749
文字列型の比較メゾッドを使います。section で比較する場合の実装は

45
00:04:05,749 --> 00:04:10,878
section 値の差を返します。

46
00:04:11,093 --> 00:04:17,511
小さければマイナス、等しければゼロ、大きければプラスです。

47
00:04:17,511 --> 00:04:25,185
このコードはコンパレータを実装する上で参考になる簡単な方法です。

48
00:04:25,185 --> 00:04:32,643
異なるキーでソートしなければならないなら。それでは [cough]

49
00:04:32,643 --> 00:04:38,629
これがどうなるかの例です。先程の Student クラスに実装したコンパレータで

50
00:04:38,629 --> 00:04:44,890
Java のソートを使った場合です。Student 型の配列を Array.sort に渡して

51
00:04:44,890 --> 00:04:50,686
BY_NAME のコンパレータを与えると、name 列のアルファベット順になります。

52
00:04:50,686 --> 00:04:56,137
そして section のコンパレータを与えたら

53
00:04:56,137 --> 00:05:02,148
二番目の列になります。あらゆるデータ処理アプリケーションで便利ですね。

54
00:05:02,148 --> 00:05:07,342
ここで思い出すのが、以前に話した

55
00:05:07,342 --> 00:05:13,226
グラハムスキャンにソートを使う点です。各点の比較が必要で

56
00:05:13,226 --> 00:05:19,020
点 p を始点とする極座標の角度で並び替えます。

57
00:05:19,020 --> 00:05:25,028
それは凸包でのグラハムスキャンアルゴリズムで必要になります。

58
00:05:25,028 --> 00:05:31,381
points は座標のオブジェクトです。そして必要なのは極角を計算するコードで、

59
00:05:31,381 --> 00:05:37,269
それを元に比較します。これを行なうのに簡単な方法は

60
00:05:37,269 --> 00:05:45,249
反時計回りの手法で、このテキストにある通りです。やることのほとんどは

61
00:05:45,249 --> 00:05:53,308
二つの点の ccw 関数でのチェックです。もしくはチェックするのは [cough] 

62
00:05:53,308 --> 00:05:59,167
点が p より上にあり、もう片方の点が下にあるかどうかです。そうでない場合が大抵ですが

63
00:05:59,167 --> 00:06:05,001
ccw を呼びます。再びこのコードの詳細を通して見る事は省きますが

64
00:06:05,001 --> 00:06:10,082
つまりは二次元座標点のコンパレータの実装です。compare メゾッドを実装しています。

65
00:06:10,082 --> 00:06:16,085
二つの点を引数に取って、比較するためのちょっとした計算をしています。

66
00:06:16,085 --> 00:06:22,322
このコードは、凸包でのグラハムスキャンのために、システムの sort メゾッドや

67
00:06:22,322 --> 00:06:27,048
あらゆるソートを適用する際の基本になります。

68
00:06:27,048 --> 00:06:32,424
以上が凸包でのグラハムスキャン法の基本です。

69
00:06:32,424 --> 00:06:38,025
凸包は前回講義の最後でやりましたね。